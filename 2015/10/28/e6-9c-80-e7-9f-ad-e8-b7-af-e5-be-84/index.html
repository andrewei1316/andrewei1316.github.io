<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.andrewei.me","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述最短路径问题是图论研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。 算法具体的形式包括：">
<meta property="og:type" content="article">
<meta property="og:title" content="最短路径">
<meta property="og:url" content="https://blog.andrewei.me/2015/10/28/e6-9c-80-e7-9f-ad-e8-b7-af-e5-be-84/index.html">
<meta property="og:site_name" content="Andrewei">
<meta property="og:description" content="概述最短路径问题是图论研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。 算法具体的形式包括：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.andrewei.me/images/2015/10/shortest_rude.png">
<meta property="og:image" content="https://blog.andrewei.me/images/2015/10/1.jpg">
<meta property="og:image" content="https://blog.andrewei.me/images/2015/10/2.jpg">
<meta property="og:image" content="https://blog.andrewei.me/images/2015/10/3.jpg">
<meta property="og:image" content="https://blog.andrewei.me/images/2015/10/20151027144908.png">
<meta property="article:published_time" content="2015-10-28T11:47:36.000Z">
<meta property="article:modified_time" content="2018-04-09T01:16:07.261Z">
<meta property="article:author" content="Andrewei">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="图论">
<meta property="article:tag" content="最短路">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.andrewei.me/images/2015/10/shortest_rude.png">

<link rel="canonical" href="https://blog.andrewei.me/2015/10/28/e6-9c-80-e7-9f-ad-e8-b7-af-e5-be-84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>最短路径 | Andrewei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Andrewei" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Andrewei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.andrewei.me/2015/10/28/e6-9c-80-e7-9f-ad-e8-b7-af-e5-be-84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Andrewei">
      <meta itemprop="description" content="There's no feat, but what we make.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrewei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          最短路径
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-28 19:47:36" itemprop="dateCreated datePublished" datetime="2015-10-28T19:47:36+08:00">2015-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-04-09 09:16:07" itemprop="dateModified" datetime="2018-04-09T09:16:07+08:00">2018-04-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">图论</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最短路径问题是图论研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。 算法具体的形式包括：<a id="more"></a></p>
<ol>
<li>确定起点的最短路径问题 - 即已知起始结点，求最短路径的问题。</li>
<li>确定终点的最短路径问题 - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。</li>
<li>确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。</li>
<li>全局最短路径问题 - 求图中所有的最短路径。</li>
</ol>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><p>用于解决最短路径问题的算法被称做“最短路径算法”， 有时被简称作“路径算法”。 最常用的路径算法有：</p>
<ol>
<li>Dijkstra 算法</li>
<li>A*算法</li>
<li>SPFA 算法</li>
<li>Bellman-Ford 算法</li>
<li>Floyd-Warshall 算法</li>
<li>Johnson 算法<br>所谓单源最短路径问题是指：已知图 G=（V，E），我们希望找出从某给定的源结点 S∈V 到 V 中的每个结点的最短路径。</li>
</ol>
<h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>设 G=(V,E)是一个带权有向图，把图中顶点集合 V 分成两组，第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，以后每求得一条最短路径 , 就将加入到集合 S 中，直到全部顶点都加入到 S 中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中。在加入的过程中，总保持从源点 v 到 S 中各顶点的最短路径长度不大于从源点 v 到 U 中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S 中的顶点的距离就是从 v 到此顶点的最短路径长度，</p>
<p>U 中的顶点的距离，是从 v 到此顶点只包括 S 中的顶点为中间顶点的当前最短路径长度。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>初始时，S 只包含源点，即 $S＝{v}$，v 的距离为 0。U 包含除 v 外的其他顶点，即:U={其余顶点}，若 v 与 U 中顶点 u 有边，则&lt;u,v&gt;正常有权值，若 u 不是 v 的出边邻接点，则$&lt;u,v&gt;$权值为∞。</li>
<li>从 U 中选取一个距离 v 最小的顶点 k，把 k，加入 S 中（该选定的距离就是 v 到 k 的最短路径长度）。</li>
<li>以 k 为新考虑的中间点，修改 U 中各顶点的距离；若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值的顶点 k 的距离加上边上的权。</li>
<li>重复步骤 b 和 c 直到所有顶点都包含在 S 中。</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=" "></a> <img src="/images/2015/10/shortest_rude.png"></h3><h3 id="示例代码（邻接表-优先队列）"><a href="#示例代码（邻接表-优先队列）" class="headerlink" title="示例代码（邻接表+优先队列）"></a>示例代码（邻接表+优先队列）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (1 &lt;&lt; 30) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> v, w, n; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Struct Node&#123;    </span><br><span class="line">    <span class="keyword">int</span> v, w; </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &gt; b.w; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], dis[N], n, m, e; <span class="keyword">bool</span> vis[N];</span><br><span class="line">Edge edge[N * /<span class="number">2</span>]; </span><br><span class="line"><span class="built_in">priority_queue</span> &lt; Node &gt; que; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    e = <span class="number">0</span>;     </span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) que.pop();</span><br><span class="line">    fill(head, head + N, <span class="number">-1</span>);</span><br><span class="line">    fill(dis, dis + N, M);     </span><br><span class="line">    fill(vis, vis + N, <span class="literal">false</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;     </span><br><span class="line">    edge[e].v = v;     </span><br><span class="line">    edge[e].w = w;     </span><br><span class="line">    edge[e].n = head[u];</span><br><span class="line">    head[u] = e++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;     </span><br><span class="line">    Node t;     </span><br><span class="line">    t.v = s; </span><br><span class="line">    t.w = <span class="number">0</span>;     </span><br><span class="line">    dis[t.v] = t.w;     </span><br><span class="line">    que.push(t);     </span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;         </span><br><span class="line">        t = que.top();         </span><br><span class="line">        que.pop();         </span><br><span class="line">        <span class="keyword">if</span>(vis[t.v]) <span class="keyword">continue</span>;        </span><br><span class="line">        vis[t.v] = <span class="literal">true</span>;         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[t.v]; i != <span class="number">-1</span>; i = edge[i].n) </span><br><span class="line">            <span class="keyword">if</span>(!vis[edge[i].v] &amp;&amp; dis[edge[i].v] &gt; dis[t.v] + edge[i].w)&#123;                 </span><br><span class="line">                Node tt;                 </span><br><span class="line">                tt.v = edge[i].v; </span><br><span class="line">                dis[edge[i].v] = tt.w = dis[t.v] + edge[i].w;                 </span><br><span class="line">                que.push(tt); </span><br><span class="line">            &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF &amp;&amp; n)&#123;         </span><br><span class="line">        init();        </span><br><span class="line">        <span class="keyword">int</span> a, b, c;         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;             </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);             </span><br><span class="line">            addedge(a, b, c);             </span><br><span class="line">            addedge(b, a, c); </span><br><span class="line">        &#125; </span><br><span class="line">        Dijkstra(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[n]); </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>邻接矩阵 $O(n^{2})$, 邻接表+优先队列 $O(e logv)$.</p>
<h2 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>弗洛伊德（Floyd）算法过程：</p>
<ol>
<li>用 $D[v][w]$记录每一对顶点的最短距离。</li>
<li>依次扫描每一个点，并以其为基点再遍历所有每一对顶点 D[][]的值，看看是否可用过该基点让这对顶点间的距离更小。</li>
</ol>
<h3 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h3><p>最短距离有三种情况：</p>
<ul>
<li>两点的直达距离最短。（如下图&lt;v,x&gt;）</li>
<li>两点间只通过一个中间点而距离最短。（图&lt;v,u&gt;）</li>
<li>两点间用通过两各以上的顶点而距离最短。（图&lt;v,w&gt;）<br>对于第一种情况：在初始化的时候就已经找出来了且以后也不会更改到。对于第二种情况：弗洛伊德算法的基本操作就是对于每一对顶点，遍历所有其它顶点，看看可否通过这一个顶点让这对顶点距离更短，也就是遍历了图中所有的三角形（算法中对同一个三角形扫描了九次，原则上只用扫描三次即可，但要加入判断，效率更低）。</li>
</ul>
<p>对于第三种情况：如下图的五边形，可先找一点（比如 x，使$&lt;v,u&gt;=2$），就变成了四边形问题，再找一点（比如 y,使&lt;u,w&gt;=2），可变成三角形问题了（v,u,w），也就变成第二种情况了，由此对于 n 边形也可以一步步转化成四边形三角形问题。（这里面不用担心哪个点要先找哪个点要后找，因为找了任一个点都可以使其变成（n－1）边形的问题）。结合代码 并参照上图所示 我们来模拟执行下 这样才能加深理解：</p>
<p>第一关键步骤：当 k 执行到 x，i=v,j=u 时，计算出 v 到 u 的最短路径要通过 x，此时 v、u 联通了。<img src="/images/2015/10/1.jpg"></p>
<p>第二关键步骤：当 k 执行到 u，i=v，j=y，此时计算出 v 到 y 的最短路径的最短路径为 v 到 u，再到 y(此时 v 到 u 的最短路径上一步我们已经计算过来，直接利用上步结果)。</p>
<p>第三关键步骤：当 k 执行到 y 时，i=v，j=w，此时计算出最短路径为 v 到 y(此时 v 到 y 的最短路径长在第二步我们已经计算出来了)，再从 y 到 w。</p>
<p><strong>依次扫描每一点**</strong>(k)<strong>**，并以该点作为中介点，计算出通过 **</strong>k <strong><strong>点的其他任意两点</strong></strong>(i,j)<strong>**的最短距离，这就是 **</strong>floyd <strong>**算法的精髓！</strong></p>
<p>同时也解释了为什么 k 点这个中介点要放在最外层循环的原因.</p>
<p><strong>动态规划的解释：</strong></p>
<p>在动态规划算法中，处于首要位置、且也是核心理念之一的就是状态的定义。在这里，把 d[k][i][j]定义成：</p>
<p>“只能使用第 1 号到第 k 号点作为中间媒介时，点 i 到点 j 之间的最短路径长度。”</p>
<p>图中共有 n 个点，标号从 1 开始到 n。因此，在这里，k 可以认为是动态规划算法在进行时的一种层次，或者称为“松弛操作”。d[1][i][j]表示只使用 1 号点作为中间媒介时，点 i 到点 j 之间的最短路径长度；d[2][i][j]表示使用 1 号点到 2 号点中的所有点作为中间媒介时，点 i 到点 j 之间的最短路径长度；d[n-1][i][j]表示使用 1 号点到 (n-1)号点中的所有点作为中间媒介时，点 i 到点 j 之间的最短路径长度 d[n][i][j]表示使用 1 号到 n 号点时，点 i到点 j 之间的最短路径长度。有了状态的定义之后，就可以根据动态规划思想来构建动态转移方程。</p>
<p>动态转移的基本思想可以认为是建立起某一状态和之前状态的一种转移表示。按照前面的定义，d[k][i][j]是一种使用 1 号到 k 号点的状态，可以想办法把这个状态通过动态转移，规约到使用 1 号到(k-1)号的状态，即 d[k1][i][j]。对于 d[k][i][j]（即使用 1 号到 k 号点中的所有点作为中间媒介时，i 和 j 之间的最短路径），可以分为两种情况：（1）i 到 j 的最短路不经过 k；（2）i 到 j 的最短路经过了 k。不经过点 k 的最短路情况下，$d[k][i][j]=d[k1][i][j]$。经过点 k 的最短路情况下，$d[k][i][j]=d[k-1][i][k]+d[k-1][k][j]$。因此，综合上述两种情况，便可以得到 Floyd 算法的动态转移方程：$$d[k][i][j] = min(d[k-1][i][j], d[k-1][i][k]+d[k-1][k][j]) (k,i,j \epsilon [1,n])$$</p>
<p>最后，d[n][i][j]就是所要求的图中所有的两点之间的最短路径的长度。在这里，需要注意上述动态转移方程的初始（边界）条件，即 d[0][i][j]=w(i, j)，也就是说在不使用任何点的情况下（“松弛操作”的最初），两点之间最短路径的长度就是两点之间边的权值（若两点之间没有边，则权值为 INF，且我比较偏向在 Floyd 算法中把图用邻接矩阵的数据结构来表示，因为便于操作）。当然，还有 $d[i][i]=0(i\epsilon [1,n])$。</p>
<p>这样我们就可以编写出最为初步的 Floyd 算法代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd_original</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)             </span><br><span class="line">            d[<span class="number">0</span>][i][j] = graph[i][j];     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;             </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123; </span><br><span class="line">                d[k][i][j] = min(d[k<span class="number">-1</span>][i][j], d[k<span class="number">-1</span>][i][k] + d[k<span class="number">-1</span>][k][j]); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几乎所有介绍动态规划中最为著名的“0/1 背包”问题的算法书籍中，都会进一步介绍利用滚动数组的技巧来进一步减少算<br>的空<br>间复杂度，使得 0/1 背包只需要使用一维数组就可以求得最优解。而在各种资料中，最为常见的 Floyd 算法也都是用了二维数组来表示状态。那么，在 Floyd 算法中，是如何运用滚动数组的呢？</p>
<p>再次观察动态转移方程 $$d[k][i][j] = min(d[k-1][i][j], d[k-1][i][k]+d[k-1][k][j])$$ <span style="line-height: 1.5;">可以发现每一个第 k 阶段的状态（d[k][i][j]），所依赖的都是前一阶段（即第 k-1 阶段）的状态（如 d[k-1][i][</span><span style="line-height: 1.5;">j]，d[k-1][i][k]和 d[k-1][k][j]）。</span></p>
<p>右图描述了在前面最初试的 Floyd 算法中，计算状态 d[k][i][j]时，d[k-1][][]和 d[k][][]这两个二维数组的情况（d[k-1][][]表示第 k-1 阶段时，图中两点之间最短路径长度的二维矩阵；d[k][][]表示第 k 阶段时，图中两点之间最短路径长度的二维矩阵）。红色带有箭头的有向线段指示了规划方向。灰色表示已经算过的数组元素，白色代表还未算过的元素。由于 d[k-1][][]和 d[k][][]是两个相互独立的二维数组，因此利用 d[k-1][i][j]，d[k-1][i][k] 和 d[k-1][k][j]（皆处于上方的二维数组中）来计算 d[k][i][j]时没有任何问题。</p>
<p>那如何利用一个二维数组来实现滚动数组，以减小空间复杂度呢？</p>
<p>右图是使用滚动数组，在第 k 阶段，计算 d[i][j]时的情况。此时，由于使用 d[][]这个二维数组作为滚动数组，在各个阶段的计算中被重复使用，因此数组中表示阶段的那一维也被取消了。在这图中，白色的格子，代表最新被计算过的元素（即第 k 阶段的新值），而灰色的格子中的元素值，其实保存的还是上一阶段（即第 k-1 阶段）的旧值。因此，在新的 d[i][j]还未被计算出来时，d[i][j]中保存的值其实就对应之前没有用滚动数组时 d[k-1][i][j] 的值。此时，动态转移方程在隐藏掉阶段索<br>引后就变为：$$d[i][j] = min(d[i][j], d[i][k]+d[k][j]) (k,i,j\epsilon [1,n])$$ 赋值号左侧 d[i][j]就是我们要计算的第 k 阶段是 i 和 j 之间的最短路径长度。在这里，需要确保赋值号右侧的d[i][j], d[i][k]和 d[k][j]的值是上一阶段（k-1 阶段）的值。前面已经分析过了，在新的 d[i][j]算出之前，d[i][j]元素保留的值的确就是上一阶段的旧值。但至于 d[i][k]和 d[k][j]呢？我们无法确定这两个元素是落在白色区域（新值）还是灰色区域（旧值）。好在有这样一条重要的性质，dp[k-1][i][k]和 dp[k-1][k][j]是不会在第 k 阶段改变大小的。也就是说，凡是和 k 节点相连的边，在第 k 阶段的值都不会变。如何简单证明呢？我们可以把 j=k 代入之前的$$ d[k][i][j]=min(d[k-1][i][j], d[k-1][i][k]+d[k-1][k][j]) $$方程中，即：</p>
<p>$$d[k][i][k]</p>
<p>= min(d[k-1][i][k], d[k-1][i][k]+d[k-1][k][k])</p>
<p>= min(d[k-1][i][k], d[k-1][i][k]+0)</p>
<p>= d[k-1][i][k]$$</p>
<p>也就是说在第 k-1 阶段和第 k 阶段，点 i 和点 k 之间的最短路径长度是不变的。相同可以证明，在这两个阶段中，点 k 和点 j 之间的的最短路径长度也是不变的。因此，对于使用滚动数组的转移方程$$ d[i][j] = min(d[i][j], d[i][k]+d[k][j]) $$来说，赋值号右侧的 d[i][j], d[i][k]和 d[k][j]的值都是上一阶段（k-1 阶段）的值，可以放心地被用来计算第 k 阶段时 d[i][j]的值。</p>
<p><img src="/images/2015/10/2.jpg"><br><img src="/images/2015/10/3.jpg"></p>
<p>利用滚动数组改写后的 Floyd 算法代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)  </span><br><span class="line">                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>因此，通过这篇文章的分析，我们可以发现，Floyd 算法的的确确是一种典型的动态规划算法；理解 Floyd 算法，也可以帮助我们进一步理解动态规划思想。</p>
<h3 id="示例代码（含记录路径）"><a href="#示例代码（含记录路径）" class="headerlink" title="示例代码（含记录路径）"></a>示例代码（含记录路径）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (1 &lt;&lt; 20) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[N][N], path[N][N]; </span><br><span class="line"><span class="keyword">int</span> n, m; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)              <span class="comment">// 初始化 path 数组         </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)             </span><br><span class="line">            path[i][j] = i;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)             </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)                 </span><br><span class="line">                <span class="keyword">if</span>(mp[i][k] + mp[k][j] &lt; mp[i][j])&#123;                     </span><br><span class="line">                    mp[i][j] = mp[i][k] + mp[k][j];                     </span><br><span class="line">                    path[i][j] = path[k][j]; </span><br><span class="line">                &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF)&#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 输入图 */</span> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)             </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;                 </span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;mp[i][j]);                 </span><br><span class="line">                mp[i][j] = mp[i][j]; </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 求解 */</span>         </span><br><span class="line">        floyd(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 输出 */</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Origin -&gt; Dest      Distance        Path\n&quot;</span>);        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;             </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;                 </span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;                 </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;     %d -&gt; %d          &quot;</span>, i + <span class="number">1</span>, j + <span class="number">1</span>);                 </span><br><span class="line">                <span class="keyword">if</span>(mp[i][j] == M) <span class="built_in">printf</span>(<span class="string">&quot;No answer\n&quot;</span>);                 </span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%2d             &quot;</span>, mp[i][j]);                 </span><br><span class="line">                <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; sta;                 </span><br><span class="line">                <span class="keyword">int</span> k = j;                 </span><br><span class="line">                <span class="keyword">do</span>&#123;                     </span><br><span class="line">                    k = path[i][k];                     </span><br><span class="line">                    sta.push(k);                 </span><br><span class="line">                &#125;<span class="keyword">while</span>(k != i); </span><br><span class="line">                <span class="keyword">while</span>(!sta.empty()) <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, sta.top() + <span class="number">1</span>), sta.pop();                 </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, j + <span class="number">1</span>); </span><br><span class="line">            &#125;        					</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="用-Floyd-算法思想求最小环"><a href="#用-Floyd-算法思想求最小环" class="headerlink" title="用 **Floyd **算法思想求最小环"></a>用 **Floyd **算法思想求最小环</h3><p>Floyd 算法在进行时会不断更新矩阵 dist(k)。设 dist[k，i，j]表示从结点 i 到结点 j 且满足所有中间结点，它们均属于集合{1，2，⋯ ，k}的一条最短路径的权。其中 dist[0，i,j ]即为初始状态 i 到 j 的直接距离。对于一个给定的赋权有向图， 求出其中权值和最小的一个环。我们可以将任意一个环化成如下形式：u-&gt;k-&gt;v -&gt;(x1-&gt; x2-&gt; ⋯ xm1)-&gt; u(u 与 k、k 与 v 都是直接相连的)，其中 v -&gt;(x1-&gt; 2-&gt; ⋯ m)-&gt; u 是指 v 到 u 不经过 k 的一种路径。</p>
<p>在 u，k，v 确定的情况下，要使环权值最小， 则要求 (x1 一&gt;x2-&gt;⋯一&gt;xm)-&gt;u 路径权值最小．即要求其为 v 到 u 不经过 k 的最短路径，则这个经过 u，k，v 的环的最短路径就是：[v 到 u 不包含 k 的最短距离]+dist[O， u，k]+dist[O，k，v]。我们用 Floyd 只能求出任意 2 点间满足中间结点均属于集合{1，2，⋯ ，k}的最短路径，可是我们如何求出 v 到 u 不包含 k 的最短距离呢?</p>
<p>现在我们给 k 加一个限制条件：k 为当前环中的序号最大的节点(简称最大点)。因为 k 是最大点，所以当前环中没有任何一个点≥k，即所有点都 &lt; k。因为 v-&gt;(x1-&gt;x2-&gt;……xm)-&gt;u 属于当前环，所以 x1，x2，⋯ ， xm &lt; k，即 x1，x2．⋯。xm≤k-1。这样，v 到 u 的最短距离就可以表示成 dist[k - 1 ,u,v]。dist[k - 1,v,u]表示的是从 v 到 u 且满足所有中间结点均属于集合{1，2，⋯ ，k - 1}的一条最短路径的权。接下来，我们就可以求出 v 到 u 不包含 k 的最短距离了。这里只是要求不包含 k，而上述方法用的是 dist[k - 1，v，u]，求出的路径永远不会包含 k+l，k+2，⋯ 。万一所求的最小环中包含 k+1，k+2，⋯ 怎么办呢?的确，如果最小环中包含比 k 大的节点，在当前 u,k,v 所求出的环显然不是那个最小环。然而我们知道，这个最小环中必定有一个最大点 kO，也就是说，虽然当前 k 没有求出我们所需要的最小环，但是当我们从 k 做到 kO 的时候，这个环上的所有点都小于 kO 了．也就是说在 k=kO 时一定能求出这个最小环。我们用一个实例来说明：假设最小环为 1—3—4—5—6—2—1。的确，在 u=l，v=4，k=3 时，k&lt;6，dist[3，4，1]的确求出的不是 4—5—6—2—1 这个环，但是，当 u=4，v=6，k=5 或 u=5，v=2，k=6 时，dist[k，v，u]表示的都是这条最短路径.所以我们在 Floyd 以后，只要枚举 u, v, k 三个变量即可求出最小环。时间复杂度为 O(n3)。我们可以发现，Floyd 和最后枚举 u, v, k 三个变量求最小环的过程都是 u,v,k 三个变量，所以我们可以将其合并。这样，我们在 k 变量变化的同时，也就是进行 Floyd 算法的同时，寻找最大点为 k 的最小环。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1100 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (1 &lt;&lt; 29) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[N][N], dis[N][N]; </span><br><span class="line"><span class="keyword">int</span> path[N], pre[N][N]; </span><br><span class="line"><span class="keyword">int</span> n, m, minc, num; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;             </span><br><span class="line">            mp[i][j] = M;             </span><br><span class="line">            dis[i][j] = M;             </span><br><span class="line">            pre[i][j] = i; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        <span class="keyword">if</span>(w &lt; mp[a][b])</span><br><span class="line">            dis[a][b] = dis[b][a] = mp[a][b] = mp[b][a] = w; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    minc = M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; j++)</span><br><span class="line">                <span class="keyword">if</span>(minc &gt; dis[i][j] + mp[j][k] + mp[k][i])&#123;</span><br><span class="line">                    minc = dis[i][j] + mp[j][k] + mp[k][i];</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> t = j;</span><br><span class="line">                    <span class="keyword">while</span>(t != i)&#123;</span><br><span class="line">                        path[num++] = t;</span><br><span class="line">                        t = pre[i][t];</span><br><span class="line">                    &#125;</span><br><span class="line">                    path[num++] = i;</span><br><span class="line">                    path[num++] = k;</span><br><span class="line">                &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j] &gt; dis[i][k] + dis[k][j])&#123;</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">                    pre[i][j] = pre[k][j]; </span><br><span class="line">                &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) !=EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        Floyd();</span><br><span class="line">        <span class="keyword">if</span>(minc == M) <span class="built_in">printf</span>(<span class="string">&quot;No solution.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, path[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, path[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>$O(n ^{3})$</p>
<h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Bellman-ford 算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写。即进行不停地松弛每次松弛把每条边都更新一下，若 n-1 次松弛后还能更新，则说明图中有负环，无法得出结果，否则就成功完成。Bellmanford 算法有一个小优化：每次松弛先设一个旗帜 flag，初值为 FALSE，若有边更新则赋值为 TRUE，最终如果还是 FALSE 则直接成功退出。Bellman-ford 算法浪费了许多时间做无必要的松弛。Dijkstra 算法中不允许边的权是负权，如果遇到负权，则可以采用 Bellman-Ford 算法。</p>
<p>Bellman-Ford 算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。对于给定的带权（有向或无向）图 G=（V,E），其源点为 s，加权函数 w 是 边集 E 的映射。对图 G 运行 Bellman-Ford 算法的结果是一个布尔值，表明图中是否存在着一个从源点 s 可达的负权回路。若不存在这样的回路，算法将给出从源点 s 到 图</p>
<p>G 的任意顶点 v 的最短路径 d[v]。</p>
<h3 id="适用条件-amp-范围"><a href="#适用条件-amp-范围" class="headerlink" title="适用条件**&amp;**范围"></a>适用条件**&amp;**范围</h3><p>1.单源最短路径(从源点 s 到其它所有顶点 v);</p>
<p>2.有向图&amp;无向图(无向图可以看作(u,v),(v,u)同属于边集 E 的有向图);</p>
<p>3.边权可正可负(如有负权回路输出错误提示);</p>
<p>4.差分约束系统;</p>
<h3 id="Bellman-Ford-算法描述"><a href="#Bellman-Ford-算法描述" class="headerlink" title="**Bellman-Ford **算法描述"></a>**Bellman-Ford **算法描述</h3><p>1,.初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0;</p>
<p>2.迭代求解：反复对边集 E 中的每条边进行松弛操作，使得顶点集 V 中的每个顶点 v 的最短距离估计值逐步逼近其最短距离；（运行|v|-1 次）</p>
<p>3.检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回 true，并且从源点可达的顶点 v 的最短距离保存在 d[v]中。</p>
<h3 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h3><p>首先指出，图的任意一条最短路径既不能包含负权回路，也不会包含正权回路，因此它最多包含|v|-1 条边。   其次，从源点 s 可达的所有顶点如果 存在最短路径，则这些最短路径构成一个以 s 为根的最短路径树。</p>
<p>Bellman-Ford 算法的迭代松弛操作，实际上就是按顶点距离 s 的层次，逐层生成这棵最短路径树的过程。</p>
<p>在对每条边进行 1 遍松弛的时候，生成了从 s 出发，层次至多为 1 的那些树枝。也就是说，找到了与 s 至多有 1 条边相联的那些顶点的最短路径；对每条边进行第 2 遍松弛的时候，生成了第 2 层次的树枝，就是说找到了经过 2 条边相连的那些顶点的最短路径……。因为最短路径最多只包含|v|-1 条边，所以，只需要循环|v|-</p>
<p>1 次。</p>
<p>每实施一次松弛操作，最短路径树上就会有一层顶点达到其最短距离，此后这层顶点的最短距离值就会一直保持不变，不再受后续松弛操作的影响。（但是，每次还要判断松弛，这里浪费了大量的时间，怎么优化？单纯的优化是否可行？）   如果没有负权回路，由于最短路径树的高度最多只能是|v|-1，所以最多经过|v|-1 遍松弛操作后，所有从 s 可达的顶点必将求出最短距离。如果 d[v]仍保持 +∞，则表明从 s 到 v 不可达。</p>
<p>如果有负权回路，那么第 |v|-1 遍松弛操作仍然会成功，这时，负权回路上的顶点不会收敛。</p>
<h3 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h3><p>首先介绍一下松弛计算。如图：松弛计算之前，点 B 的值是 8，但是点 A 的值加上边上的权重 2，得到 5，比点 B 的值（8）小，所以，点 B 的值减小为 5。这个过程的意义是，找到了一条通向 B 点更短的路线，且该路线是先经过点 A，然后通过权重为 2 的边，到达点B。</p>
<p>Bellman－Ford 算法可以大致分为三个部分<img src="/images/2015/10/20151027144908.png"></p>
<p>第一，初始化所有点。每一个点保存一个值，表示从原点到达这个点的距离，将原点的值设为 0，其它的点的值设为无穷大（表示不可达）。</p>
<p>第二，进行循环，循环下标为从 1 到 n－1（n 等于图中点的个数）。在循环内部，遍历所有的边，进行松弛计算。</p>
<p>第三，遍历途中所有的边（edge（u，v）），判断是否存在这样情况：</p>
<p>d（v） &gt; d (u) + w(u,v)</p>
<p>则返回 false，表示途中存在从源点可达的权为负的回路。</p>
<p>之所以需要第三部分的原因，是因为，如果存在从源点可达的权为负的回路。则 应为无法收敛而导致不能求出最短路径。</p>
<p>考虑右图：</p>
<p>经过第一次遍历后，点 B 的值变为 5，点 C 的值变为 8，这时，注意权重为－10 的边，这条边的存在，导致点 A 的值变为－2。（8＋ －10＝－2）第二次遍历后，点 B 的值变为 3，点 C 变为 6，点 A 变为－4。正是因为有一条负边在回路中，导致每次遍历后，各个点的值不断变小。</p>
<p>在回过来看一下 bellman－ford 算法的第三部分，遍历所有边，检查是否存在 d（v） &gt; d (u) + w(u,v)。因为第二部分循环的次数是定长的，所以如果存在无法收敛的情况，则肯定能够在第三部分中检查出来。比如此时，点 A 的值为－2，点 B 的值为 5，边 AB 的权重为 5，5 &gt; -2 + 5. 检查出来这条边没有收敛。</p>
<p>所以，Bellman－Ford 算法可以解决图中有权为负数的边的单源最短路径问。</p>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s; <span class="comment">//点，边，起点   </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="comment">//边       </span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">int</span> cost;   </span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line">Edge edge[N];</span><br><span class="line"><span class="keyword">int</span> dis[N], pre[N];   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman_Ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//初始化</span></span><br><span class="line">        dis[i] = (i == s ? <span class="number">0</span> : MAX);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cost)&#123; <span class="comment">//松弛（顺序一定不能反~）</span></span><br><span class="line">                dis[edge[j].v] = dis[edge[j].u] + edge[j].cost;</span><br><span class="line">                pre[edge[j].v] = edge[j].u; </span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>; <span class="comment">//判断是否含有负权回路   </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span>(dis[edge[i].v] &gt; dis[edge[i].u] + edge[i].cost)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_path</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123; <span class="comment">//打印最短路的路径</span></span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">    <span class="keyword">while</span>(root != pre[root])&#123; <span class="comment">//前驱</span></span><br><span class="line">        sta.push(root);</span><br><span class="line">        root = pre[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root);</span><br><span class="line">    <span class="keyword">while</span>(!sta.empty())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d&quot;</span>, sta.top());</span><br><span class="line">        sta.pop(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s))&#123;</span><br><span class="line">        fill(pre, pre + N, <span class="number">0</span>);</span><br><span class="line">        pre[s] = s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].cost);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Bellman_Ford())</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123; <span class="comment">//每个点最短路</span></span><br><span class="line">                <span class="keyword">if</span>(dis[i] == MAX)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;From %d to %d no way!\n&quot;</span>, s, i);</span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;From %d to %d : %d\n&quot;</span>, s, i, dis[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Path: &quot;</span>);</span><br><span class="line">                print_path(i);   </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;have negative circle\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>O(VE)</p>
<h2 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="SPFA 算法"></a>SPFA 算法</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>SPFA(Shortest Path Faster Algorithm)是 Bellman-Ford 算法的一种队列实现，减少了不必要的冗余计算。 SPFA——Shortest Path Faster Algorithm，它可以在 O(kE)的时间复杂度内求出源点到其他所有点的最短路径，可以处理负边。SPFA 的实现甚至比 Dijkstra 或者 Bellman_Ford 还要简单。</p>
<h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>设 Dist 代表 S 到 I 点的当前最短距离，Fa 代表 S 到 I 的当前最短路径中 I 点之前的一个点的编号。开始时 Dist 全部为+∞，只有 Dist[S]=0，Fa 全部为 0。</p>
<p>维护一个队列，里面存放所有需要进行迭代的点。初始时队列中只有一个点 S。用一个布尔数组记录每个点是否处在队列中。</p>
<p>每次迭代，取出队头的点 v，依次枚举从 v 出发的边 v-&gt;u，设边的长度为 len，判断 Dist[v]+len 是否小于 Dist[u]，若小于则改进 Dist[u]，将 Fa[u]记为 v，并且由于 S 到 u 的最短距离变小了，有可能 u 可以改进其它的点，所以若 u 不在队列中，就将它放入队尾。这样一直迭代下去直到队列变空，也就是 S 到所有的最短距离都确定下来，结束算法。若一个点入队次数超过 n，则有负权环。</p>
<p>SPFA 在形式上和宽度优先搜索非常类似，不同的是宽度优先搜索中一个点出了队列就不可能重新进入队列，但是 SPFA 中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进，于是再次用来改进其它的点，这样反复迭代下去。设一个点用来作为迭代点对其它点进行改进的平均次数为 k，有办法证明对于通常的情况，k 在 2 左右。</p>
<p>SPFA 算法（Shortest Path Faster Algorithm），也是求解单源最短路径问题的一种算法，用来解决：给定一个加权有向图 G 和源点 s，对于图 G 中的任意一点 v，求从 s 到 v 的最短路径。 SPFA 算法是 Bellman-Ford 算法的一种队列实现，减少了不必要的冗余计算，他的基本算法和 Bellman-Ford 一样，并且用如下的方法改进： 1、第二步，不是枚举所有节点，而是通过队列来进行优化 设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点 u，并且用 u 点当前的最短路径估计值对离开 u 点所指向的结点 v 进行松弛操作，如果 v 点的最短路径估计值有所调整，且 v 点不在当前的队列中，就将 v 点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。 2、同时除了通过判断队列是否为空来结束循环，还可以通过下面的方法： 判断有无负环：如果某个点进入队列的次数超过 V 次则存在负环（SPFA 无法处理带负环的图）。</p>
<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="cpp">#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
const int MAXN = 3010;
const int MAX_INT = (1 &lt;&lt; 29);

struct Edge&#123;
    int v, w, nxt;
&#125;;
int n, m, ecnt;
bool vis[MAXN];
Edge edge[MAXN * MAXN];
int head[MAXN], cnt[MAXN], dis[MAXN], path[MAXN];
void init()&#123;
    ecnt = 0;
    memset(vis, 0, sizeof(vis));
    memset(cnt, 0, sizeof(cnt));
    memset(edge, 0, sizeof(edge));
    memset(head, -1, sizeof(head));
    fill(cnt, cnt + MAXN, MAX_INT);
    for(int i = 0; i &lt; MAXN; i++)
        path[i] = i;
&#125;
void addEdge(int u, int v, int w)&#123;
    edge[ecnt].v = v;
    edge[ecnt].w = w;
    edge[ecnt].nxt = head[u];
    head[u] = ecnt++;
&#125;
bool SPFA(int s)&#123;
    queue &lt;int&gt; que;
    vis[s] = true;
    que.push(s);
    dis[s] = 0;
    while(!que.empty())&#123;
        int u = que.front();
        que.pop();
        vis[u] = false;
        cnt[u]++;
        if(cnt[u] &gt; n) return false;
        for(int i = head[u]; i + 1; edge[i].nxt)&#123;
            int v = edge[i].v;
            if(dis[v] &gt; dis[u] + edge[i].w)&#123;
                dis[v] = dis[u] + edge[i].w;
                path[v] = u;
                if(!vis[v])&#123;
                    vis[v] = true;
                    que.push(v);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
void PrintPath(int t)&#123;
    stack &lt;int&gt; sta;
    while(t != path[t])&#123;
        sta.push(t);
        t = path[t];
    &#125;
    printf(&quot;%d &quot;, t);
    while(!sta.empty())&#123;
        printf(&quot;%d &quot;, sta.top());
        sta.pop();
    &#125;
    printf(&quot;\n&quot;);
&#125;</code></pre>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>O(E)</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/weixinpay.jpg" alt="Andrewei 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Andrewei 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag"># 图论</a>
              <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag"># 最短路</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2015/10/26/e7-94-9f-e6-88-90-e6-a0-91/" rel="prev" title="生成树">
      <i class="fa fa-chevron-left"></i> 生成树
    </a></div>
      <div class="post-nav-item">
    <a href="/2015/11/03/e6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-2/" rel="next" title="排序算法">
      排序算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">常用算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dijkstra-%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">Dijkstra 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="nav-number">3.2.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.3.</span> <span class="nav-text">算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.4.</span> <span class="nav-text"> </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">3.5.</span> <span class="nav-text">示例代码（邻接表+优先队列）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.6.</span> <span class="nav-text">算法复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Floyd-Warshall-%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">Floyd-Warshall 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">4.1.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3"><span class="nav-number">4.2.</span> <span class="nav-text">算法理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88%E5%90%AB%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">示例代码（含记录路径）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8-Floyd-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%E6%B1%82%E6%9C%80%E5%B0%8F%E7%8E%AF"><span class="nav-number">4.4.</span> <span class="nav-text">用 **Floyd **算法思想求最小环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">4.5.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">4.6.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bellman-Ford-%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">Bellman-Ford 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6-amp-%E8%8C%83%E5%9B%B4"><span class="nav-number">5.2.</span> <span class="nav-text">适用条件**&amp;**范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bellman-Ford-%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="nav-number">5.3.</span> <span class="nav-text">**Bellman-Ford **算法描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E8%AF%81%E6%98%8E"><span class="nav-number">5.4.</span> <span class="nav-text">算法证明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95"><span class="nav-number">5.5.</span> <span class="nav-text">图解算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-number">5.6.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="nav-number">5.7.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPFA-%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">SPFA 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-1"><span class="nav-number">6.1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">6.2.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="nav-number">6.3.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="nav-number">6.4.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Andrewei"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Andrewei</p>
  <div class="site-description" itemprop="description">There's no feat, but what we make.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/andrewei1316" title="GitHub → https://github.com/andrewei1316" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andrewei</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
