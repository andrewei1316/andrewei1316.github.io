<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.andrewei.me","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="最小生成树概述在一给定的无向图G &#x3D; (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边（即），而 w(u, v) 代表此边的权重，若存在 T 为 E 的子集（即）且为无循环图，使得 的 w(T) 最小，则此 T 为 G 的最小生成树。最小生成树其实是最小权重生成树的简称。 许多应用问题都是一个求无向连通图的最小生成树问题。例如：要在n个城市之间铺设光缆，主要目标是要使这 n 个城">
<meta property="og:type" content="article">
<meta property="og:title" content="生成树">
<meta property="og:url" content="https://blog.andrewei.me/2015/10/26/e7-94-9f-e6-88-90-e6-a0-91/index.html">
<meta property="og:site_name" content="Andrewei">
<meta property="og:description" content="最小生成树概述在一给定的无向图G &#x3D; (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边（即），而 w(u, v) 代表此边的权重，若存在 T 为 E 的子集（即）且为无循环图，使得 的 w(T) 最小，则此 T 为 G 的最小生成树。最小生成树其实是最小权重生成树的简称。 许多应用问题都是一个求无向连通图的最小生成树问题。例如：要在n个城市之间铺设光缆，主要目标是要使这 n 个城">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.andrewei.me/images/2015/10/01d8ed9a66f30951a25ef99a948a.png">
<meta property="og:image" content="https://blog.andrewei.me/images/2015/10/c7fb458bbac68eaaacb3f01fd78f.png">
<meta property="og:image" content="https://blog.andrewei.me/images/2015/10/67be1993566a793b82d315be6b9d.png">
<meta property="og:image" content="https://blog.andrewei.me/images/2015/10/32d28b1ccb75847eda177a2acae0.png">
<meta property="article:published_time" content="2015-10-26T14:38:27.000Z">
<meta property="article:modified_time" content="2018-04-09T01:16:07.263Z">
<meta property="article:author" content="Andrewei">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="图论">
<meta property="article:tag" content="生成树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.andrewei.me/images/2015/10/01d8ed9a66f30951a25ef99a948a.png">

<link rel="canonical" href="https://blog.andrewei.me/2015/10/26/e7-94-9f-e6-88-90-e6-a0-91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>生成树 | Andrewei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Andrewei" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Andrewei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/andrewei1316" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.andrewei.me/2015/10/26/e7-94-9f-e6-88-90-e6-a0-91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Andrewei">
      <meta itemprop="description" content="There's no feat, but what we make.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrewei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          生成树
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-26 22:38:27" itemprop="dateCreated datePublished" datetime="2015-10-26T22:38:27+08:00">2015-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-04-09 09:16:07" itemprop="dateModified" datetime="2018-04-09T09:16:07+08:00">2018-04-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">图论</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在一给定的无向图G = (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边（即），而 w(u, v) 代表此边的权重，若存在 T 为 E 的子集（即）且为无循环图，使得 的 w(T) 最小，则此 T 为 G 的最小生成树。<br>最小生成树其实是最小权重生成树的简称。 许多应用问题都是一个求无向连通图的最小生成树问题。例如：要在n个城市之间铺设光缆，主要目标是要使这 n 个城市的任意两个之间都可以通信，但铺设光缆的费用很高，且各个城市之间铺设光缆的费用不同；另一个目标是要使铺设光缆的总费用最低。这就需要找到带权的最小生成树。 <a id="more"></a></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>最小生成树的边数必然是顶点数减一，|E| = |V| - 1。<br>最小生成树不可以有环。<br>最小生成树不必是唯一的。</p>
<h4 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。</p>
<h5 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h5><p>从单一顶点开始，Prim算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。<br><strong>输入</strong>：一个加权连通图，其中顶点集合为V，边集合为E；<br><strong>初始化</strong>：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {}；<br><strong>重复下列操作，直到Vnew = V：</strong><br>在集合E中选取权值最小的边（u, v），其中u为集合Vnew中的元素，而v则不是（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；<br>将v加入集合Vnew中，将（u, v）加入集合Enew中；</p>
<p><strong>输出：</strong>使用集合Vnew和Enew来描述所得到的最小生成树。过程如图所示：</p>
<p><img src="/images/2015/10/01d8ed9a66f30951a25ef99a948a.png" alt="01d8ed9a66f30951a25ef99a948a"></p>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>通过邻接矩阵图表示的简易实现中，找到所有最小权边共需O（V2）的运行时间。使用简单的二叉堆与邻接表来表示的话，普里姆算法的运行时间则可缩减为O(E log V)，其中E为连通图的边数，V为顶点数。如果使用较为复杂的斐波那契堆，则可将运行时间进一步缩短为O(E + V log V)，这在连通图足够密集时（当E满足Ω（V log V）条件时），可较显著地提高运行速度。<br><img src="/images/2015/10/c7fb458bbac68eaaacb3f01fd78f.png" alt="c7fb458bbac68eaaacb3f01fd78f"></p>
<h6 id="两种实现"><a href="#两种实现" class="headerlink" title="两种实现"></a>两种实现</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// n 是点的数目；</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N][N], low[N], div[N]; <span class="comment">// map[N][N] 存储点和权值，low[N]中存储未收录到树的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123; <span class="comment">// 点到树的最小距离，div记录已经收录到树中的点。</span></span><br><span class="line">    <span class="keyword">int</span> i, j, min, minp, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 初始化div[N] 数组的值 0 为未收录该点，1 为收录。</span></span><br><span class="line">        div[i] = <span class="number">0</span>;</span><br><span class="line">    div[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    minp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">// 第一次初始化low[N] 数组，存储个点到minp的距离</span></span><br><span class="line">        low[i] = <span class="built_in">map</span>[minp][i];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        min = M;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(div[j] == <span class="number">0</span> &amp;&amp; min &gt; low[j])&#123; <span class="comment">// 找出距离minp 最小的点，用minp记录，并记距离</span></span><br><span class="line">                min = low[j];</span><br><span class="line">                minp = j;</span><br><span class="line">            &#125;</span><br><span class="line">        div[minp] = <span class="number">1</span>; <span class="comment">// 上一个过程中找到的点被收录到树中，并加上权值</span></span><br><span class="line">        sum += min;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)&#123; <span class="comment">// 更新low[N] 数组，使其始终保持未收录到树中的点</span></span><br><span class="line">            <span class="keyword">if</span>(div[j] == <span class="number">0</span> &amp;&amp; low[j] &gt; <span class="built_in">map</span>[minp][j]) <span class="comment">// 到树的最小距离。</span></span><br><span class="line">                low[j] = <span class="built_in">map</span>[minp][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (1 &lt;&lt; 30)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], dis[N], n, m, e;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">Edge edge[N * N / <span class="number">2</span>];</span><br><span class="line"><span class="built_in">priority_queue</span> &lt; Node &gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) que.pop();</span><br><span class="line">    fill(head, head + N, <span class="number">-1</span>);</span><br><span class="line">    fill(dis, dis + N, M);</span><br><span class="line">    fill(vis, vis + N, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[e].v = v;</span><br><span class="line">    edge[e].w = w;</span><br><span class="line">    edge[e].n = head[u];</span><br><span class="line">    head[u] = e++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    Node t;</span><br><span class="line">    t.v = <span class="number">1</span>;</span><br><span class="line">    t.w = <span class="number">0</span>;</span><br><span class="line">    que.push(t);</span><br><span class="line">    <span class="keyword">int</span> nume = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty() &amp;&amp; nume &lt;= m)&#123;</span><br><span class="line">        t = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[t.v]) <span class="keyword">continue</span>;</span><br><span class="line">        ans += t.w;</span><br><span class="line">        vis[t.v] = <span class="literal">true</span>;</span><br><span class="line">        nume++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[t.v]; i != <span class="number">-1</span>; i = edge[i].n)</span><br><span class="line">            <span class="keyword">if</span>(!vis[edge[i].v])&#123;</span><br><span class="line">                Node tt;</span><br><span class="line">                tt.v = edge[i].v;</span><br><span class="line">                tt.w = edge[i].w;</span><br><span class="line">                que.push(tt);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    If(nume == n) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF &amp;&amp; n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">            addedge(a, b, w);</span><br><span class="line">            addedge(b, a, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, prime());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>假设 WN=(V,{E}) 是一个含有 n 个顶点的连通网，则按照克鲁斯卡尔算法构造最小生成树的过程为：先构造一个只含 n 个顶点，而边集为空的子图，若将该子图中各个顶点看成是各棵树上的根结点，则它是一个含有 n 棵树的一个森林。之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，也就是说，将这两个顶点分别所在的两棵树合成一棵树；反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直至森林中只有一棵树，也即子图中含有 n-1条边为止。</p>
<h5 id="主要操作-1"><a href="#主要操作-1" class="headerlink" title="主要操作"></a>主要操作</h5><ol>
<li>记Graph中有v个顶点，e个边</li>
<li>新建图Graphnew，Graphnew中拥有原图中相同的e个顶点，但没有边</li>
<li>将原图Graph中所有e个边按权值从小到大排序</li>
<li>循环：从权值最小的边开始遍历每条边 直至图Graph中所有的节点都在同一个连通分量中<br>if 这条边连接的两个节点于图Graphnew中不在同一个连通分量中添加这条边到图Graphnew中；<br>过程如图所示：</li>
</ol>
<p><img src="/images/2015/10/67be1993566a793b82d315be6b9d.png" alt="67be1993566a793b82d315be6b9d"><br><img src="/images/2015/10/32d28b1ccb75847eda177a2acae0.png" alt="32d28b1ccb75847eda177a2acae0"></p>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>从Kruskal算法中可以看到，执行该算法时间主要花费在堆排序和单层循环上，而循环是线性级的，则可以认为时间复杂性主要花费在堆排序上，由堆排序算法可知，Kruskal算法的时间复杂度为O(eloge)，其中e为图的边数。</p>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10000 <span class="comment">// M 为最多的点的数目</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">maps</span>&#123;</span> <span class="comment">// 定义新类型，maps x，y代表两个点，w为他们的权值；</span></span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">maps <span class="built_in">map</span>[M * M];</span><br><span class="line"><span class="keyword">int</span> par[M], n, ne; <span class="comment">// n 为实际点的数目，ne为两个不同的点构成的边的数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> maps&amp; a, <span class="keyword">const</span> maps&amp; b)</span></span>&#123; <span class="comment">// sort 函数调用将边按权值由小到大排序</span></span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 以下为并查集内容</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        par[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] != x)</span><br><span class="line">        par[x] = find(par[x]);</span><br><span class="line">    <span class="keyword">return</span> par[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">        par[fy] = fx;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruscal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    b = <span class="number">0</span>; <span class="comment">// b为加入树中的边的数目；</span></span><br><span class="line">    sort(<span class="built_in">map</span>, <span class="built_in">map</span> + ne, cmp); <span class="comment">// 排序；</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= ne; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(unit(<span class="built_in">map</span>[i].x, <span class="built_in">map</span>[i].y))&#123; <span class="comment">// 当两点至少有一个未收录到树中时，向树中加入该边</span></span><br><span class="line">            sum += <span class="built_in">map</span>[i].w; <span class="comment">// 这样做是为了防止树中出现环路；</span></span><br><span class="line">            b++;</span><br><span class="line">            <span class="keyword">if</span>(b == n - <span class="number">1</span>) <span class="comment">// 当边数比点数少1时，所有的点被收录到树中；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="POJ-例题分析"><a href="#POJ-例题分析" class="headerlink" title="POJ 例题分析"></a>POJ 例题分析</h6><p><strong>POJ 1751</strong></p>
<p><strong>题目大意</strong>：一个有n个城市的国家，已知有些城市有道路联通，问增加哪些道路使得所有的城市都可以彼此联通且代价最小，已经代价是两个城市坐标的笛卡尔距离；<br><strong>输入：</strong>n 表示有九个点，接下来n行将输入这就个点的坐标，之后会有一个整数q代表已经有q条边连接，接下来q行将输入这q条边所连接的点（例如： 1 2 代表上面所输入的n个坐标的第一个和第二个点已经连接。<br><strong>输出：</strong>输出还需要连接的点，用空格隔开（已经连号的点不能输出）。</p>
<p><strong>解题思路：</strong>Prim 算法，因为这道题目已经有一些边连起来了，故在初始化map数组时，连起来的边要置为零，由于该题要求输出被连接的两个点，在算法内部可以用一个数组来记录当前正在验证的边的端点，此外，已经连接的点不能输出，故当权值为零时则不输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXINT 1&lt;&lt;28</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span>&#123;</span> <span class="comment">// 定义结构体来存放点的坐标；</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[M][M], low[M];</span><br><span class="line"><span class="keyword">int</span> vis[M], p[M]; <span class="comment">// 数组 P 用来存放 low 数组中权值所对应的点</span></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line">a s[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, minp, f = <span class="number">0</span>; <span class="comment">// f用来标记权值是否为零；</span></span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    minp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        p[i] = minp; <span class="comment">// p 数组用来存放 low 数组中的权值所对应的点</span></span><br><span class="line">        low[i] = <span class="built_in">map</span>[minp][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        min = MAXINT;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; min &gt; low[j] &amp;&amp; minp != j)&#123; <span class="comment">// minp != j 即跳过边的两端为同一个点的情况</span></span><br><span class="line">                minp = j;</span><br><span class="line">                min = low[j];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[p[j]][minp] == <span class="number">0</span>) <span class="comment">// 若权值为零，则标记下来；</span></span><br><span class="line">                    f = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        vis[minp] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(f == <span class="number">0</span>) <span class="comment">// 权值为零时不输出；</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; p[minp] &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; minp &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        mina = minp;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[minp][j] &lt; low[j])&#123;</span><br><span class="line">                p[j] = minp;</span><br><span class="line">                low[j] = <span class="built_in">map</span>[minp][j];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, a, b;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i].x &gt;&gt; s[i].y;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            l = (s[i].x - s[j].x) * (s[i].x - s[j].x) + (s[i].y - s[j].y) * (s[i].y - s[j].y);</span><br><span class="line">            <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[j][i] = l; <span class="comment">// 注意无向图应该两个方向的值相同；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">map</span>[a][b] = <span class="built_in">map</span>[b][a] = <span class="number">0</span>; <span class="comment">// 已经连起来的边权值为零；</span></span><br><span class="line">    &#125;</span><br><span class="line">    prim();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kruskal 算法,注意在本题上的使用技巧，题目要求不输出已经连接的边的端点，故可以在初始化的时候将连接好的端点加入集合中，这样在kruskal算法执行过程中就不会涉及到那些边。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 755</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">maps</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span>&#123;</span> <span class="comment">// 存储点的坐标</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> maps&amp; a, <span class="keyword">const</span> maps&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maps <span class="built_in">map</span>[N * N];</span><br><span class="line">s s[N];</span><br><span class="line"><span class="keyword">int</span> par[N];</span><br><span class="line"><span class="keyword">int</span> n, ne, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        par[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] != x)</span><br><span class="line">        par[x] = find(par[x]);</span><br><span class="line">    <span class="keyword">return</span> par[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">        par[fy] = fx;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruscal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">    sort(<span class="built_in">map</span>, <span class="built_in">map</span> + ne, cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= ne; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(unit(<span class="built_in">map</span>[i].x, <span class="built_in">map</span>[i].y))&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">map</span>[i].x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">map</span>[i].y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            b++;</span><br><span class="line">            <span class="keyword">if</span>(b == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, l, q, a;</span><br><span class="line">    ne = <span class="number">0</span>;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i].x &gt;&gt; s[i].y;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i != j)&#123; <span class="comment">// 避免重（chong）点</span></span><br><span class="line">                l = (s[i].x - s[j].x) * (s[i].x - s[j].x) + (s[i].y - s[j].y) * (s[i].y - s[j].y);</span><br><span class="line">                <span class="built_in">map</span>[ne].x = i;</span><br><span class="line">                <span class="built_in">map</span>[ne].y = j;</span><br><span class="line">                <span class="built_in">map</span>[ne].w = l;</span><br><span class="line">                ne++;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        par[find(b)] = par[find(a)]; <span class="comment">// 已经连起来的边的端点收录到集合中；</span></span><br><span class="line">        b++; <span class="comment">// 记录边的条数；</span></span><br><span class="line">    &#125;</span><br><span class="line">    kruscal();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>POJ 2966</strong></p>
<p><strong>题目大意：</strong>一个图中有几个连通分支（并不是每个点与其他点都有连接，只有一部分边） 。你可以连通任意两个点。求在满足使这个图成为连通图的前提下，使你所连的两点间的边的sum(权值)最小。<br><strong>输入：</strong>第一行为case个数，每个case里的第一行为两个数N和E分别表示点的个数和边的条数，接下来的E行是两个点和他们的权值。<br><strong>输出：</strong>每个case输出一行，即连接这些点的最小权值。<br><strong>解题思路:</strong> Prim 算法，最小生成树最基本的题目，只要把map数组初始化为很大的值，就可以在程序运行中避开那些不能连接的边。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXINT 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[M][M], low[M], vis[M];</span><br><span class="line"><span class="keyword">int</span> t, e, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, min, minp, key = <span class="number">0</span>;</span><br><span class="line">    min = MAXINT;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    minp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        low[i] = <span class="built_in">map</span>[minp][i];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        min = MAXINT;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(min &gt; low[j] &amp;&amp; vis[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                min = low[j];</span><br><span class="line">                minp = j;</span><br><span class="line">            &#125;</span><br><span class="line">        key += min;</span><br><span class="line">        vis[minp] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[minp][j] &lt; low[j])</span><br><span class="line">                low[j] = <span class="built_in">map</span>[minp][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; key &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j, k, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">                <span class="built_in">map</span>[i][j] = MAXINT; <span class="comment">// 初始化为很大的值</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; e;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; e; k++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            <span class="built_in">map</span>[j][i] = <span class="built_in">map</span>[i][j] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        prim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kruskal 算法：没技巧，直接套模版。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">maps</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">maps <span class="built_in">map</span>[N * N];</span><br><span class="line"><span class="keyword">int</span> par[N], n, e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> maps&amp; a, <span class="keyword">const</span> maps&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        par[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] != x)</span><br><span class="line">        par[x] = find(par[x]);</span><br><span class="line">    <span class="keyword">return</span> par[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">        par[fy] = fx;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruscal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, b = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line">    sort(<span class="built_in">map</span>, <span class="built_in">map</span> + e, cmp);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">        <span class="keyword">if</span>(unit(<span class="built_in">map</span>[i].x, <span class="built_in">map</span>[i].y))&#123;</span><br><span class="line">            sum += <span class="built_in">map</span>[i].w;</span><br><span class="line">            b++;</span><br><span class="line">            <span class="keyword">if</span>(b == n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, t, x, y, cost;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;e);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; e; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;cost);</span><br><span class="line">            <span class="built_in">map</span>[i].x = x;</span><br><span class="line">            <span class="built_in">map</span>[i].y = y;</span><br><span class="line">            <span class="built_in">map</span>[i].w = cost;</span><br><span class="line">        &#125;</span><br><span class="line">        kruscal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="次小生成树（k小生成树）"><a href="#次小生成树（k小生成树）" class="headerlink" title="次小生成树（k小生成树）"></a>次小生成树（k小生成树）</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>给出一个带边权的无向图G，设其最小生成树为T，求出图G的与T不完全相同的边权和最小的生成树（即G的次小生成树）。一个无向图的两棵生成树不完全相同，当且仅当这两棵树中至少有一条边不同。注意，图G可能不连通，可能有平行边，但一定没有自环（其实对于自环也很好处理：直接舍弃。因为生成树中不可能出现自环）。定义生成树T的一个可行变换(-E1, +E2)：将T中的边E1删除后，再加入边E2（满足边E2原来不在T中但在G中），若得到的仍然是图G的一棵生成树，则该变换为可行变换，该可行变换的代价为(E2权值 - E1权值)。这样，很容易证明，G的次小生成树就是由G的最小生成树经过一个代价最小的可行变换得到。进一步可以发现，这个代价最小的可行变换中加入的边E2的两端点如果为V1和V2，那么E1一定是原来最小生成树中从V1到V2的路径上的权值最大的边。</p>
<h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>设立数组F，F[x][y]表示T中从x到y路径上的最大边的权值。F数组可以在用Prim算法求最小生成树的过程中得出。每次将边(i, j)加入后（j是新加入树的边，i=c[j]），枚举树中原有的每个点k（包括i，但不包括j），则F[k][j]=max{F[k][i], (i, j)边权值}，又由于F数组是对称的，可以得到F[j][k]=F[k][j]。然后千万记住将图G中的边(i, j)删除（就是将邻接矩阵中(i, j)边权值改为∞）！因为T中的边是不能被加入的。等T被求出后，所有的F值也求出了，然后，枚举点i、j，若邻接矩阵中边(i, j)权值不是无穷大（这说明i、j间存在不在T中的边），则求出{(i, j)边权值 - F[i][j]}的值，即为加入边(i, j)的代价，求最小的总代价即可。</p>
<p>另外注意三种特殊情况：</p>
<ol>
<li>图G不连通，此时最小生成树和次小生成树均不存在。判定方法：在扩展T的过程中找不到新的可以加入的边；</li>
<li>图G本身就是一棵树，此时最小生成树存在（就是G本身）但次小生成树不存在。判定方法：在成功求出T后，发现邻接矩阵中的值全部是无穷大；</li>
<li>图G存在平行边。这种情况最麻烦，因为这时代价最小的可行变换(-E1, +E2)中，E1和E2可能是平行边！<br>因此，只有建立两个邻接矩阵，分别存储每两点间权值最小的边和权值次小的边的权值，然后，每当一条新边(i, j)加入时，不是将邻接矩阵中边(i, j)权值改为无穷大，而是改为连接点i、j的权值次小的边的权值。</li>
</ol>
<h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (1 &lt;&lt; 30)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[N][N], mp1[N][N], ma[N][N], pre[N], dis[N], n, m, ans, res;</span><br><span class="line"><span class="keyword">bool</span> vis[N]; <span class="comment">//mp1 存储次小边，ma存储每一条路径的最大值 pre 前驱</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fill(mp[<span class="number">0</span>], mp[N], M);</span><br><span class="line">    fill(mp1[<span class="number">0</span>], mp1[N], M);</span><br><span class="line">    fill(ma[<span class="number">0</span>], ma[N], <span class="number">0</span>);</span><br><span class="line">    fill(dis, dis + N, M);</span><br><span class="line">    fill(vis, vis + N, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="keyword">if</span>(w &lt; mp[u][v])&#123;</span><br><span class="line">            mp1[u][v] = mp[u][v];</span><br><span class="line">            mp[u][v] = w;</span><br><span class="line">            mp1[v][u] = mp1[u][v];</span><br><span class="line">            mp[v][u] = mp[u][v];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(w &lt; mp1[u][v])&#123;</span><br><span class="line">            mp1[u][v] = w;</span><br><span class="line">            mp1[v][u] = mp1[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>, res = M;</span><br><span class="line">    <span class="keyword">int</span> mi, mip;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dis[i] = mp[s][i];</span><br><span class="line">        pre[i] = s;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        mi = M, mip = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; mi)&#123;</span><br><span class="line">                mi = dis[j];</span><br><span class="line">                s = pre[j];</span><br><span class="line">                mip = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mi == M) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0 时，说明不存在最小生成树</span></span><br><span class="line">        ans += mi;</span><br><span class="line">        vis[mip] = <span class="literal">true</span>;</span><br><span class="line">        mp[s][mip] = M;</span><br><span class="line">        mp[mip][s] = M;</span><br><span class="line">        <span class="keyword">if</span>(mp1[s][mip] &lt; M &amp;&amp; mp1[s][mip] - mi &lt; res)</span><br><span class="line">            res = mp1[s][mip] - mi;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; mp[mip][j])&#123;</span><br><span class="line">                dis[j] = mp[mip][j];</span><br><span class="line">                pre[j] = mip;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(vis[j] &amp;&amp; j != s &amp;&amp; j != mip)&#123;</span><br><span class="line">                ma[j][mip] = max(ma[j][s], mi);</span><br><span class="line">                ma[mip][j] = ma[j][mip];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i != j &amp;&amp; mp[i][j] != M)</span><br><span class="line">                res = min(res, mp[i][j] - ma[i][j]);</span><br><span class="line">    <span class="keyword">if</span>(res == M) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回 1 时， 说明不存在次小生成树</span></span><br><span class="line">    res += ans; <span class="comment">// 之前的 res 都代表 E2-E1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 返回 2 时， 说明存在次小生成树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="comment">//clock_t start = clock();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> ch = prim(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ans, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ans, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//clock_t stop = clock();</span></span><br><span class="line">    <span class="comment">//printf(&quot;Time = %.2lfMS\n&quot;, (double)(stop - start) / CLOCKS_PER_SEC * 1000);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>Kruskal算法也可以用来求次小生成树。在准备加入一条新边(a, b)（该边加入后不会出现环）时，选择原来a所在连通块（设为S1）与b所在连通块（设为S2）中，点的个数少的那个（如果随便选一个，最坏情况下可能每次都碰到点数多的那个，时间复杂度可能增至O(NM)），找到该连通块中的每个点i，并遍历所有与i相关联的边，若发现某条边的另一端点j在未选择的那个连通块中（也就是该边(i, j)跨越了S1和S2）时，就说明最终在T中”删除边(a, b)并加入该边”一定是一个可行变换，且由于加边是按照权值递增顺序的，(a, b)也一定是T中从i到j路径上权值最大的边，故这个可行变换可能成为代价最小的可行变换，计算其代价为[(i, j)边权值 - (a, b)边权值]，取最小代价即可。注意，在遍历时需要排除一条边，就是(a, b)本身（具体实现时由于用DL边表，可以将边(a, b)的编号代入）。另外还有一个难搞的地方：如何快速找出某连通块内的所有点？方法：由于使用并查集，连通块是用树的方式存储的，可以直接建一棵树（准确来说是一个森林），用“最左子结点+相邻结点”表示，则找出树根后遍历这棵树就行了，另外注意在合并连通块时也要同时合并树。</p>
<p>对于三种特殊情况：</p>
<ol>
<li>图G不连通。判定方法：遍历完所有的边后，实际加入T的边数小于(N-1)；</li>
<li>图G本身就是一棵树。判定方法：找不到这样的边(i, j)；</li>
<li>图G存在平行边。这个对于Kruskal来说完全可以无视，因为Kruskal中两条边只要编号不同就视为不同的边。<br>其实Kruskal算法求次小生成树还有一个优化：每次找到边(i, j)后，一处理完这条边就把它从图中删掉，因为当S1和S2合并后，(i, j)就永远不可能再是可行变换中的E2了。</li>
</ol>
<h5 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(i, n) for (int i=0; i&lt;n; i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re3(i, l, r) for (int i=l; i&lt;=r; i++)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">7000</span>, MAXM = <span class="number">130000</span>, INF = ~<span class="number">0U</span> &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, len, pre, next;</span><br><span class="line">&#125; ed[MAXM + MAXM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge2</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, len, No;</span><br><span class="line">&#125; ed2[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">0</span>, m2, u[MAXN], ch[MAXN], nx[MAXN], q[MAXN], res1 = <span class="number">0</span>, res2 = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_d</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i - <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ed[i].a = ed[i].pre = ed[i].next = i;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) m = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> m = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    ed[m].a = a; ed[m].b = b; ed[m].len = l; ed[m].pre = ed[a].pre; ed[m].next = a; ed[a].pre = m; ed[ed[m].pre].next = m++;</span><br><span class="line">    ed[m].a = b; ed[m].b = a; ed[m].len = l; ed[m].pre = ed[b].pre; ed[m].next = b; ed[b].pre = m; ed[ed[m].pre].next = m++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_edge</span><span class="params">(<span class="keyword">int</span> No)</span></span>&#123;</span><br><span class="line">    ed[ed[No].pre].next = ed[No].next;</span><br><span class="line">    ed[ed[No].next].pre = ed[No].pre;</span><br><span class="line">    ed[ed[No ^ <span class="number">1</span>].pre].next = ed[No ^ <span class="number">1</span>].next;</span><br><span class="line">    ed[ed[No ^ <span class="number">1</span>].next].pre = ed[No ^ <span class="number">1</span>].pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m2);</span><br><span class="line">    <span class="keyword">if</span> (!m2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) res1 = -INF;</span><br><span class="line">        res2 = -INF;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    init_d();</span><br><span class="line">    <span class="keyword">int</span> a, b, len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m2; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;len);</span><br><span class="line">        ed2[i].No = m; add_edge(--a, --b, len);</span><br><span class="line">        ed2[i].a = a; ed2[i].b = b; ed2[i].len = len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *s1, <span class="keyword">const</span> <span class="keyword">void</span> *s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((edge2 *)s1)-&gt;len - ((edge2 *)s2)-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        u[i] = ch[i] = nx[i] = <span class="number">-1</span>;</span><br><span class="line">        qsort(ed2, m2, <span class="number">16</span>, cmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = x, r0 = x, tmp;</span><br><span class="line">    <span class="keyword">while</span> (u[r] &gt;= <span class="number">0</span>) r = u[r];</span><br><span class="line">    <span class="keyword">while</span> (u[r0] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = u[r0];</span><br><span class="line">        u[r0] = r;</span><br><span class="line">        r0 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> r2, <span class="keyword">int</span> No, <span class="keyword">int</span> l0)</span> </span>&#123;</span><br><span class="line">    q[<span class="number">0</span>] = r1;</span><br><span class="line">    <span class="keyword">int</span> j, k, l1, front, rear;</span><br><span class="line">    <span class="keyword">for</span> (front = <span class="number">0</span>, rear = <span class="number">0</span>; front &lt;= rear; front++) &#123;</span><br><span class="line">        j = ch[q[front]];</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span>) &#123;</span><br><span class="line">            q[++rear] = j;</span><br><span class="line">            j = nx[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rear; i++)&#123;</span><br><span class="line">        j = q[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p=ed[j].next; p != j; p=ed[p].next) &#123;</span><br><span class="line">            k = ed[p].b;</span><br><span class="line">            <span class="keyword">if</span> (p != No &amp;&amp; find(k) == r2) &#123;</span><br><span class="line">                l1 = ed[p].len - l0;</span><br><span class="line">                <span class="keyword">if</span> (l1 &lt; res2) res2 = l1;</span><br><span class="line">                del_edge(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    u[r2] += u[r1]; u[r1] = r2; nx[r1] = ch[r2]; ch[r2] = r1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r1, r2, l0, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m2; i++)&#123;</span><br><span class="line">        r1 = find(ed2[i].a);</span><br><span class="line">        r2 = find(ed2[i].b);</span><br><span class="line">        <span class="keyword">if</span> (r1 != r2) &#123;</span><br><span class="line">            l0 = ed2[i].len;</span><br><span class="line">            res1 += l0;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">if</span> (u[r1] &gt;= u[r2]) uni(r1, r2, ed2[i].No, l0);</span><br><span class="line">            <span class="keyword">else</span> uni(r2, r1, ed2[i].No ^ <span class="number">1</span>, l0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">        res1 = res2 = -INF;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res2 == INF) res2 = -INF;</span><br><span class="line">    <span class="keyword">else</span> res2 += res1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cost: %d\nCost: %d\n&quot;</span>, res1 == -INF ? <span class="number">-1</span> : res1, res2 == -INF ? <span class="number">-1</span> : res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">if</span> (!res1 &amp;&amp; res2 == INF) &#123;</span><br><span class="line">        prepare();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    pri();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="另解"><a href="#另解" class="headerlink" title="另解"></a>另解</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (1 &lt;&lt; 29)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max(a, b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;a, <span class="keyword">const</span> Edge &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LCA</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">            <span class="keyword">int</span> v, n, w;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">                v = a, n = b, w = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Edge tedge[<span class="number">2</span> * N], qedge[<span class="number">2</span> * N], aedge[<span class="number">2</span> * N];</span><br><span class="line">        <span class="keyword">int</span> thead[N], qhead[N], ahead[N];</span><br><span class="line">        <span class="keyword">int</span> vis[N], par[N], ma[<span class="number">2</span> * N], ans[<span class="number">2</span> * N];</span><br><span class="line">        <span class="keyword">int</span> te, qe, ae;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">            te = qe = ae = <span class="number">0</span>;</span><br><span class="line">            fill(ma, ma + <span class="number">2</span> * N, -M);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">                par[i] = i;</span><br><span class="line">                thead[i] = qhead[i] = ahead[i] = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">//ma[i] = -M;</span></span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = par[x];</span><br><span class="line">            <span class="keyword">if</span>(x != temp) par[x] = find(par[x]);</span><br><span class="line">            ma[x] = Max(ma[x], ma[temp]);</span><br><span class="line">            <span class="keyword">return</span> par[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> *head, Edge *edge, <span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">            edge[e].v = v, edge[e].w = w, edge[e].n = head[u], head[u] = e++;</span><br><span class="line">            <span class="keyword">if</span>(head == ahead) <span class="keyword">return</span>;</span><br><span class="line">            edge[e].v = u, edge[e].w = w, edge[e].n = head[v], head[v] = e++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">            vis[a] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = qhead[a]; i + <span class="number">1</span>; i = qedge[i].n)&#123;</span><br><span class="line">                <span class="keyword">int</span> b = qedge[i].v;</span><br><span class="line">                <span class="keyword">if</span>(vis[b])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = find(b);</span><br><span class="line">                    addEdge(ahead, aedge, temp, a, i, ae);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = thead[a]; i + <span class="number">1</span>; i = tedge[i].n)&#123;</span><br><span class="line">                <span class="keyword">int</span> b = tedge[i].v;</span><br><span class="line">                <span class="keyword">if</span>(vis[b] == <span class="number">0</span>)&#123;</span><br><span class="line">                    dfs(b);</span><br><span class="line">                    par[b] = a;</span><br><span class="line">                    ma[b] = tedge[i].w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = ahead[a]; i + <span class="number">1</span>; i = aedge[i].n)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = aedge[i].v;</span><br><span class="line">                <span class="keyword">int</span> t = aedge[i].w;</span><br><span class="line">                <span class="keyword">int</span> y = qedge[t].v;</span><br><span class="line">                find(x);</span><br><span class="line">                find(y);</span><br><span class="line">                ans[qedge[t].w] = Max(ma[x], ma[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;lca;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[N], n, m;</span><br><span class="line">Edge edge[<span class="number">2</span> * N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        par[i] = i, vis[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] != x) par[x] = find(par[x]);</span><br><span class="line">    <span class="keyword">return</span> par[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx == fy) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    par[fx] = fy;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruscal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ne = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    sort(edge, edge + m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span>(Union(edge[i].a, edge[i].b))&#123;</span><br><span class="line">            ans += edge[i].w;</span><br><span class="line">            ne++;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            lca.addEdge(lca.thead, lca.tedge, edge[i].a, edge[i].b, edge[i].w, lca.te);</span><br><span class="line">            <span class="keyword">if</span>(ne == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(ne == n - <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ckruscal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = M, me = <span class="number">0</span>, ne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) lca.addEdge(lca.qhead, lca.qedge, edge[i].a, edge[i].b, me++, lca.qe);</span><br><span class="line">    lca.dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].w - lca.ans[ne] &lt; res) res = edge[i].w - lca.ans[ne];</span><br><span class="line">            ne++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(res &lt; M) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//clock_t start = clock();</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; j++)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;Case %d: &quot;, j);</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        init();</span><br><span class="line">        lca.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">            edge[i].a = a, edge[i].b = b, edge[i].w = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Kruscal();</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> res = Ckruscal();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ans, res == <span class="number">-1</span> ? <span class="number">-1</span> : ans + res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//clock_t stop = clock();</span></span><br><span class="line">    <span class="comment">//printf(&quot;Time = %.2lfMS\n&quot;, (double)(stop - start) / CLOCKS_PER_SEC * 1000);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>效率分析：可以证明，如果每次都选取点少的连通块，Kruskal算法求次小生成树的时间复杂度为O(M*(logN+logM))，空间复杂度为O(M)。<br>总结：显然Prim适用于稠密图，而Kruskal适用于稀疏图。</p>
<h2 id="生成树个数"><a href="#生成树个数" class="headerlink" title="生成树个数"></a>生成树个数</h2><p>Matrix-Tree定理(Kirchhoff矩阵-树定理)。Matrix-Tree定理是解决生成树计数问题最有力的武器之一。它首先于1847年被Kirchhoff证明。在介绍定理之前，我们首先明确几个概念：</p>
<ol>
<li>G的度数矩阵D[G]是一个n*n的矩阵，并且满足：当i≠j时,dij=0；当i=j时，dij等于vi的度数。</li>
<li>G的邻接矩阵A[G]也是一个n*n的矩阵， 并且满足：如果vi、vj之间有边直接相连，则aij=1，否则为0。<br>我们定义G的Kirchhoff矩阵(也称为拉普拉斯算子)C[G]为$C[G]=D[G]-A[G]$，则Matrix-Tree定理可以描述为：G的所有不同的生成树的个数等于其Kirchhoff矩阵C[G]任何一个n-1阶主子式的行列式的绝对值。所谓n-1阶主子式，就是对于r(1≤r≤n)，将C[G]的第r行、第r列同时去掉后得到的新矩阵，用Cr[G]表示。</li>
</ol>
<h3 id="最小生成树的个数"><a href="#最小生成树的个数" class="headerlink" title="最小生成树的个数"></a>最小生成树的个数</h3><h4 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h4><p>抛开“最小”的限制不看,如果只要求求出所有生成树的个数,是可以利用Matrix-Tree定理解决的; Matrix-Tree定理此定理利用图的Kirchhoff矩阵,可以在O(N3)时间内求出生成树的个数;</p>
<h5 id="kruskal算法："><a href="#kruskal算法：" class="headerlink" title="kruskal算法："></a>kruskal算法：</h5><p>将图G={V,E}中的所有边按照长度由小到大进行排序,等长的边可以按照任意顺序;<br>初始化图G’为{V,?},从前向后扫描排序后的边,如果扫描到的边e在G’中连接了两个相异的连通块,则将它插入G’中;<br>最后得到的图G’就是图G的最小生成树;</p>
<p>由于kruskal按照任意顺序对等长的边进行排序,则应该将所有长度为L0的边的处理当作一个阶段来整体看待;</p>
<p>令kruskal处理完这一个阶段后得到的图为G0,如果按照不同的顺序对等长的边进行排序,得到的G0也是不同;</p>
<p>虽然G0可以随排序方式的不同而不同,但它们的连通性都是一样的,都和F0的连通性相同(F0表示插入所有长度为L0的边后形成的图);</p>
<p>在kruskal算法中的任意时刻,并不需要关注G’的具体形态,而只要关注各个点的连通性如何(一般是用并查集表示);</p>
<p>所以只要在扫描进行完第一阶段后点的连通性和F0相同,且是通过最小代价到达这一状态的,接下去都能找到最小生成树;</p>
<p>经过上面的分析,可以看出第一个阶段和后面的工作是完全独立的;</p>
<p>第一阶段需要完成的任务是使G0的连通性和F0一样,且只能使用最小的代价;<br>计算出这一阶段的方案数,再乘上完成后续事情的方案数,就是最终答案;<br>由于在第一个阶段中,选出的边数是一定的,所有边的长又都为L0;<br>所以无论第一个阶段如何进行代价都是一样的,那么只需要计算方案数就行了;<br>此时Matrix-Tree定理就可以派上用场了,只需对F0中的每一个连通块求生成树个数再相乘即可;</p>
<h6 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL par[N], fa[N], vis[N];</span><br><span class="line">LL mp[N][N], mp1[N][N];</span><br><span class="line">Edge edge[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; vec[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(LL &amp;a, LL &amp;b)</span></span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    fill(mp[<span class="number">0</span>], mp[N], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        vec[i].clear();</span><br><span class="line">        par[i] = i;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;edge[i].a, &amp;edge[i].b, &amp;edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, LL father[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != father[x]) father[x] = find(father[x], father);</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       if(x == father[x]) return x;</span></span><br><span class="line"><span class="comment">       return find(father[x], father);</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Mtree</span><span class="params">(LL a[][N], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            a[i][j] %= mod;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">while</span>(a[j][i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[i][i] / a[j][i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; n; k++)</span><br><span class="line">                    a[i][k] = (a[i][k] - a[j][k] * temp) % mod;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; n; k++)</span><br><span class="line">                    Swap(a[i][k], a[j][k]);</span><br><span class="line">                ans = -ans;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i][i] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans = ans * a[i][i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(edge, edge + m);</span><br><span class="line">    LL flag = <span class="number">-1</span>;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= m; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[k].w != flag || k == m)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">                    LL u = find(i, fa);</span><br><span class="line">                    vec[u].push_back(i);</span><br><span class="line">                    vis[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vec[i].size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    fill(mp1[<span class="number">0</span>], mp1[n + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">int</span> len = vec[i].size();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; len; a++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> a1 = vec[i][a];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> b = a + <span class="number">1</span>; b &lt; len; b++)&#123;</span><br><span class="line">                            <span class="keyword">int</span> b1 = vec[i][b];</span><br><span class="line">                            mp1[a][b] = (mp1[b][a] -= mp[a1][b1]);</span><br><span class="line">                            mp1[a][a] += mp[a1][b1];</span><br><span class="line">                            mp1[b][b] += mp[a1][b1];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    LL res = (LL)Mtree(mp1, len);</span><br><span class="line">                    ans = (ans * res) % mod;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; len; a++)</span><br><span class="line">                        par[vec[i][a]] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                fa[i] = par[i] = find(i, par);</span><br><span class="line">                vec[i].clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k == m) <span class="keyword">break</span>;</span><br><span class="line">            flag = edge[k].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = edge[k].a;</span><br><span class="line">        <span class="keyword">int</span> b = edge[k].b;</span><br><span class="line">        <span class="keyword">int</span> a1 = find(a, par);</span><br><span class="line">        <span class="keyword">int</span> b1 = find(b, par);</span><br><span class="line">        <span class="keyword">if</span>(a1 == b1) <span class="keyword">continue</span>;</span><br><span class="line">        vis[a1] = vis[b1] = <span class="number">1</span>;</span><br><span class="line">        fa[find(a1, fa)] = find(b1, fa);</span><br><span class="line">        mp[a1][b1]++;</span><br><span class="line">        mp[b1][a1]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n &amp;&amp; !flag1; i++)</span><br><span class="line">        <span class="keyword">if</span>(fa[i] != fa[i - <span class="number">1</span>]) flag1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) flag1 = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, flag1 ? <span class="number">0</span> : ans % mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//clock_t start = clock();</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)&#123;</span><br><span class="line">        init();</span><br><span class="line">        Solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//clock_t stop = clock();</span></span><br><span class="line">    <span class="comment">//printf(&quot;Time = %.2lfMS\n&quot;, (double)(stop - start) / CLOCKS_PER_SEC * 1000);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 550</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 10000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;a, <span class="keyword">const</span> Edge &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[N], fa[N], cnt[N], ne[N];</span><br><span class="line"><span class="keyword">int</span> n, m, len, from, to;</span><br><span class="line">Edge edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> *par, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        par[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> *par, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] != x) par[x] = find(par, par[x]);</span><br><span class="line">    <span class="keyword">return</span> par[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> num, <span class="keyword">int</span> &amp;ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == len)&#123;</span><br><span class="line">        init(fa, N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; from; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> fx = find(fa, edge[i].a);</span><br><span class="line">            <span class="keyword">int</span> fy = find(fa, edge[i].b);</span><br><span class="line">            <span class="keyword">if</span>(fx != fy) fa[fy] = fx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> di = ne[i];</span><br><span class="line">            <span class="keyword">int</span> fx = find(fa, edge[di].a);</span><br><span class="line">            <span class="keyword">int</span> fy = find(fa, edge[di].b);</span><br><span class="line">            <span class="keyword">if</span>(fx != fy) fa[fy] = fx;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt;= to; i++)&#123;</span><br><span class="line">            ne[num] = i;</span><br><span class="line">            dfs(i + <span class="number">1</span>, num + <span class="number">1</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    from = to = <span class="number">0</span>;</span><br><span class="line">    init(par, n);</span><br><span class="line">    edge[m].w = <span class="number">-1</span>;</span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> fx = find(par, edge[i].a);</span><br><span class="line">        <span class="keyword">int</span> fy = find(par, edge[i].b);</span><br><span class="line">        <span class="keyword">if</span>(i) cnt[i] = cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(fx != fy)&#123;</span><br><span class="line">            par[fy] = fx;</span><br><span class="line">            cnt[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].w != edge[i + <span class="number">1</span>].w)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!from) len = cnt[i];</span><br><span class="line">            <span class="keyword">else</span> len = cnt[i] - cnt[from - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            to = i;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            dfs(from, <span class="number">0</span>, c);</span><br><span class="line">            from = i + <span class="number">1</span>;</span><br><span class="line">            ans = ans * c % Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt[m - <span class="number">1</span>] == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;edge[i].a, &amp;edge[i].b, &amp;edge[i].w);</span><br><span class="line">        sort(edge, edge + m);</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小限度生成树"><a href="#最小限度生成树" class="headerlink" title="最小限度生成树"></a>最小限度生成树</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>最小度限制生成树就是给一个图，求它的满足点vo的度数最大为k的最小生成树.</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol>
<li>将v0从图中删除，将得到m个连通分量。</li>
<li>对每个连通分量求最小生成树，假设m个。</li>
<li>从每个连通分量中找与v0关联的权值最小的边，与v0相连接，这样将得到v0的最小m度生成树</li>
<li>如果 k &lt; m 那么这种树是不存在的。</li>
<li>如果 k &gt;= m, 那么考虑构建 m + 1度最小生成树, 将与v0关联的且不在当前的树中的边</li>
<li>如果将其加入树中, 必然会存在一个环，那么删掉该环中与v0不关联的权值最大边，将得到加入该边后的最小生成树，且是m + 1的。</li>
<li>枚举上述 6 的边找树权值最小, 那么即是m + 1度限制的最小生成树。如果 m + 1 度最小生成树的值大于 m 度最小生成树的话直接输出当前 m 度的值即可。、</li>
<li>重复5.6.7，直到k 度最小生成树出现。<br>由上述步骤可知，由 m 度限制生成树拓展为 m + 1 度限制生成树的过程中需要大量的重复运算, 可以运用动态规划来优化。</li>
</ol>
<p>设 $dp(v)$ 为路径 $v_0-v$ 上与 $v_0$ 无关联且权值最大的边。定义 $father(v)$ 为 v 的父结点，动态转移方程 $$p(v)=max(dp(father(v)), w(father(v),v))$$ 边界条件为 $$dp[v_0] = -\infty, dp[v^{‘}] = -\infty | (v_0, v^{‘}) \epsilon E(T)$$</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>并查集 + kruskal;<br>首先,每个连通分量的的最小生成树可以直接用一个循环,循环着 Kruskal 求出;<br>这里利用了联通分量间的独立性,对每个连通分量分别求最小生成树,和放在一起求,毫不影响;<br>而且 kruskral 算法保证了各连通分量边的有序性;<br>找最小边的时候,可以用动态规划,也可以这么做：<br>先走一个循环,但我们需要逆过来加边,将与 v0 关联的所有边从小到达排序;<br>然后将各连通分量连接起来,利用并查集可以保证每个连通分量只有一条边与 v0 相连;<br>由于边已经从小到达排序,故与每个连通分量相连的边就是每个连通分量与 v0 相连中的最小边;<br>然后求 m + 1度的最小生成树时,可以直接用DFS,最小生成树要一直求到k度,然后从中找出一个最优值;</p>
<h3 id="例题-POJ-1639"><a href="#例题-POJ-1639" class="headerlink" title="例题 [POJ 1639]"></a>例题 [<a target="_blank" rel="noopener" href="http://poj.org/problem?id=1639">POJ 1639</a>]</h3><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>给出m条边,每条边有两个端点和一个权值;<br>求这个图在满足以下条件的情况下的最小生成树:<br>在所有点中,有一个特殊点Park,它在求得的最小生成树中的度必须小于等于某个值;</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, nxt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pcnt;</span><br><span class="line"><span class="keyword">int</span> par[MAXN];</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; ma;</span><br><span class="line">Node node[MAXN * MAXN], dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ecnt, n, m, k;</span><br><span class="line"><span class="keyword">bool</span> use[MAXN][MAXN];</span><br><span class="line">Edge edge[MAXN * MAXN];</span><br><span class="line"><span class="keyword">int</span> head[MAXN], vis[MAXN], dis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Min[MAXN], tmp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ma.clear();</span><br><span class="line">    ecnt = pcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(use, <span class="number">0</span>, <span class="keyword">sizeof</span>(use));</span><br><span class="line">    <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line">    <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(node));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    fill(Min, Min + MAXN, MAX_INT);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) par[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].w = w;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u] = ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ma.find(s) == ma.end()) ma[s] = ++pcnt;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ma[s];</span><br><span class="line">    <span class="keyword">return</span> pcnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x] != x) par[x] = Find(par[x]);</span><br><span class="line">    <span class="keyword">return</span> par[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = Find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = Find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx == fy) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    par[fy] = fx;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v != s &amp;&amp; v != fa &amp;&amp; use[u][v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[v].w == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[u].w &gt; edge[i].w) dp[v] = dp[u];</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[v].w = edge[i].w;</span><br><span class="line">                    dp[v].u = u;</span><br><span class="line">                    dp[v].v = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(s, v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node[i].u == s || node[i].v == s) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Union(node[i].u, node[i].v)) <span class="keyword">continue</span>;</span><br><span class="line">        use[node[i].u][node[i].v] = use[node[i].v][node[i].u] = <span class="literal">true</span>;</span><br><span class="line">        ans += node[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    sort(node, node + n);</span><br><span class="line">    <span class="keyword">int</span> ans = kruskal(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[s]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">int</span> belong = Find(v);</span><br><span class="line">        <span class="keyword">if</span>(Min[belong] &gt; edge[i].w)&#123;</span><br><span class="line">            tmp[belong] = edge[i].v;</span><br><span class="line">            Min[belong] = edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> degree = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pcnt; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Min[i] != MAX_INT)&#123;</span><br><span class="line">            degree++;</span><br><span class="line">            use[s][tmp[i]] = use[tmp[i]][s] = <span class="literal">true</span>;</span><br><span class="line">            ans += Min[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = degree + <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">        dp[s].w = -MAX_INT;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= pcnt; j++)</span><br><span class="line">            <span class="keyword">if</span>(use[s][j]) dp[j].w = -MAX_INT;</span><br><span class="line">        dfs(s, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> temp, mi = MAX_INT;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = head[s]; j + <span class="number">1</span>; j = edge[j].nxt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mi &gt; edge[j].w - dp[edge[j].v].w)&#123;</span><br><span class="line">                mi = edge[j].w - dp[edge[j].v].w;</span><br><span class="line">                temp = edge[j].v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mi &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        use[s][temp] = use[temp][s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> u = dp[temp].u;</span><br><span class="line">        <span class="keyword">int</span> v = dp[temp].v;</span><br><span class="line">        use[u][v] = use[v][u] = <span class="literal">false</span>;</span><br><span class="line">        ans += mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">char</span> s1[<span class="number">50</span>];</span><br><span class="line">        <span class="keyword">char</span> s2[<span class="number">50</span>];</span><br><span class="line">        ma[<span class="string">&quot;Park&quot;</span>] = ++pcnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%s%d&quot;</span>, s1, s2, &amp;w);</span><br><span class="line">            u = getId(s1), v = getId(s2);</span><br><span class="line">            addEdge(u, v, w);</span><br><span class="line">            addEdge(v, u, w);</span><br><span class="line">            node[i].u = u, node[i].v = v, node[i].w = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> ans = solve(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total miles driven: %d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最优比率生成树"><a href="#最优比率生成树" class="headerlink" title="最优比率生成树"></a>最优比率生成树</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>引入：传说在2005年北京现场赛的赛场上，楼教主在5分钟搞定一题后第25分钟搞定了这个题，让所有人都以为这是一道水题，带坏了全场的节奏，200多次提交只有8个人过， 最终顺利夺冠。</p>
<p>我们设一个顶点数为n，边数为m的无环连通图G，其中 <code>cost[i]</code> 表示是第i条边花费的代价，<code>benefit[i]</code> 表示第i条边获得的收益，现要求这个图的一个生成树，使得这棵树的总花费与总收益的比值最小。这个问题就是解决最优比率生成树的问题。在实际问题当中，我们会经常遇到如修建道路要考虑收益和开销，使得代价比最小的问题。</p>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>设 $x[i]$ 等于 $1$ 或 $0$ , 表示边 $e[i]$是否属于生成树. 则我们所求的比率 $$r = sum(benefit[i] * x[i]) / \sum(cost[i] * x[i]), 0≤i&lt;m $$ 为了使 $r$ 最大, 设计一个子问题—&gt; 让 $$z = \sum(benefit[i] * x[i]) - r * \sum(cost[i] * x[i]) = \sum(d[i] * x[i]), 其中(d[i] = benefit[i] - l * cost[i]) $$并记为 $z(r)$ .</p>
<p>然后明确两个性质 :</p>
<ol>
<li><p><strong>z单调递减</strong><br>证明: 因为cost为正数, 所以z随l的减小而增大.</p>
</li>
<li><p><strong>z( max(r) ) = 0</strong><br>证明: 若$$z( max(r) ) &lt; 0$$则$$\sum(benifit[i] * x[i]) - max(r) * \sum(cost[i] * x[i]) &lt; 0$$可化为 $$max(r) &lt; max(r)$$ 矛盾;<br>若$$z( max(r) ) &gt;= 0$$, 根据性质1, 当 $z = 0$ 时r最大.<br>这样上面的问题就转化为了求 z(r) 的零点问题, 方法有以下两个:</p>
</li>
<li><p>迭代法：由上面的分析可知：<br>当 $z(r) &gt; 0$ 时，$rate$ 值无效，而 $rateNex$ 有效且$z(rateNex) &lt;= 0$;<br>当 $z(rate) &lt; 0$ 时，$rateNex &lt; rate$，又 $z(rate)$ 为单调递减函数，故 $0 &gt;= z(rateNex) &gt; z(rate)$。<br>故迭代过程向 $z(rate) == 0$ 收敛，又由有限节点的完全图其生成树只有有限个可知迭代次数必为有限值。</p>
</li>
<li><p>二分法：在定出一个搜索范围和精度之后(以$[0,MAXRATE]$为例)，我们就可以使用二分法进行搜索：对于当前的搜索区间$[low,high]$，$mid = (low + high) / 2$，根据 $z(mid)$ 的值及 $z(rate)$ 的增减性，对搜索区间进行更新：<br>从而在经过有限次搜索之后便能找到所求比率。</p>
</li>
</ol>
<h3 id="例题-POJ-2728"><a href="#例题-POJ-2728" class="headerlink" title="例题 [POJ 2728]"></a>例题 [<a target="_blank" rel="noopener" href="http://poj.org/problem?id=2728">POJ 2728</a>]</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h4><p>有n个村庄要连在一起，村与村之间的长度为他们之间的水平距离，连在一起的花费是两村的高度差。现求所花费和与长度和之比最小</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入:"></a>输入:</h4><p>n 和 n 个村庄的三维坐标</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出:"></a>输出:</h4><p>花费和与长度和的最小比值</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><h5 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ABS(x) ((x) &gt; 0 ? (x) : (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalDis</span><span class="params">(<span class="keyword">const</span> Point &amp;a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - x) * (a.x - x) + (a.y - y) * (a.y - y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalHig</span><span class="params">(<span class="keyword">const</span> Point &amp;a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ABS(h - a.h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> mp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">double</span> dis[MAXN][MAXN]; </span><br><span class="line"><span class="keyword">double</span> cost[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">double</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    fill(dist, dist + MAXN, MAX_INT);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> mi;</span><br><span class="line">    <span class="keyword">int</span> mip = s;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dist[i] = mp[s][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        mi = MAX_INT;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; mi &gt; dist[j]) mi = dist[j], mip = j;</span><br><span class="line">        ans += mi;</span><br><span class="line">        vis[mip] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dist[j] &gt; mp[mip][j])</span><br><span class="line">                dist[j] = mp[mip][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            mp[i][j] = mp[j][i] = cost[i][j] - mid * dis[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> mst = prim(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mst &gt; eps) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0.0</span>, r = <span class="number">100.0</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; eps)&#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;a[i].x, &amp;a[i].y, &amp;a[i].h);</span><br><span class="line"></span><br><span class="line">        fill(dis[<span class="number">0</span>], dis[MAXN], MAX_INT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dis[i][j] = dis[j][i] = a[i].CalDis(a[j]);</span><br><span class="line">                cost[i][j] = cost[j][i] = a[i].CalHig(a[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> ans = solve();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title=" 牛顿迭代法"></a> 牛顿迭代法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ABS(x) ((x) &gt; 0 ? (x) : (-(x)))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> MAX_INT = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>) / <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalDis</span><span class="params">(<span class="keyword">const</span> Point &amp;a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - x) * (a.x - x) + (a.y - y) * (a.y - y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalHig</span><span class="params">(<span class="keyword">const</span> Point &amp;a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ABS(h - a.h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line">Point a[MAXN];</span><br><span class="line"><span class="keyword">double</span> mp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">double</span> dis[MAXN][MAXN]; </span><br><span class="line"><span class="keyword">double</span> cost[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">double</span> dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    fill(dist, dist + MAXN, MAX_INT);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    dist[s] = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> mip = s;</span><br><span class="line">    <span class="keyword">double</span> mi = <span class="number">0.0</span>, dissum = <span class="number">0.0</span>, costsum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dist[j] &gt; mp[mip][j])&#123;</span><br><span class="line">                dist[j] = mp[mip][j];</span><br><span class="line">                pre[j] = mip;</span><br><span class="line">            &#125;</span><br><span class="line">        mi = MAX_INT;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; mi &gt; dist[j]) mi = dist[j], mip = j;</span><br><span class="line">        vis[mip] = <span class="literal">true</span>;</span><br><span class="line">        dissum += dis[mip][pre[mip]];</span><br><span class="line">        costsum += cost[mip][pre[mip]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> costsum / dissum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">double</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            mp[i][j] = mp[j][i] = cost[i][j] - mid * dis[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> last = <span class="number">0.0</span>, cur = <span class="number">-1.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ABS(cur - last) &gt; eps)&#123;</span><br><span class="line">        last = cur;</span><br><span class="line">        change(last);</span><br><span class="line">        cur = prim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;a[i].x, &amp;a[i].y, &amp;a[i].h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dis[i][j] = dis[j][i] = a[i].CalDis(a[j]);</span><br><span class="line">                cost[i][j] = cost[j][i] = a[i].CalHig(a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            dis[i][i] = cost[i][i] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> ans = solve();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/weixinpay.jpg" alt="Andrewei 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Andrewei 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag"># 图论</a>
              <a href="/tags/%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag"># 生成树</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2015/10/26/e5-b9-b6-e6-9f-a5-e9-9b-86/" rel="prev" title="并查集">
      <i class="fa fa-chevron-left"></i> 并查集
    </a></div>
      <div class="post-nav-item">
    <a href="/2015/10/28/e6-9c-80-e7-9f-ad-e8-b7-af-e5-be-84/" rel="next" title="最短路径">
      最短路径 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8"><span class="nav-number">1.2.</span> <span class="nav-text">性质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim-%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">Prim 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">主要操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">复杂度分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.1.3.1.</span> <span class="nav-text">两种实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal-%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">Kruskal 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C-1"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">主要操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">复杂度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">代码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#POJ-%E4%BE%8B%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">1.2.2.4.1.</span> <span class="nav-text">POJ 例题分析</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88k%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">次小生成树（k小生成树）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#prim%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.1.</span> <span class="nav-text">prim算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0-2"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.2.</span> <span class="nav-text">Kruskal算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0-3"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%A6%E8%A7%A3"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">另解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%AA%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">生成树个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">最小生成树的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="nav-number">3.1.1.</span> <span class="nav-text">算法思想：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#kruskal%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">kruskal算法：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">3.1.1.1.1.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E9%99%90%E5%BA%A6%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">最小限度生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.3.</span> <span class="nav-text">算法实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-POJ-1639"><span class="nav-number">4.4.</span> <span class="nav-text">例题 [POJ 1639]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E6%84%8F%EF%BC%9A"><span class="nav-number">4.4.1.</span> <span class="nav-text">题意：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">4.4.2.</span> <span class="nav-text">示例代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E6%AF%94%E7%8E%87%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">最优比率生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-1"><span class="nav-number">5.1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-1"><span class="nav-number">5.2.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-POJ-2728"><span class="nav-number">5.3.</span> <span class="nav-text">例题 [POJ 2728]</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E6%84%8F"><span class="nav-number">5.3.1.</span> <span class="nav-text">题意:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5"><span class="nav-number">5.3.2.</span> <span class="nav-text">输入:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">5.3.3.</span> <span class="nav-text">输出:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81"><span class="nav-number">5.3.4.</span> <span class="nav-text">参考代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">二分法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="nav-number">5.3.4.2.</span> <span class="nav-text"> 牛顿迭代法</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Andrewei"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Andrewei</p>
  <div class="site-description" itemprop="description">There's no feat, but what we make.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/andrewei1316" title="GitHub → https://github.com/andrewei1316" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andrewei</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
