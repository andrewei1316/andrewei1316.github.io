<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andrewei</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.andrewei.me/"/>
  <updated>2019-06-02T08:49:33.290Z</updated>
  <id>https://blog.andrewei.me/</id>
  
  <author>
    <name>Andrewei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>方法引用</title>
    <link href="https://blog.andrewei.me/2019/06/02/method-reference/"/>
    <id>https://blog.andrewei.me/2019/06/02/method-reference/</id>
    <published>2019-06-02T05:55:26.000Z</published>
    <updated>2019-06-02T08:49:33.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>方法引用</code>的基础是 Lambda 表达式，它可以认为是 Lambda 表达式的语法糖，用来简化开发。</p><p>在我们使用Lambda表达式的时候，<code>-&gt;</code> 右边部分是要执行的代码，即要完成的功能，可以把这部分称作 Lambda 体。有时候，当我们想要实现一个函数式接口的那个抽象方法，但是已经有类实现了我们想要的功能，这个时候我们就可以用方法引用来直接使用现有类的功能去实现。</p><a id="more"></a><h2 id="四种形式"><a href="#四种形式" class="headerlink" title="四种形式"></a>四种形式</h2><h3 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h3><p>语法: 类名::静态方法名</p><p>例如: <code>String::valueOf</code> 对应的 Lambda 表达式为 <code>s -&gt;String.valueOf(s)</code></p><h3 id="引用特定对象实例的方法"><a href="#引用特定对象实例的方法" class="headerlink" title="引用特定对象实例的方法"></a>引用特定对象实例的方法</h3><p>语法: 对象::对象方法</p><p>例如: <code>obj::toString</code> 对应的 Lambda 表达式为 <code>obj -&gt; obj.toString()</code></p><h3 id="引用特定类型任意对象的实例方法"><a href="#引用特定类型任意对象的实例方法" class="headerlink" title="引用特定类型任意对象的实例方法"></a>引用特定类型任意对象的实例方法</h3><p>语法: 类名::对象方法</p><p>例如: <code>String::compareTo</code> 对应的 Lambda 表达式为 <code>(str1, str2) -&gt; str1.compareTo(str2)</code></p><p>注意: 这种形式不太容易理解，虽然 <code>compareTo</code> 方法只需要一个参数，但是其对应的 Lambda 表达式中却有两个参数，其中第一个参数是 <code>调用 compareTo</code> 方法的对象本身。</p><h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><p>语法: 类名::new</p><p>例如: <code>String::new</code> 对应 Lambda 表达式的 <code>() -&gt; new String()</code></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> info.andrewei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andrewei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student str1 = <span class="keyword">new</span> Student(<span class="string">"zhangsan"</span>, <span class="number">10</span>);</span><br><span class="line">        Student str2 = <span class="keyword">new</span> Student(<span class="string">"lisi"</span>, <span class="number">50</span>);</span><br><span class="line">        Student str3 = <span class="keyword">new</span> Student(<span class="string">"wangwu"</span>, <span class="number">40</span>);</span><br><span class="line">        Student str4 = <span class="keyword">new</span> Student(<span class="string">"zhaoliu"</span>, <span class="number">30</span>);</span><br><span class="line">        List&lt;Student&gt; list;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种</span></span><br><span class="line">        list = Arrays.asList(str1, str2, str3, str4);</span><br><span class="line">        list.sort(StudentCompare::staticCompareStudentsByName);</span><br><span class="line">        list.forEach(stu -&gt; System.out.println(stu.getName()));</span><br><span class="line"></span><br><span class="line">        list.sort(StudentCompare::staticCompareStudentsByScore);</span><br><span class="line">        list.forEach(stu -&gt; System.out.println(stu.getScore()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种</span></span><br><span class="line">        StudentCompare studentCompator = <span class="keyword">new</span> StudentCompare();</span><br><span class="line">        list = Arrays.asList(str1, str2, str3, str4);</span><br><span class="line">        list.sort(studentCompator::compareStudentsByName);</span><br><span class="line">        list.forEach(stu -&gt; System.out.println(stu.getName()));</span><br><span class="line"></span><br><span class="line">        list.sort(studentCompator::compareStudentsByScore);</span><br><span class="line">        list.forEach(stu -&gt; System.out.println(stu.getScore()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三种</span></span><br><span class="line">        list = Arrays.asList(str1, str2, str3, str4);</span><br><span class="line">        list.sort(Student::comparedByName);</span><br><span class="line">        list.forEach(stu -&gt; System.out.println(stu.getName()));</span><br><span class="line"></span><br><span class="line">        list.sort(Student::comparedByScore);</span><br><span class="line">        list.forEach(stu -&gt; System.out.println(stu.getScore()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第四种</span></span><br><span class="line">        System.out.println(Student.getStudent(String::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.score = score;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">getStudent</span><span class="params">(Supplier&lt;String&gt; nameSupplier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(nameSupplier.get()+<span class="string">"_test"</span>, <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> score;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">comparedByScore</span><span class="params">(Student stu1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.score - stu1.getScore();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">comparedByName</span><span class="params">(Student stu1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(stu1.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", score="</span> + score +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentCompare</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">staticCompareStudentsByScore</span><span class="params">(Student stu1, Student stu2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stu1.getScore() - stu2.getScore();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">staticCompareStudentsByName</span><span class="params">(Student stu1, Student stu2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stu1.getName().compareTo(stu2.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareStudentsByScore</span><span class="params">(Student stu1, Student stu2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stu1.getScore() - stu2.getScore();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareStudentsByName</span><span class="params">(Student stu1, Student stu2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stu1.getName().compareTo(stu2.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">//lisi</span></span><br><span class="line"><span class="comment">//wangwu</span></span><br><span class="line"><span class="comment">//zhangsan</span></span><br><span class="line"><span class="comment">//zhaoliu</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//30</span></span><br><span class="line"><span class="comment">//40</span></span><br><span class="line"><span class="comment">//50</span></span><br><span class="line"><span class="comment">//---------------------</span></span><br><span class="line"><span class="comment">//lisi</span></span><br><span class="line"><span class="comment">//wangwu</span></span><br><span class="line"><span class="comment">//zhangsan</span></span><br><span class="line"><span class="comment">//zhaoliu</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//30</span></span><br><span class="line"><span class="comment">//40</span></span><br><span class="line"><span class="comment">//50</span></span><br><span class="line"><span class="comment">//---------------------</span></span><br><span class="line"><span class="comment">//lisi</span></span><br><span class="line"><span class="comment">//wangwu</span></span><br><span class="line"><span class="comment">//zhangsan</span></span><br><span class="line"><span class="comment">//zhaoliu</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//30</span></span><br><span class="line"><span class="comment">//40</span></span><br><span class="line"><span class="comment">//50</span></span><br><span class="line"><span class="comment">//---------------------</span></span><br><span class="line"><span class="comment">//Student&#123;name='_test', score=10&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;方法引用&lt;/code&gt;的基础是 Lambda 表达式，它可以认为是 Lambda 表达式的语法糖，用来简化开发。&lt;/p&gt;
&lt;p&gt;在我们使用Lambda表达式的时候，&lt;code&gt;-&amp;gt;&lt;/code&gt; 右边部分是要执行的代码，即要完成的功能，可以把这部分称作 Lambda 体。有时候，当我们想要实现一个函数式接口的那个抽象方法，但是已经有类实现了我们想要的功能，这个时候我们就可以用方法引用来直接使用现有类的功能去实现。&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.andrewei.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="JAVA" scheme="https://blog.andrewei.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/"/>
    
    
      <category term="java" scheme="https://blog.andrewei.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Optional 详解</title>
    <link href="https://blog.andrewei.me/2019/05/18/java-optional/"/>
    <id>https://blog.andrewei.me/2019/05/18/java-optional/</id>
    <published>2019-05-18T02:36:48.000Z</published>
    <updated>2019-05-18T04:17:50.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li><p><code>Optional</code> 的出现主要为了解决 <code>NullPointerExcepton</code> 的异常。</p></li><li><p><code>Optional</code> 是一个值的容器，用来存储一个 <code>Object</code> 或者 <code>null</code>。</p></li><li><p>它是一个<code>基于值的类(value-base class)</code>。</p><blockquote><p>基于值的类(value-base class) 需要满足以下几个条件:</p><ol><li>必须为 <code>final</code> 和 不可变的(可以包含可变对象的引用)；</li><li>必须实现 <code>equals</code>、 <code>hashCode</code> 和 <code>toString</code> 方法。并且这些方法必须仅根据当前实例的状态独自计算，而不是根据他的标识或者其他对象的状态、变量计算；</li><li>不使用身份敏感的操作，例如实例之间通过引用的 <code>==</code> 来判等、实例的 <code>hashCode</code> 已经实例内在的锁；</li><li>两个实例的相等，仅仅基于 <code>equals()</code> 方法，而不基于引用的相等(==)；</li><li>没有可访问的构造方法(构造方法为私有)，仅仅通过工厂方法来实例化对象，但是工厂方法不保证返回实例的一致性(即：第一次调用与第二次调用可能返回的实例是不同的)；</li><li>如果使用 <code>equals</code> 方法判断两个实例是相同的，那么这两个实例之间可以随意替换。</li></ol></blockquote></li></ol><a id="more"></a><h3 id="static-方法"><a href="#static-方法" class="headerlink" title="static 方法"></a>static 方法</h3><ol><li><p><code>empty()</code> 构造一个包含的值为 <code>null</code> 的 <code>Optional</code> 对象;</p></li><li><p><code>of()</code> 构造一个包含的值不为 <code>null</code> 的 <code>Optional</code> 对象;</p></li><li><p><code>ofNullable()</code> 构造一个包含的值可为 <code>null</code> 也可不为 <code>null</code> 的 <code>Optional</code> 对象;</p></li></ol><h3 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h3><h4 id="ifPresent-方法"><a href="#ifPresent-方法" class="headerlink" title="ifPresent 方法"></a>ifPresent 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If a value is present, invoke the specified consumer with the value,</span></span><br><span class="line"><span class="comment"> * otherwise do nothing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumer block to be executed if a value is present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if value is present and &#123;<span class="doctag">@code</span> consumer&#125; is</span></span><br><span class="line"><span class="comment"> * null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法接收一个 <code>Consumer</code> 对象，并且当 <code>Optional</code> 对象中包含的值不为 <code>null</code> 的时候，调用 <code>Consumer</code> 对象的 <code>accept</code> 方法.</p><p>这个方法可以提供给我们的便利是，判断当一个对象不为空的时候去做一些事情，比如 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> info.andrewei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andrewei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main ma = <span class="keyword">new</span> Main();</span><br><span class="line">        ma.print(<span class="keyword">null</span>);</span><br><span class="line">        ma.print(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种写法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != str) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种写法</span></span><br><span class="line">        Optional&lt;String&gt; optional = Optional.ofNullable(str);</span><br><span class="line">        optional.ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="orElse-方法"><a href="#orElse-方法" class="headerlink" title="orElse 方法"></a>orElse 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the value if present, otherwise return &#123;<span class="doctag">@code</span> other&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other the value to be returned if there is no value present, may</span></span><br><span class="line"><span class="comment"> * be null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value, if present, otherwise &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法接收一个与当前 <code>Optional</code> 对象包含的值类型相同的对象参数，当前 <code>Optional</code> 对象包含的值为 <code>null</code> 时，返回传入的参数，否则返回当前包含的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> info.andrewei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andrewei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main ma = <span class="keyword">new</span> Main();</span><br><span class="line">        ma.print(<span class="keyword">null</span>);</span><br><span class="line">        ma.print(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种写法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != str) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种写法</span></span><br><span class="line">        Optional&lt;String&gt; optional = Optional.ofNullable(str);</span><br><span class="line">        System.out.println(optional.orElse(<span class="string">"world"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="orElseGet-方法"><a href="#orElseGet-方法" class="headerlink" title="orElseGet 方法"></a>orElseGet 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the value if present, otherwise invoke &#123;<span class="doctag">@code</span> other&#125; and return</span></span><br><span class="line"><span class="comment"> * the result of that invocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other a &#123;<span class="doctag">@code</span> Supplier&#125; whose result is returned if no value</span></span><br><span class="line"><span class="comment"> * is present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value if present otherwise the result of &#123;<span class="doctag">@code</span> other.get()&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if value is not present and &#123;<span class="doctag">@code</span> other&#125; is</span></span><br><span class="line"><span class="comment"> * null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 <code>orElase</code> 不同的是，该方法传入的参数为 <code>Supplier</code> 的对象，当前 <code>Optional</code> 对象包含的值为 <code>null</code> 时，该方法会调用 <code>Supplier</code> 对象的 <code>get()</code> 方法来生成一个值返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> info.andrewei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andrewei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main ma = <span class="keyword">new</span> Main();</span><br><span class="line">        ma.print(<span class="keyword">null</span>);</span><br><span class="line">        ma.print(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种写法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != str) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种写法</span></span><br><span class="line">        Optional&lt;String&gt; optional = Optional.ofNullable(str);</span><br><span class="line">        System.out.println(optional.orElseGet(() -&gt; <span class="string">"world"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-方法"><a href="#map-方法" class="headerlink" title="map 方法"></a>map 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If a value is present, apply the provided mapping function to it,</span></span><br><span class="line"><span class="comment"> * and if the result is non-null, return an &#123;<span class="doctag">@code</span> Optional&#125; describing the</span></span><br><span class="line"><span class="comment"> * result.  Otherwise return an empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span> This method supports post-processing on optional values, without</span></span><br><span class="line"><span class="comment"> * the need to explicitly check for a return status.  For example, the</span></span><br><span class="line"><span class="comment"> * following code traverses a stream of file names, selects one that has</span></span><br><span class="line"><span class="comment"> * not yet been processed, and then opens that file, returning an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Optional&lt;FileInputStream&gt;&#125;:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *     Optional&lt;FileInputStream&gt; fis =</span></span><br><span class="line"><span class="comment"> *         names.stream().filter(name -&gt; !isProcessedYet(name))</span></span><br><span class="line"><span class="comment"> *                       .findFirst()</span></span><br><span class="line"><span class="comment"> *                       .map(name -&gt; new FileInputStream(name));</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Here, &#123;<span class="doctag">@code</span> findFirst&#125; returns an &#123;<span class="doctag">@code</span> Optional&lt;String&gt;&#125;, and then</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> map&#125; returns an &#123;<span class="doctag">@code</span> Optional&lt;FileInputStream&gt;&#125; for the desired</span></span><br><span class="line"><span class="comment"> * file if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; The type of the result of the mapping function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mapper a mapping function to apply to the value, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Optional&#125; describing the result of applying a mapping</span></span><br><span class="line"><span class="comment"> * function to the value of this &#123;<span class="doctag">@code</span> Optional&#125;, if a value is present,</span></span><br><span class="line"><span class="comment"> * otherwise an empty &#123;<span class="doctag">@code</span> Optional&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the mapping function is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code> 方法接收一个 <code>Function</code> 对象。返回一个新的 <code>Optional</code> 对象。</p><p>当前 <code>Optiaon</code> 对象包含的值为 <code>null</code> 时，返回一个包含 <code>null</code> 对象的 <code>Optional</code> 对象；当前 <code>Optional</code> 包含的值 <code>value</code> 不为 <code>null</code> 时，通过在 <code>value</code> 上应用 <code>Function</code> 对象的 <code>apply</code> 方法得到新值 <code>value1</code> 并构造一个包含 <code>value1</code> 的新 <code>Optional</code> 对象。即该方法可以改变值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> info.andrewei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andrewei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main ma = <span class="keyword">new</span> Main();</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.setName(<span class="string">"zhangsan"</span>);</span><br><span class="line">        p1.setAge(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        p2.setName(<span class="string">"lisi"</span>);</span><br><span class="line">        p2.setAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Company company = <span class="keyword">new</span> Company();</span><br><span class="line">        company.setName(<span class="string">"company1"</span>);</span><br><span class="line">        company.setPersonList(Arrays.asList(p1, p2));</span><br><span class="line"></span><br><span class="line">        System.out.println(ma.getCompanyPersons(<span class="keyword">null</span>));</span><br><span class="line">        System.out.println(ma.getCompanyPersons(<span class="keyword">new</span> Company()));</span><br><span class="line">        System.out.println(ma.getCompanyPersons(company));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getCompanyPersons</span><span class="params">(Company company)</span> </span>&#123;</span><br><span class="line">        Optional&lt;Company&gt; optional = Optional.ofNullable(company);</span><br><span class="line">        <span class="keyword">return</span> optional.map(Company::getPersonList).orElse(Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        List&lt;Person&gt; personList;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersonList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> personList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonList</span><span class="params">(List&lt;Person&gt; personList)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.personList = personList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter 方法"></a>filter 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If a value is present, and the value matches the given predicate,</span></span><br><span class="line"><span class="comment"> * return an &#123;<span class="doctag">@code</span> Optional&#125; describing the value, otherwise return an</span></span><br><span class="line"><span class="comment"> * empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate a predicate to apply to the value, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Optional&#125; describing the value of this &#123;<span class="doctag">@code</span> Optional&#125;</span></span><br><span class="line"><span class="comment"> * if a value is present and the value matches the given predicate,</span></span><br><span class="line"><span class="comment"> * otherwise an empty &#123;<span class="doctag">@code</span> Optional&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the predicate is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> predicate.test(value) ? <span class="keyword">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法传入一个 <code>Predicate</code> 对象，当前 <code>Optiaonal</code> 包含的值 <code>value</code> 为 <code>null</code> 或者在 <code>value</code> 上应用 <code>Predicate</code> 对象的 <code>test</code> 方法返回 <code>false</code> 时，该方法返回空的 <code>Predicate</code> 否则返回自身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> info.andrewei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andrewei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main ma = <span class="keyword">new</span> Main();</span><br><span class="line"></span><br><span class="line">        ma.print(<span class="keyword">null</span>);</span><br><span class="line">        ma.print(<span class="string">"abc"</span>);</span><br><span class="line">        ma.print(<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; optional = Optional.ofNullable(str);</span><br><span class="line"></span><br><span class="line">        Optional&lt;String&gt; newOpt = optional.filter(s -&gt; s.length() &gt; <span class="number">3</span>);</span><br><span class="line">        System.out.println(newOpt.orElse(<span class="string">"no print"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; 的出现主要为了解决 &lt;code&gt;NullPointerExcepton&lt;/code&gt; 的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; 是一个值的容器，用来存储一个 &lt;code&gt;Object&lt;/code&gt; 或者 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它是一个&lt;code&gt;基于值的类(value-base class)&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基于值的类(value-base class) 需要满足以下几个条件:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须为 &lt;code&gt;final&lt;/code&gt; 和 不可变的(可以包含可变对象的引用)；&lt;/li&gt;
&lt;li&gt;必须实现 &lt;code&gt;equals&lt;/code&gt;、 &lt;code&gt;hashCode&lt;/code&gt; 和 &lt;code&gt;toString&lt;/code&gt; 方法。并且这些方法必须仅根据当前实例的状态独自计算，而不是根据他的标识或者其他对象的状态、变量计算；&lt;/li&gt;
&lt;li&gt;不使用身份敏感的操作，例如实例之间通过引用的 &lt;code&gt;==&lt;/code&gt; 来判等、实例的 &lt;code&gt;hashCode&lt;/code&gt; 已经实例内在的锁；&lt;/li&gt;
&lt;li&gt;两个实例的相等，仅仅基于 &lt;code&gt;equals()&lt;/code&gt; 方法，而不基于引用的相等(==)；&lt;/li&gt;
&lt;li&gt;没有可访问的构造方法(构造方法为私有)，仅仅通过工厂方法来实例化对象，但是工厂方法不保证返回实例的一致性(即：第一次调用与第二次调用可能返回的实例是不同的)；&lt;/li&gt;
&lt;li&gt;如果使用 &lt;code&gt;equals&lt;/code&gt; 方法判断两个实例是相同的，那么这两个实例之间可以随意替换。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.andrewei.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="JAVA" scheme="https://blog.andrewei.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/"/>
    
    
      <category term="java" scheme="https://blog.andrewei.me/tags/java/"/>
    
      <category term="optional" scheme="https://blog.andrewei.me/tags/optional/"/>
    
  </entry>
  
  <entry>
    <title>Lambda 表达式与函数式接口</title>
    <link href="https://blog.andrewei.me/2019/05/04/java-lambda/"/>
    <id>https://blog.andrewei.me/2019/05/04/java-lambda/</id>
    <published>2019-05-04T08:54:51.000Z</published>
    <updated>2019-05-08T01:49:54.018Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>视频教程笔记，视频地址见 <a href="https://www.bilibili.com/video/av46434650" target="_blank" rel="noopener">深入理解 Java8+jdk8 源码级思想</a></p></blockquote><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><h3 id="Lambda-表达式简介"><a href="#Lambda-表达式简介" class="headerlink" title="Lambda 表达式简介"></a>Lambda 表达式简介</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Lambda 表达式可以认为是一种匿名函数(对 JAVA 而言，他是一个对象，此处暂且认为是一种匿名函数吧)，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>在 JAVA8 之前，无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法。Lambda 表达式为 JAVA 添加了缺失的函数式编程的特性，使我们能把函数作为一等公民看待</li><li>在将函数作为一等公民的语言中，Lambda 表达式的类型是函数。但是在 JAVA 中 Lambda 表达式是对象，他们必须依附于一类特别的对象类型——函数式接口。</li></ol><a id="more"></a><h3 id="Lambda-表达式的语法结构"><a href="#Lambda-表达式的语法结构" class="headerlink" title="Lambda 表达式的语法结构"></a>Lambda 表达式的语法结构</h3><ul><li>一个 Lambda 表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：<code>(int a)</code>与<code>(a)</code>效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：<code>(a, b)</code> 或 <code>(int a, int b)</code> 或 <code>(String a, int b, float c)</code></li><li>空圆括号代表参数集为空。例如：<code>() -&gt; 42</code></li><li>当只有一个参数，且其类型可推导时，圆括号 <code>()</code>  可省略。例如：<code>a -&gt; return a*a</code></li><li>Lambda 表达式的主体可包含零条或多条语句</li><li>如果 Lambda 表达式的主体只有一条语句，花括号 <code>{}</code> 可省略。匿名函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号 `{}  中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ul><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h3 id="函数式接口简介"><a href="#函数式接口简介" class="headerlink" title="函数式接口简介"></a>函数式接口简介</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>某个接口中有且只有一个抽象方法，此时该接口称为函数式接口。</p><blockquote><p> 如果接口中某个方法重写了 java.lang.Object 中的方法，则改方法不算接口的抽象方法。即下面代码声明的接口也是函数式接口<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="几个知识点"><a href="#几个知识点" class="headerlink" title="几个知识点"></a>几个知识点</h4><ol><li>如果在接口上添加了 FunctionalInterface 注解，则编译器会以函数式接口的定义来要求该接口</li><li>如果一个接口只有一个抽象方法，但是没有加上 FunctionalInterface注解，编译器也会认为该接口是函数式接口</li><li>函数式接口可以通过 lambda表达式、函数引用和构造函数引用的方式来创建</li></ol><h3 id="java8中常用的函数式接口"><a href="#java8中常用的函数式接口" class="headerlink" title="java8中常用的函数式接口"></a>java8中常用的函数式接口</h3><h4 id="Function-接口详解"><a href="#Function-接口详解" class="headerlink" title="Function 接口详解"></a>Function 接口详解</h4><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #apply(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment">     * function to its input, and then applies this function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of input to the &#123;<span class="doctag">@code</span> before&#125; function, and to the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> before the function to apply before this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment">     * function and then applies this function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if before is null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #andThen(Function)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #compose(Function)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a function that always returns its input argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input and output objects to the function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a function that always returns its input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Function</code> 函数接口一共有四个方法，其中有一个抽象方法，两个有 default 实现的方法，一个静态方法。</p><ol><li><code>R apply(T t)</code> 接收一个 <code>T</code> 类型的参数，并有一个 <code>R</code> 类型的返回值</li><li><code>&lt;V&gt; java.util.function.Function&lt;V, R&gt; compose(java.util.function.Function&lt;? super V, ? extends T&gt; before)</code> 和 <code>&lt;V&gt; java.util.function.Function&lt;T, V&gt; andThen(java.util.function.Function&lt;? super R, ? extends V&gt; after)</code> 提供了两种组合处理行为。前者是在调用自己的 <code>apply</code> 方法之前，先调用另外一个 <code>Function</code> 接口的 <code>apply</code> 方法；后者是先执行自己的 <code>apply</code> 方法，再执行另外一个 <code>Function</code> 接口的 <code>apply</code> 方法。值得注意的是，这两个函数返回的是一个实现了 <code>apply</code> 方法的新的 <code>Function</code> 对象，而不是直接返回计算后的结果，所以在调用了这两个方法后，还需要  <code>.apply(T)</code> 才能得到结果。</li><li><code>&lt;T&gt; java.util.function.Function&lt;T, T&gt; identity()</code> 用来直接返回输入的参数。</li></ol><h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> info.andrewei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andrewei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main ma = <span class="keyword">new</span> Main();</span><br><span class="line">        System.out.println(ma.compute1(<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));</span><br><span class="line">        System.out.println(ma.compute2(<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute1</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function1.compose(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute2</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function1.andThen(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 3 * (2 * 2) = 12</span></span><br><span class="line"><span class="comment">// (2 * 3) ^ 2 = 36</span></span><br></pre></td></tr></table></figure><h4 id="BIFunction-接口详解"><a href="#BIFunction-接口详解" class="headerlink" title="BIFunction 接口详解"></a>BIFunction 接口详解</h4><h5 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts two arguments and produces a result.</span></span><br><span class="line"><span class="comment"> * This is the two-arity specialization of &#123;<span class="doctag">@link</span> Function&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #apply(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the first argument to the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; the type of the second argument to the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">BiFunction&lt;T, U, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以类比 <code>Function</code> 来看。注意方法 <code>&lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)</code> 的参数为 <code>Function</code> 类型。原因也比较容易理解，因为 <code>andThen</code> 方法会先执行自己的 <code>apply</code> 方法，再执行传入的 <code>Function</code> 接口的 <code>apply</code> 方法。执行自己的 <code>apply</code> 方法只会有一个 <code>R</code> 类型的返回值，所以后面的 <code>apply</code> 方法只能有一个入参。</p><h5 id="一个例子-1"><a href="#一个例子-1" class="headerlink" title="一个例子"></a>一个例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> info.andrewei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andrewei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main ma = <span class="keyword">new</span> Main();</span><br><span class="line"></span><br><span class="line">        System.out.println(ma.compute3(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 + value2));</span><br><span class="line">        System.out.println(ma.compute3(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 - value2));</span><br><span class="line">        System.out.println(ma.compute3(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 * value2));</span><br><span class="line">        System.out.println(ma.compute3(<span class="number">1</span>, <span class="number">2</span>, (value1, value2) -&gt; value1 / value2));</span><br><span class="line"></span><br><span class="line">        System.out.println(ma.compute4(<span class="number">2</span>, <span class="number">3</span>, (value1, value2) -&gt; value1 + value2, value -&gt; value * value));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biFunction.apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biFunction.andThen(function).apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h4 id="Predicate-接口详解"><a href="#Predicate-接口详解" class="headerlink" title="Predicate 接口详解"></a>Predicate 接口详解</h4><h5 id="源码解析-2"><a href="#源码解析-2" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> false&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ANDed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> true&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ORed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of arguments to the predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetRef the object reference with which to compare for equality,</span></span><br><span class="line"><span class="comment">     *               which may be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口主要用于做判断，即<code>是否满足条件</code> 这种场景，一共有5个方法</p><ol><li><code>boolean test(T t)</code> 该方法接受一个 <code>T</code> 类型的入参，并返回 <code>boolean</code> 值</li><li><code>Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other)</code>  该方法允许传入另外一个 <code>Predicate</code> 接口，只有两个 <code>Predicate</code> 都判断为 <code>true</code> 时，才会返回 <code>true</code>，即 <code>与</code> 条件</li><li><code>Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)</code> 对比上面的方法，上面的是 <code>与</code> 条件，这个函数是 <code>或</code> 条件</li><li><code>Predicate&lt;T&gt; negate()</code> 返回 <code>!test(t)</code></li><li><code>&lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef)</code> 判断两个 <code>object</code> 是否相等。一眼看上去会感觉比较奇怪，这个函数实际上是通过出入的参数 <code>targetRef</code> 生成一个 <code>&lt;T&gt; Predicate&lt;T&gt;</code> 对象，即固定了相比较的两个 <code>object</code> 中的一个 <code>targetRef</code>，后面再调用 <code>.test(obj)</code> 来判断是否相等。</li></ol><h5 id="一个例子-2"><a href="#一个例子-2" class="headerlink" title="一个例子"></a>一个例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> info.andrewei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andrewei</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list.stream().filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList()));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(list.stream().filter(i -&gt; i % <span class="number">2</span> != <span class="number">0</span>).collect(Collectors.toList()));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(list.stream().filter(i -&gt; i &gt;= <span class="number">5</span>).collect(Collectors.toList()));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(list.stream().filter(i -&gt; i &lt; <span class="number">3</span>).collect(Collectors.toList()));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(list.stream().filter(i -&gt; <span class="keyword">true</span>).collect(Collectors.toList()));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(list.stream().filter(i -&gt; <span class="keyword">false</span>).collect(Collectors.toList()));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Main ma = <span class="keyword">new</span> Main();</span><br><span class="line"></span><br><span class="line">        System.out.println(list.stream().filter(item -&gt; ma.and(item, i -&gt; i&gt; <span class="number">5</span>, i-&gt; i % <span class="number">2</span> == <span class="number">0</span>)).collect(Collectors.toList()));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(list.stream().filter(item -&gt; ma.or(item, i -&gt; i&gt; <span class="number">5</span>, i-&gt; i % <span class="number">2</span> == <span class="number">0</span>)).collect(Collectors.toList()));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(list.stream().filter(item -&gt; ma.negate(item, i -&gt; i&gt; <span class="number">5</span>, i-&gt; i % <span class="number">2</span> == <span class="number">0</span>)).collect(Collectors.toList()));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line"></span><br><span class="line">        Predicate&lt;String&gt; isStringEqual = Predicate.isEqual(<span class="string">"string"</span>);</span><br><span class="line">        System.out.println(isStringEqual.test(<span class="string">"string"</span>));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        System.out.println(isStringEqual.test(<span class="string">"string1"</span>));</span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">and</span><span class="params">(<span class="keyword">int</span> i, Predicate&lt;Integer&gt; p1, Predicate&lt;Integer&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.and(p2).test(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">or</span><span class="params">(<span class="keyword">int</span> i, Predicate&lt;Integer&gt; p1, Predicate&lt;Integer&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.or(p2).test(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> i, Predicate&lt;Integer&gt; p1, Predicate&lt;Integer&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.and(p2).negate().test(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">//[0, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//[1, 3, 5, 7, 9]</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//[5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//[0, 1, 2]</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//[]</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//[6, 8]</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//[0, 2, 4, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//[0, 1, 2, 3, 4, 5, 7, 9]</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//-----------------------</span></span><br></pre></td></tr></table></figure><h4 id="Supplier-接口详解"><a href="#Supplier-接口详解" class="headerlink" title="Supplier 接口详解"></a>Supplier 接口详解</h4><h5 id="源码解析-3"><a href="#源码解析-3" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a supplier of results.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There is no requirement that a new or distinct result be returned each</span></span><br><span class="line"><span class="comment"> * time the supplier is invoked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #get()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of results supplied by this supplier</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口很简单，只有一个抽象方法，<code>T get()</code> 获取一个对象，每次获取的对象可以是相同的，也可以是不同的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;视频教程笔记，视频地址见 &lt;a href=&quot;https://www.bilibili.com/video/av46434650&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入理解 Java8+jdk8 源码级思想&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Lambda-表达式&quot;&gt;&lt;a href=&quot;#Lambda-表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda 表达式&quot;&gt;&lt;/a&gt;Lambda 表达式&lt;/h2&gt;&lt;h3 id=&quot;Lambda-表达式简介&quot;&gt;&lt;a href=&quot;#Lambda-表达式简介&quot; class=&quot;headerlink&quot; title=&quot;Lambda 表达式简介&quot;&gt;&lt;/a&gt;Lambda 表达式简介&lt;/h3&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;Lambda 表达式可以认为是一种匿名函数(对 JAVA 而言，他是一个对象，此处暂且认为是一种匿名函数吧)，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。&lt;/p&gt;
&lt;h4 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;在 JAVA8 之前，无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法。Lambda 表达式为 JAVA 添加了缺失的函数式编程的特性，使我们能把函数作为一等公民看待&lt;/li&gt;
&lt;li&gt;在将函数作为一等公民的语言中，Lambda 表达式的类型是函数。但是在 JAVA 中 Lambda 表达式是对象，他们必须依附于一类特别的对象类型——函数式接口。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.andrewei.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="JAVA" scheme="https://blog.andrewei.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JAVA/"/>
    
    
      <category term="java" scheme="https://blog.andrewei.me/tags/java/"/>
    
      <category term="lambda" scheme="https://blog.andrewei.me/tags/lambda/"/>
    
      <category term="函数式接口" scheme="https://blog.andrewei.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>利用git将本地Hexo生成的博客部署到服务器</title>
    <link href="https://blog.andrewei.me/2016/11/28/hexo-deploy-to-vps/"/>
    <id>https://blog.andrewei.me/2016/11/28/hexo-deploy-to-vps/</id>
    <published>2016-11-28T05:34:45.000Z</published>
    <updated>2018-04-09T01:16:07.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-简介"><a href="#hexo-简介" class="headerlink" title="hexo 简介"></a>hexo 简介</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 由于Hexo最终会生成静态页面，所以在部署的时候我们只需要将静态页面上传到服务器即可。结合git我们就可以实现一键自动部署。下面将介绍如何配置。<br><a id="more"></a></p><h2 id="服务器准备工作"><a href="#服务器准备工作" class="headerlink" title="服务器准备工作"></a>服务器准备工作</h2><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><p>在服务器上安装 git 工具<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure></p><h3 id="新建-git-用户"><a href="#新建-git-用户" class="headerlink" title="新建 git 用户"></a>新建 git 用户</h3><p>在服务器上新建 <code>git</code> 用户(当然也可以是其他名字)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -d /home/git -m git</span><br></pre></td></tr></table></figure></p><p>这个命令会新建一个用户，并创建 <code>/home/git/</code> 目录做为这个用户的目录，同时创建一个与用户名相同的组。</p><h3 id="配置-SSH-免密访问"><a href="#配置-SSH-免密访问" class="headerlink" title="配置 SSH 免密访问"></a>配置 SSH 免密访问</h3><p>在本地的电脑上（也就是你写博客的电脑上），进入 <code>~/.ssh/</code> 目录（如果没有就创建一个），执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></p><p>一路回车，会在 <code>~/.ssh/</code> 目录下生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件。把 <code>id_rsa.pub</code> 文件传到服务器的 <code>git</code> 用户目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp .ssh/id_rsa.pub git@&lt;your-ip&gt;:.</span><br></pre></td></tr></table></figure></p><p>使用 <code>git</code> 用户登录服务器，执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.ssh</span><br><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p><p>到此客户端机器就可以免密登录到服务器了。<br>如果出现不能登录的情况，可能是文件权限有问题，在服务器上做如下修改：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 ~/.ssh</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p><p>在服务器上 <code>~/.ssh/</code> 目录必须要在 <code>git</code> 用户下创建。</p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><h3 id="在服务器上创建仓库"><a href="#在服务器上创建仓库" class="headerlink" title="在服务器上创建仓库"></a>在服务器上创建仓库</h3><p>使用 <code>git</code> 用户登录服务器，执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir blog.git</span><br><span class="line">cd blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure></p><h3 id="配置-Git-Hook"><a href="#配置-Git-Hook" class="headerlink" title="配置 Git Hook"></a>配置 Git Hook</h3><p>假设 web 目录为 <code>/var/www/</code>，博客放在 <code>blog</code> 子目录中。<br>使用 <code>root</code> 用户登录服务器，进入 <code>/var/www/</code> 目录，并创建 <code>blog</code> 子目录，此时 <code>git</code> 用户没有该这个目录的写权限。用 <code>ls -l</code> 查看权限，<code>blog</code> 目录属于 <code>root</code> 用户：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x  2 root root 4096 10月 27 00:19 blog</span><br></pre></td></tr></table></figure></p><p>这个目录要给 <code>git</code> 用户访问，<code>blog.git</code> 仓库收到提交后，<code>git</code> 用户要把提交的内容再 <code>checkout</code> 到 <code>/var/www/blog/</code> 目录。因为 <code>root</code> 用户创建的这个目录 <code>git</code> 用户没有写权限，所以要把这个目录的所有权交给 <code>git</code> 用户：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown git:git blog</span><br></pre></td></tr></table></figure></p><p>再用 <code>ls -l</code> 查看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x  2 git git 4096 10月 27 00:19 blog</span><br></pre></td></tr></table></figure></p><p>切换到 <code>git</code> 用户执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone blog.git /var/www/blog</span><br></pre></td></tr></table></figure></p><p>最后一步，处理 <code>blog.git</code> 提交的事件，自动更新内容到 <code>blog</code> 目录。在 <code>git</code> 用户下执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~/blog.git/hooks</span><br><span class="line">touch post-receive</span><br><span class="line">cat &gt; post-receive &lt;&lt; EOF</span><br><span class="line"><span class="meta">&gt;</span> #!/bin/bash -l</span><br><span class="line"><span class="meta">&gt;</span> unset GIT_DIR</span><br><span class="line"><span class="meta">&gt;</span> cd /var/www/blog &amp;&amp; git pull</span><br><span class="line"><span class="meta">&gt;</span> EOF</span><br></pre></td></tr></table></figure></p><p>给脚本加上执行权限：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure></p><h2 id="配置本地-Hexo-的部署信息"><a href="#配置本地-Hexo-的部署信息" class="headerlink" title="配置本地 Hexo 的部署信息"></a>配置本地 Hexo 的部署信息</h2><p>打开 <code>_config.yml</code> 文件，找到 <code>deploy</code> 字段，修改如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  message: update</span><br><span class="line">  repository: git@&lt;your-ip&gt;:blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>如果出于安全或其它原因考虑，你修改了 SSH 默认的端口，那么上面 <code>repository</code> 的配置要做如下修改：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repository: ssh://git@&lt;your-ip&gt;:&lt;your-port&gt;/~/blog.git</span><br></pre></td></tr></table></figure></p><p>执行以下命令部署：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>如果出现以下错误：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure></p><p>是因为你还没有安装部署工具。Hexo 3.0 开始，部署工具需要单独安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>当我们完成一篇文章的编辑后， 可以直接执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></p><p>将最新的博客部署到服务器上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hexo-简介&quot;&gt;&lt;a href=&quot;#hexo-简介&quot; class=&quot;headerlink&quot; title=&quot;hexo 简介&quot;&gt;&lt;/a&gt;hexo 简介&lt;/h2&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 由于Hexo最终会生成静态页面，所以在部署的时候我们只需要将静态页面上传到服务器即可。结合git我们就可以实现一键自动部署。下面将介绍如何配置。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.andrewei.me/categories/Linux/"/>
    
      <category term="软件" scheme="https://blog.andrewei.me/categories/Linux/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="hexo" scheme="https://blog.andrewei.me/categories/Linux/%E8%BD%AF%E4%BB%B6/hexo/"/>
    
    
      <category term="hexo" scheme="https://blog.andrewei.me/tags/hexo/"/>
    
      <category term="git" scheme="https://blog.andrewei.me/tags/git/"/>
    
      <category term="blog" scheme="https://blog.andrewei.me/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu16.04上连接L2TP/IPsec的VPN</title>
    <link href="https://blog.andrewei.me/2016/11/27/Enabling-L2TP-IPSec-on-Ubuntu16-04/"/>
    <id>https://blog.andrewei.me/2016/11/27/Enabling-L2TP-IPSec-on-Ubuntu16-04/</id>
    <published>2016-11-27T11:13:28.000Z</published>
    <updated>2018-04-09T01:16:07.242Z</updated>
    
    <content type="html"><![CDATA[<p>最近有在<code>Ubuntu</code>系统上连接L2TP/IPsec协议的VPN的需求，所以在网上搜了一波，发现一名叫做<code>Werner Jaeger</code>的大神开发了一款名叫 <code>l2tp-ipsec-vpn</code> 的软件可以解决这个问题。但是在 <code>Ubuntu16.04LTS</code> 系统上，这个款软件的软件源已经不存在，后来在 <a href="http://blog.z-proj.com/enabling-l2tp-over-ipsec-on-ubuntu-16-04/" target="_blank" rel="noopener">Enabling L2TP over IPSec on Ubuntu 16.04</a> 这里看到了解决方法，为了做个备份写下这篇博客。<br><a id="more"></a></p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install intltool libtool network-manager-dev libnm-util-dev libnm-glib-dev libnm-glib-vpn-dev libnm-gtk-dev libnm-dev libnma-dev ppp-dev libdbus-glib-1-dev libsecret-1-dev libgtk-3-dev libglib2.0-dev xl2tpd strongswan</span><br></pre></td></tr></table></figure><h3 id="下载源码并编译安装"><a href="#下载源码并编译安装" class="headerlink" title="下载源码并编译安装"></a>下载源码并编译安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nm-l2tp/network-manager-l2tp.git  </span><br><span class="line"><span class="meta">#</span> 如果失效可以从这里克隆: git clone https://github.com/andrewei1316/network-manager-l2tp.git</span><br><span class="line">cd network-manager-l2tp  </span><br><span class="line">autoreconf -fi  </span><br><span class="line">intltooliz</span><br><span class="line"></span><br><span class="line">./configure --disable-static --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib/x86_64-linux-gnu --libexecdir=/usr/lib/NetworkManager --localstatedir=/var --with-pppd-plugin-dir=/usr/lib/pppd/2.4.7</span><br><span class="line"></span><br><span class="line">make  </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="取消IPsec应用程序访问控制的设置"><a href="#取消IPsec应用程序访问控制的设置" class="headerlink" title="取消IPsec应用程序访问控制的设置"></a>取消IPsec应用程序访问控制的设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apparmor_parser -R /etc/apparmor.d/usr.lib.ipsec.charon  </span><br><span class="line">sudo apparmor_parser -R /etc/apparmor.d/usr.lib.ipsec.stroke</span><br></pre></td></tr></table></figure><h3 id="用libpcap代替x2ltpd"><a href="#用libpcap代替x2ltpd" class="headerlink" title="用libpcap代替x2ltpd"></a>用libpcap代替x2ltpd</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove xl2tpd  </span><br><span class="line">sudo apt install libpcap0.8-dev</span><br><span class="line"></span><br><span class="line">wget https://github.com/xelerance/xl2tpd/archive/v1.3.6/xl2tpd-1.3.6.tar.gz  </span><br><span class="line">tar xvzf xl2tpd-1.3.6.tar.gz  </span><br><span class="line">cd xl2tpd-1.3.6  </span><br><span class="line">make  </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>最后重启计算机，就可以在<code>添加网络连接中</code>找到添加<code>L2TP</code>类型网络.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有在&lt;code&gt;Ubuntu&lt;/code&gt;系统上连接L2TP/IPsec协议的VPN的需求，所以在网上搜了一波，发现一名叫做&lt;code&gt;Werner Jaeger&lt;/code&gt;的大神开发了一款名叫 &lt;code&gt;l2tp-ipsec-vpn&lt;/code&gt; 的软件可以解决这个问题。但是在 &lt;code&gt;Ubuntu16.04LTS&lt;/code&gt; 系统上，这个款软件的软件源已经不存在，后来在 &lt;a href=&quot;http://blog.z-proj.com/enabling-l2tp-over-ipsec-on-ubuntu-16-04/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Enabling L2TP over IPSec on Ubuntu 16.04&lt;/a&gt; 这里看到了解决方法，为了做个备份写下这篇博客。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.andrewei.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.andrewei.me/tags/Linux/"/>
    
      <category term="软件" scheme="https://blog.andrewei.me/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>伸展树(SplayTree)</title>
    <link href="https://blog.andrewei.me/2016/07/11/splay-tree/"/>
    <id>https://blog.andrewei.me/2016/07/11/splay-tree/</id>
    <published>2016-07-11T02:30:56.000Z</published>
    <updated>2018-04-09T01:16:07.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ol><li>树的遍历</li><li>二叉树的基本知识</li><li>排序二叉树的基本知识</li><li>线段树区间更新和区间查询知识</li><li>平衡排序二叉树的基本知识(非必须)</li></ol><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>伸展树(SplayTree) 是一种经过改进的平衡排序二叉树, 他跟平衡二叉树的操作非常类似，同时也有很多不同。<br><a id="more"></a></p><blockquote><p>伸展树的性质有:</p><ul><li>通过节点的旋转来调整树的结构来达到某种目的;</li><li>整棵树保证有序性，即无论怎么旋转整棵树的中序遍历的顺序是一定的，不会发生改变;</li><li>伸展树不能保证树是“平衡”的，也导致了它不能保证所有操作的时间复杂度都在 $O(log(n))$, 但是从统计意义上来讲，它可以使得所有操作的均摊复杂度为 $(O(log(n))$;</li><li>伸展树保证了“八二原则”（或者称为“九一原则”，即 $80\%$ 的操作都集中在 $20\%$ 的数据上), 也就是说在伸展树中对某些值操作的次数越多，那么对这些数操作的复杂度就会越来越低，这个特性拥有非常好的现实意义。</li></ul></blockquote><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><blockquote><p>以下所有操作的示例代码以 <code>区间更新，区间求和</code> 问题为例给出，代码参考了<a href="http://www.cnblogs.com/kuangbin/archive/2013/04/21/3034081.html" target="_blank" rel="noopener">kuangbin博客</a>，特此说明.</p></blockquote><p><strong> 代码说明: </strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> key_value tree[tree[root].ch[1]].ch[0]</span></span><br><span class="line"><span class="comment">// 定义了一个宏，代表根节点的右儿子的左儿子，我们在进行操作时都会尽量把数据集中在这个地方</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;                    <span class="comment">// 数据规模</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>);                  <span class="comment">// 定义了一个极值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];                              <span class="comment">// 左右儿子</span></span><br><span class="line">    <span class="keyword">int</span> pre, val, size;                     <span class="comment">// 父节点，当前节点的值，当前节点为根的子树的大小</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;                          <span class="comment">// 当前节点为根的子树的和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rev, add, same;                     <span class="comment">// 反转标记, 增量延迟标记， 区间所有元素相同标记</span></span><br><span class="line">    <span class="keyword">int</span> lx, rx, mx;                         <span class="comment">// 从区间最左端开始的子序列最大和，从区间最右端开始的区间子序列最大和，整个区间里面子序列最大和</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root, total;                            <span class="comment">// 根节点，节点数量</span></span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; mPool;                          <span class="comment">// 内存池，用来存储删除节点时释放的节点, 以便之后使用</span></span><br><span class="line">Node tree[maxn];                            <span class="comment">// 树的所有节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;                                   <span class="comment">// n 个数， q 个询问</span></span><br><span class="line"><span class="keyword">int</span> data[maxn];                             <span class="comment">// 原始数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAdd</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> add)</span></span>;            <span class="comment">// 更新增量延迟标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateRev</span><span class="params">(<span class="keyword">int</span> rt)</span></span>;                     <span class="comment">// 更新反转延迟标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSame</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>;           <span class="comment">// 更新区间数值相同延迟标记</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span>;                        <span class="comment">// 回朔时根据子节点来更新父节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> rt)</span></span>;                      <span class="comment">// 向树的深处遍历时将父节点的延迟标记推到子节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> pre, <span class="keyword">int</span> val)</span></span>;    <span class="comment">// 添加新节点, (当前根节点，父节点，添加的值)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pre, <span class="keyword">int</span> *a)</span></span>;</span><br><span class="line">                                            <span class="comment">// 建树, (当前根节点，区间左端点，区间右端点，父节点，原始数据)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> *data)</span></span>;                       <span class="comment">// 初始化整棵树调用建树函数，(原始数据)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> com)</span></span>;              <span class="comment">// 单旋操作，将 cur 节点左(com==0)右(com==1)旋, (旋转的节点，控制左右旋)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> tar)</span></span>;                <span class="comment">// 实现树的调整，将 rt 节点调整到 tar 节点的下面，(要调整的节点，目的节点)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> k)</span></span>;                  <span class="comment">// 得到第 k 个数，（当前根，第k个数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValMinPos</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>;          <span class="comment">// 得到比 val 大的最小值的位置(当前节点，val);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValPos</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>;             <span class="comment">// 得到 val 的位置，（当前节点，val);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValRank</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>;            <span class="comment">// 得到 val 的排名, （当前节点，val);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> rt)</span></span>;                         <span class="comment">// 得到最小的数字&lt;树中的数基于大小排列&gt;(当前节点);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> rt)</span></span>;                         <span class="comment">// 得到最大的数字&lt;树中的数基于大小排列&gt;(当前节点);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertOne</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>;             <span class="comment">// 在第 x 个数后面插入 val;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> rt)</span></span>;                         <span class="comment">// 内存回收，在删除节点的时候调用(删除的节点);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteOne</span><span class="params">(<span class="keyword">int</span> k)</span></span>;                      <span class="comment">// 回收第 k 个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt, <span class="keyword">int</span> *val)</span></span>;    <span class="comment">// 在第 pos 个数后插入 cnt 个数，这些数存放在 val 数组中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt)</span></span>;              <span class="comment">// 从第 pos 个数开始连续删除 cnt 个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>;                  <span class="comment">// 获取区间[l, r]中的和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAdd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span>;        <span class="comment">// 将 [l, r] 区间的所有值都增加 val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSame</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt, <span class="keyword">int</span> val)</span></span>;   <span class="comment">// 从 pos 开始连续的 cnt 个数都变为 val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revolve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> T)</span></span>;          <span class="comment">// 区间滑动，将 [l, r] 区间循环右移 T 个单位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>;                 <span class="comment">// 区间反转，将 [l, r] 区间内的数完全反转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMaxSum</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt)</span></span>;           <span class="comment">// 求从 pos 开始的连续 cnt 长度的区间内的子序列最大和</span></span><br></pre></td></tr></table></figure></p><p><strong> 接下来边讲算法原理边实现代码: </strong></p><p>下面是 <code>pushUp</code>, <code>pushDown</code> 还有延迟标记的处理， 与线段树区间操作类似，不再赘述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新增量延迟标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAdd</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span>;</span><br><span class="line">    tree[rt].add += add;</span><br><span class="line">    tree[rt].val += add;</span><br><span class="line">    tree[rt].sum += (<span class="keyword">long</span> <span class="keyword">long</span>)add * tree[rt].size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新反转延迟标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateRev</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span>;</span><br><span class="line">    tree[rt].rev ^= <span class="number">1</span>;</span><br><span class="line">    swap(tree[rt].lx, tree[rt].rx);</span><br><span class="line">    swap(tree[rt].ch[<span class="number">0</span>], tree[rt].ch[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新区间元素值相同延迟标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSame</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span>;</span><br><span class="line">    tree[rt].val = val;</span><br><span class="line">    tree[rt].sum = val * tree[rt].size;</span><br><span class="line">    tree[rt].lx = tree[rt].rx = tree[rt].mx = max(val, val * tree[rt].size);</span><br><span class="line">    tree[rt].same = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过孩子节点的数据来更新父节点的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lson = tree[rt].ch[<span class="number">0</span>], rson = tree[rt].ch[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点的大小</span></span><br><span class="line">    tree[rt].size = tree[lson].size + tree[rson].size + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新该节点及其子树所有值的和</span></span><br><span class="line">    tree[rt].sum = tree[lson].sum + tree[rson].sum + tree[rt].val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新子序列最大值</span></span><br><span class="line">    tree[rt].lx = max((<span class="keyword">long</span> <span class="keyword">long</span>)tree[lson].lx, tree[lson].sum + tree[rt].val + max(<span class="number">0</span>, tree[rson].lx));</span><br><span class="line">    tree[rt].rx = max((<span class="keyword">long</span> <span class="keyword">long</span>)tree[rson].rx, tree[rson].sum + tree[rt].val + max(<span class="number">0</span>, tree[lson].rx));</span><br><span class="line">    tree[rt].mx = max(<span class="number">0</span>, tree[lson].rx) + tree[rt].val + max(<span class="number">0</span>, tree[rson].lx);</span><br><span class="line">    tree[rt].mx = max(tree[rt].mx, max(tree[lson].mx, tree[rson].mx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父节点的延迟标记更新到孩子节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新增量延迟标记</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].add)&#123;</span><br><span class="line">        updateAdd(tree[rt].ch[<span class="number">0</span>], tree[rt].add);</span><br><span class="line">        updateAdd(tree[rt].ch[<span class="number">1</span>], tree[rt].add);</span><br><span class="line">        tree[rt].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新区间相同标记</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].same)&#123;</span><br><span class="line">        updateSame(tree[rt].ch[<span class="number">0</span>], tree[rt].val);</span><br><span class="line">        updateSame(tree[rt].ch[<span class="number">1</span>], tree[rt].val);</span><br><span class="line">        tree[rt].same = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新反转标记</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].rev)&#123;</span><br><span class="line">        updateRev(tree[rt].ch[<span class="number">0</span>]);</span><br><span class="line">        updateRev(tree[rt].ch[<span class="number">1</span>]);</span><br><span class="line">        tree[rt].rev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>建树时要考虑数据的顺序问题，这是由你需要求解的问题所决定的。这些顺序包括，按照插入数据的大小排序，数据的原始排列顺序等等。</p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> pre, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mPool.empty())&#123;</span><br><span class="line">        rt = mPool.top();</span><br><span class="line">        mPool.pop();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        rt = ++total;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[rt].pre = pre;</span><br><span class="line">    tree[rt].size = <span class="number">1</span>;</span><br><span class="line">    tree[rt].val = val;</span><br><span class="line">    tree[rt].add = <span class="number">0</span>;</span><br><span class="line">    tree[rt].sum = val;</span><br><span class="line">    tree[rt].rev = tree[rt].same = <span class="number">0</span>;</span><br><span class="line">    tree[rt].ch[<span class="number">0</span>] = tree[rt].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    tree[rt].lx = tree[rt].rx = tree[rt].mx = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pre, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    newNode(cur, pre, a[mid]);</span><br><span class="line">    buildTree(tree[cur].ch[<span class="number">0</span>], l, mid - <span class="number">1</span>, cur, a);</span><br><span class="line">    buildTree(tree[cur].ch[<span class="number">1</span>], mid + <span class="number">1</span>, r, cur, a);</span><br><span class="line">    pushUp(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> *data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    root = total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!mPool.empty()) mPool.pop();</span><br><span class="line">    tree[root].rev = tree[root].same = <span class="number">0</span>;</span><br><span class="line">    tree[root].ch[<span class="number">0</span>] = tree[root].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    tree[root].lx = tree[root].rx = tree[root].mx = -INF;</span><br><span class="line">    tree[root].sum = tree[root].add = tree[root].val = <span class="number">0</span>;</span><br><span class="line">    tree[root].pre = tree[root].size = tree[root].sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    newNode(root, <span class="number">0</span>, <span class="number">-1</span>);                           <span class="comment">// 注1</span></span><br><span class="line">    newNode(tree[root].ch[<span class="number">1</span>], root, <span class="number">-1</span>);            <span class="comment">// 注2</span></span><br><span class="line"></span><br><span class="line">    buildTree(key_value, <span class="number">0</span>, n - <span class="number">1</span>, tree[root].ch[<span class="number">1</span>], data);</span><br><span class="line"></span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注1和注2插入了两个多余的结点，无论对树进行什么操作，这两个节点 <code>总是</code> 一个在 <code>树的根的上面</code>， 一个在树的<code>最右子树的叶节点</code>。 插入这两个节点的原因是，有这两个节点时可以避免讨论父节点是否是根节点，和叶节点是否是最右节点这两种情况。这两种情况都是特殊情况，正常情况下应该进行讨论。这种思想类似于无头链表和有头链表，可以去了解一下。</p></blockquote><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>伸展树的大部分操作是以旋转为基础的，伸展树最重要的也是它的旋转操作，旋转操作一般有三组共六种操作，下面来讲一下这些旋转操作:</p><h4 id="单旋"><a href="#单旋" class="headerlink" title="单旋"></a>单旋</h4><p>当目标节点是根节点的左子节点或右子节点时，进行一次单旋转，将目标节点调整到根节点的位置。<br><img src="/images/splay-tree/splay-tree1.png" alt="右旋"><br><img src="/images/splay-tree/splay-tree2.png" alt="左旋"></p><h4 id="一字型双旋"><a href="#一字型双旋" class="headerlink" title="一字型双旋"></a>一字型双旋</h4><p>节点 <code>A</code> 的父节点 <code>B</code> 不是根节点，<code>B</code> 的父节点为 <code>C</code>，且 <code>A</code> 与 <code>B</code> 同时是各自父节点的左孩子或者同时是各自父节点的右孩子。这时，我们进行一次左左旋转操作或者右右旋转操作。</p><h5 id="一字型双右旋"><a href="#一字型双右旋" class="headerlink" title="一字型双右旋"></a>一字型双右旋</h5><p><img src="/images/splay-tree/splay-tree3.png" alt="一字型双右旋"></p><h5 id="一字型双左旋"><a href="#一字型双左旋" class="headerlink" title="一字型双左旋"></a>一字型双左旋</h5><p><img src="/images/splay-tree/splay-tree4.png" alt="一字型双左旋"></p><h4 id="之字型双旋"><a href="#之字型双旋" class="headerlink" title="之字型双旋"></a>之字型双旋</h4><p>节点 <code>A</code> 的父节点 <code>B</code> 不是根节点，<code>B</code> 的父节点为 <code>C</code> ， <code>A</code> 与 <code>B</code> 中一个是其父节点的左孩子而另一个是其父节点的右孩子。这时，我们进行一次左右旋转操作或者右左旋转操作。</p><h5 id="之字型先右后左"><a href="#之字型先右后左" class="headerlink" title="之字型先右后左"></a>之字型先右后左</h5><p><img src="/images/splay-tree/splay-tree5.png" alt="之字型先右后左"></p><h5 id="之字型先左后右"><a href="#之字型先左后右" class="headerlink" title="之字型先左后右"></a>之字型先左后右</h5><p><img src="/images/splay-tree/splay-tree6.png" alt="之字型先左后右"></p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现单旋</span></span><br><span class="line"><span class="comment">// com == 0 时， 对 cur 节点进行左旋</span></span><br><span class="line"><span class="comment">// com == 1 时， 对 cur 节点进行右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> com)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = tree[cur].pre;</span><br><span class="line">    pushDown(pre);</span><br><span class="line">    pushDown(cur);</span><br><span class="line"></span><br><span class="line">    tree[pre].ch[!com] = tree[cur].ch[com];</span><br><span class="line">    tree[tree[cur].ch[com]].pre = pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上面的语句可以展开成下面的语句</span></span><br><span class="line"><span class="comment">    if(com)&#123;</span></span><br><span class="line"><span class="comment">        tree[pre].ch[0] = tree[cur].ch[1];    </span></span><br><span class="line"><span class="comment">        tree[tree[cur].ch[1]].pre = pre;</span></span><br><span class="line"><span class="comment">    &#125;else&#123;</span></span><br><span class="line"><span class="comment">        tree[pre].ch[1] = tree[cur].ch[0];   </span></span><br><span class="line"><span class="comment">        tree[tree[cur].ch[0]].pre = pre;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tree[pre].pre)&#123;</span><br><span class="line">        tree[tree[pre].pre].ch[tree[tree[pre].pre].ch[<span class="number">1</span>] == pre] = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tree[cur].pre = tree[pre].pre;</span><br><span class="line">    tree[cur].ch[com] = pre;</span><br><span class="line">    tree[pre].pre = cur;</span><br><span class="line">    pushUp(pre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现树的调整</span></span><br><span class="line"><span class="comment">// 将 rt 节点调整到 tar 下面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> tar)</span></span>&#123;</span><br><span class="line">    pushDown(rt);</span><br><span class="line">    <span class="keyword">while</span>(tree[rt].pre != tar)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[tree[rt].pre].pre == tar)&#123;</span><br><span class="line">            pushDown(tree[rt].pre);</span><br><span class="line">            pushDown(rt);</span><br><span class="line">            rotate(rt, tree[tree[rt].pre].ch[<span class="number">0</span>] == rt);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pushDown(tree[tree[rt].pre].pre);</span><br><span class="line">            pushDown(tree[rt].pre);</span><br><span class="line">            pushDown(rt);</span><br><span class="line">            <span class="keyword">int</span> pre = tree[rt].pre;</span><br><span class="line">            <span class="keyword">int</span> com = tree[tree[pre].pre].ch[<span class="number">0</span>] == pre;</span><br><span class="line">            <span class="keyword">if</span>(tree[pre].ch[com] == rt)&#123;</span><br><span class="line">                rotate(rt, !com);</span><br><span class="line">                rotate(rt, com);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rotate(pre, com);</span><br><span class="line">                rotate(rt, com);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pushUp(rt);</span><br><span class="line">    <span class="keyword">if</span>(tar == <span class="number">0</span>) root = rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="获取某个值"><a href="#获取某个值" class="headerlink" title="获取某个值"></a>获取某个值</h3><p>通常 splay 树的操作都是先得到一个数，然后以此作为基本再进行其他操作。</p><h4 id="获取第-k-个数"><a href="#获取第-k-个数" class="headerlink" title="获取第 k 个数"></a>获取第 k 个数</h4><p>可以通过左右子树的大小获得:<br>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    pushDown(rt);</span><br><span class="line">    <span class="keyword">int</span> tmp = tree[tree[rt].ch[<span class="number">0</span>]].size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp == k) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tmp &gt; k) <span class="keyword">return</span> getKth(tree[rt].ch[<span class="number">0</span>], k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> getKth(tree[rt].ch[<span class="number">1</span>], k - tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="获得大于-val-的最小数位置"><a href="#获得大于-val-的最小数位置" class="headerlink" title="获得大于 val 的最小数位置"></a>获得大于 val 的最小数位置</h4><p>此操作基于树的中序遍历是一个不减序列，通过遍历树可求得<br>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValMinPos</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Min = INF;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">        pushDown(rt);</span><br><span class="line">        <span class="keyword">if</span>(tree[rt].val == val) <span class="keyword">return</span> rt;</span><br><span class="line">        <span class="keyword">if</span>(tree[rt].val &gt; a)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Min &gt; tree[rt].val)&#123;</span><br><span class="line">                Min = tree[rt].val;</span><br><span class="line">                pos = rt;</span><br><span class="line">            &#125;</span><br><span class="line">            rt = tree[rt].ch[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> rt = tree[rt].ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>同理可得小于 <code>val</code> 的最大值.</p></blockquote><h4 id="获取值为-val-的数的排名"><a href="#获取值为-val-的数的排名" class="headerlink" title="获取值为 val 的数的排名"></a>获取值为 val 的数的排名</h4><p>此操作基于 splay 树中的值唯一，且树的中序遍历是一个不减序列.<br>先遍历整棵树，找到 <code>val</code> 的位置，然后将 <code>val</code> 旋转到 <code>root</code> 位置， 然后 <code>root 的左子树的 size + 1</code> 即所求.<br>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 得到 val 的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValPos</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[rt].val == val) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree[rt].val &gt; val)</span><br><span class="line">        <span class="keyword">return</span> getValPos(tree[rt].ch[<span class="number">0</span>], val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getValPos(tree[rt].ch[<span class="number">1</span>], val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValRank</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = getValPos(root, val);</span><br><span class="line">    splay(pos, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[root].ch[<span class="number">0</span>]) res += tree[tree[root].ch[<span class="number">0</span>]].size;</span><br><span class="line">    res += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="获取最小数的位置"><a href="#获取最小数的位置" class="headerlink" title="获取最小数的位置"></a>获取最小数的位置</h4><p>此操作基于树的中序遍历是一个不减序列;<br>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    pushDown(rt);</span><br><span class="line">    <span class="keyword">while</span>(tree[rt].ch[<span class="number">0</span>])&#123;</span><br><span class="line">        rt = tree[rt].ch[<span class="number">0</span>];</span><br><span class="line">        pushDown(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="获取最大数的位置"><a href="#获取最大数的位置" class="headerlink" title="获取最大数的位置"></a>获取最大数的位置</h4><p>此操作基于树的中序遍历是一个不减序列;<br>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    pushDown(rt);</span><br><span class="line">    <span class="keyword">while</span>(tree[rt].ch[<span class="number">1</span>])&#123;</span><br><span class="line">        rt = tree[rt].ch[<span class="number">1</span>];</span><br><span class="line">        pushDown(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入元素是树的基本操作， 方法是根据建树时所遵循的元素顺序，将 <code>key</code> 插入至树中合适的叶子节点上(比如元素从小到大排列时合适的顺序等)。</p><p>以在 <code>x</code> 个数后面插入 <code>val</code> 为例:<br>先把第 <code>x</code> 个数旋转到 <code>root</code> 位置，然后将第 <code>x + 1</code> 个数旋转到 <code>root 的右儿子</code> 的位置，此时只需把将要插入的数插入到 <code>root左儿子</code> 位置即可.</p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在第 x 个数后面插入 val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertOne</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, x + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, x + <span class="number">2</span>), root);</span><br><span class="line">    newNode(key_value, tree[root].ch[<span class="number">1</span>], val);</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>以删除第 <code>k</code> 个数为例:<br>先将第 <code>k - 1</code> 个数调整到 <code>root</code> 位置， 再将 <code>k + 1</code> 个数调整到 <code>root</code> 的右儿子，则第 <code>k</code> 个数在 <code>root 的右儿子的左儿子</code> 的位置。</p><p>参考代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回收内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt)&#123;</span><br><span class="line">        mPool.push(rt);</span><br><span class="line">        erase(tree[rt].ch[<span class="number">0</span>]);</span><br><span class="line">        erase(tree[rt].ch[<span class="number">1</span>]);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第 k 个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteOne</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, k), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, k + <span class="number">2</span>), root);</span><br><span class="line">    erase(key_value);</span><br><span class="line">    tree[key_value].pre = <span class="number">0</span>;</span><br><span class="line">    key_value = <span class="number">0</span>;</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拓展操作"><a href="#拓展操作" class="headerlink" title="拓展操作"></a>拓展操作</h2><p>拓展操作是基本操作的各种组合形成的，现在讨论几个典型的示例.</p><h3 id="区间操作"><a href="#区间操作" class="headerlink" title="区间操作"></a>区间操作</h3><p><strong> 问题1：</strong> 在某个点 <code>L</code> 后插入连续一段区间<br><strong> 解答: </strong><br>将 <code>pos</code> 旋转至根节点，再将 <code>（L+1）</code> 旋转至根节点的右子节点处。在 <code>（L+1）</code> 的左子节点进行逐个插入。<br><img src="/images/splay-tree/splay-tree7.jpg" alt="区间插入"></p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从第 pos 个数后开始插入 val 数组中的数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt, <span class="keyword">int</span> *val)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, pos + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, pos + <span class="number">2</span>), root);</span><br><span class="line">    buildTree(key_value, <span class="number">0</span>, cnt - <span class="number">1</span>, tree[root].ch[<span class="number">1</span>], val);</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 问题2：</strong> 删除一段连续区间 <code>[L,R]</code>：<br><strong> 解答: </strong><br>将节点 <code>（L-1）</code> 旋转至根节点，再将 <code>（R+1）</code> 旋转至 <code>(L-1)</code> 的右子节点处。此时 <code>（R+1）</code> 的左子树就是区间 <code>[L，R]</code>。<br>将整棵左子树删除即可。<br><img src="/images/splay-tree/splay-tree8.jpg" alt="区间删除"></p><p>参考代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 pos 个数开始连续删除 cnt 个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, pos), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, pos + cnt + <span class="number">1</span>), root);</span><br><span class="line">    erase(key_value);</span><br><span class="line">    tree[key_value].pre = <span class="number">0</span>;</span><br><span class="line">    key_value = <span class="number">0</span>;</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 问题3：</strong> 求区间[L,R]所有元素的和<br><strong> 解答: </strong><br>将节点 <code>（L-1）</code> 旋转至根节点，再将 <code>（R+1）</code> 旋转至 <code>(L-1)</code> 的右子节点处。此时 <code>（R+1）</code> 的左子树就是区间 <code>[L，R]</code>。左子树的根节点的 <code>sum</code> 就是所求结果。<br><img src="/images/splay-tree/splay-tree8.jpg" alt="区间求和"></p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 [l, r] 的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, l), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    <span class="keyword">return</span> tree[key_value].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 问题4：</strong> 区间更新<br><strong> 解答: </strong><br>将节点 <code>（L-1）</code> 旋转至根节点，再将 <code>（R+1）</code> 旋转至 <code>(L-1)</code> 的右子节点处。此时 <code>（R+1）</code> 的左子树就是区间 <code>[L，R]</code> 。更新整棵左子树。（若更新操作过多，可使用类似于线段树的延迟标记）。<br><img src="/images/splay-tree/splay-tree8.jpg" alt="区间更新"></p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [l, r] 区间的所有值都增加 val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAdd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, l), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    updateAdd(key_value, val);</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 pos 开始的连续 cnt 个数都更改为 val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSame</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, pos), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, pos + cnt + <span class="number">1</span>), root);</span><br><span class="line">    updateSame(key_value, val);</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 问题5：</strong> 区间循环滑动<br>假设原来的区间为 [L, R], 区间中的数值为[2, 3, 4, 5], 现在将其循环滑动 3 次， 则序列变为 [3, 4, 5, 2];<br><strong> 解答: </strong><br>将节点 <code>（L-1）</code> 旋转至根节点，再将 <code>（R+1）</code> 旋转至 <code>(L-1)</code> 的右子节点处。此时 <code>（R+1）</code> 的左子树就是区间 <code>[L，R]</code>。假设滑动后的区间为 <code>[l,R,L,r]</code> (对应在原来区间中的位置为 <code>[L,r,l,R]</code>)。<br>将 <code>r</code> 节点旋转至 <code>（R+1）</code> 左子树的根节点。再将 <code>R</code> 旋转至 <code>r</code> 节点的右子树的根节点。然后搬移两颗子树即可.<br><img src="/images/splay-tree/splay-tree9.jpg" alt="区间滑动"><br><img src="/images/splay-tree/splay-tree10.jpg" alt="区间滑动"></p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 [l, r] 区间循环右移 T 个单位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revolve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    T = (T % len + len) % len;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> c = r - T + <span class="number">1</span>;</span><br><span class="line">    splay(getKth(root, c), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    <span class="keyword">int</span> tmp = key_value;</span><br><span class="line">    key_value = <span class="number">0</span>;</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">    splay(getKth(root, l), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, l + <span class="number">1</span>), root);</span><br><span class="line">    key_value = tmp;</span><br><span class="line">    tree[key_value].pre = tree[root].ch[<span class="number">1</span>];</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 问题6：</strong> 区间反转<br><strong> 解答: </strong><br>将节点 <code>（L-1）</code> 旋转至根节点，再将 <code>（R+1）</code> 旋转至 <code>(L-1)</code> 的右子节点处。此时 <code>（R+1）</code> 的左子树就是区间 <code>[L，R]</code>。然后依次交换左右子树即可。（也可使用延迟标记）<br><img src="/images/splay-tree/splay-tree11.jpg" alt="区间反转"><br><img src="/images/splay-tree/splay-tree12.jpg" alt="区间反转"></p><p>参考代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, l), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    updateRev(key_value);</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 问题7：</strong> 区间子序列最大的和<br><strong> 解答: </strong><br>每个节点维护三个值。区间 <code>[L,R]</code> 表示以节点 <code>i</code> 为根节点的子树的区间。<code>lx[i]</code> 表示以 <code>L</code> 为左起点的子序列的最大和。<br><code>rx[i]</code> 表示以 <code>R</code> 为右结尾的子序列的最大和。<code>mx[i]</code> 表示区间子序列最大和。<br><code>mx</code> 可由 子节点的值转移而来: (转移的过程发生在树结构或者节点值发生变化时)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lx[i] = max(lx[lson],sum[lson] + key[i] + max(<span class="number">0</span>,lx[rson]));</span><br><span class="line">rx[i] = max(rx[rson],sum[rson] + key[i] + max(<span class="number">0</span>,rx[lson]));</span><br><span class="line">mx[i] = max(<span class="number">0</span>,rx[lson]) + key[i] + max(<span class="number">0</span>,lx[rson]);</span><br><span class="line">mx[i] = max(mx[i],max(mx[lson],mx[rson]));</span><br></pre></td></tr></table></figure></p><p>有了这个 <code>mx</code> 值。就可以将节点 <code>（L-1）</code> 旋转至根节点，再将 <code>（R+1）</code> 旋转至 <code>(L-1)</code> 的右子节点处。此时 <code>（R+1）</code> 的左子树就是区间 <code>[L，R]</code>。<br>左子树的根节点的 <code>mx</code> 值就是所求的。<br><img src="/images/splay-tree/splay-tree13.jpg" alt="区间子序列最大的和"></p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 pos 开始连续 cnt 长度的区间内子序列的最大和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxSum</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, pos), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, pos + cnt + <span class="number">1</span>), root);</span><br><span class="line">    <span class="keyword">return</span> tree[key_value].mx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跟线段树相同，根据题目要求splay维护的东西也不同，需要按照题目要求来自行修改。在懂得splay树的操作之后，在重要的是利用他的这些特性来快速的解决问题，比如怎么旋转之后可以快速放方便的得到结果等等。<br>下面是一份完整的代码，综合了目前见过的一些需要维护的东西。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment"># author:            Andrewei</span></span><br><span class="line"><span class="comment"># last modified:     2016-07-12 08:22</span></span><br><span class="line"><span class="comment"># filename:          a.cpp</span></span><br><span class="line"><span class="comment"># description: </span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> key_value tree[tree[root].ch[1]].ch[0]</span></span><br><span class="line"><span class="comment">// 定义了一个宏，代表根节点的右儿子的左儿子，我们在进行操作时都会尽量把数据集中在这个地方</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500010</span>;                    <span class="comment">// 数据规模</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>);                  <span class="comment">// 定义了一个极大值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">2</span>];                              <span class="comment">// 左右儿子</span></span><br><span class="line">    <span class="keyword">int</span> pre, val, size;                     <span class="comment">// 父节点，当前节点的值，当前节点为根的子树的大小</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;                          <span class="comment">// 当前节点为根的子树的和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rev, add, same;                     <span class="comment">// 反转标记, 增量延迟标记， 区间所有元素相同标记</span></span><br><span class="line">    <span class="keyword">int</span> lx, rx, mx;                         <span class="comment">// 从区间最左端开始的子序列最大和，从区间最右端开始的区间子序列最大和，整个区间里面子序列最大和</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root, total;                            <span class="comment">// 根节点，节点数量</span></span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; mPool;                          <span class="comment">// 内存池，用来存储删除节点时释放的节点, 以便之后使用</span></span><br><span class="line">Node tree[maxn];                            <span class="comment">// 树的所有节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;                                   <span class="comment">// n 个数， q 个询问</span></span><br><span class="line"><span class="keyword">int</span> data[maxn];                             <span class="comment">// 原始数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新增量延迟标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAdd</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span>;</span><br><span class="line">    tree[rt].add += add;</span><br><span class="line">    tree[rt].val += add;</span><br><span class="line">    tree[rt].sum += (<span class="keyword">long</span> <span class="keyword">long</span>)add * tree[rt].size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新反转延迟标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateRev</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span>;</span><br><span class="line">    tree[rt].rev ^= <span class="number">1</span>;</span><br><span class="line">    swap(tree[rt].lx, tree[rt].rx);</span><br><span class="line">    swap(tree[rt].ch[<span class="number">0</span>], tree[rt].ch[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新区间元素值相同延迟标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSame</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span>;</span><br><span class="line">    tree[rt].val = val;</span><br><span class="line">    tree[rt].sum = val * tree[rt].size;</span><br><span class="line">    tree[rt].lx = tree[rt].rx = tree[rt].mx = max(val, val * tree[rt].size);</span><br><span class="line">    tree[rt].same = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过孩子节点的数据来更新父节点的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lson = tree[rt].ch[<span class="number">0</span>], rson = tree[rt].ch[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点的大小</span></span><br><span class="line">    tree[rt].size = tree[lson].size + tree[rson].size + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新该节点及其子树所有值的和</span></span><br><span class="line">    tree[rt].sum = tree[lson].sum + tree[rson].sum + tree[rt].val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新子序列最大值</span></span><br><span class="line">    tree[rt].lx = max((<span class="keyword">long</span> <span class="keyword">long</span>)tree[lson].lx, tree[lson].sum + tree[rt].val + max(<span class="number">0</span>, tree[rson].lx));</span><br><span class="line">    tree[rt].rx = max((<span class="keyword">long</span> <span class="keyword">long</span>)tree[rson].rx, tree[rson].sum + tree[rt].val + max(<span class="number">0</span>, tree[lson].rx));</span><br><span class="line">    tree[rt].mx = max(<span class="number">0</span>, tree[lson].rx) + tree[rt].val + max(<span class="number">0</span>, tree[rson].lx);</span><br><span class="line">    tree[rt].mx = max(tree[rt].mx, max(tree[lson].mx, tree[rson].mx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将父节点的延迟标记更新到孩子节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新增量延迟标记</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].add)&#123;</span><br><span class="line">        updateAdd(tree[rt].ch[<span class="number">0</span>], tree[rt].add);</span><br><span class="line">        updateAdd(tree[rt].ch[<span class="number">1</span>], tree[rt].add);</span><br><span class="line">        tree[rt].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新区间相同标记</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].same)&#123;</span><br><span class="line">        updateSame(tree[rt].ch[<span class="number">0</span>], tree[rt].val);</span><br><span class="line">        updateSame(tree[rt].ch[<span class="number">1</span>], tree[rt].val);</span><br><span class="line">        tree[rt].same = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新反转标记</span></span><br><span class="line">    <span class="keyword">if</span>(tree[rt].rev)&#123;</span><br><span class="line">        updateRev(tree[rt].ch[<span class="number">0</span>]);</span><br><span class="line">        updateRev(tree[rt].ch[<span class="number">1</span>]);</span><br><span class="line">        tree[rt].rev = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> pre, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mPool.empty())&#123;</span><br><span class="line">        rt = mPool.top();</span><br><span class="line">        mPool.pop();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        rt = ++total;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[rt].pre = pre;</span><br><span class="line">    tree[rt].size = <span class="number">1</span>;</span><br><span class="line">    tree[rt].val = val;</span><br><span class="line">    tree[rt].add = <span class="number">0</span>;</span><br><span class="line">    tree[rt].sum = val;</span><br><span class="line">    tree[rt].rev = tree[rt].same = <span class="number">0</span>;</span><br><span class="line">    tree[rt].ch[<span class="number">0</span>] = tree[rt].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    tree[rt].lx = tree[rt].rx = tree[rt].mx = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pre, <span class="keyword">int</span> *a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    newNode(cur, pre, a[mid]);</span><br><span class="line">    buildTree(tree[cur].ch[<span class="number">0</span>], l, mid - <span class="number">1</span>, cur, a);</span><br><span class="line">    buildTree(tree[cur].ch[<span class="number">1</span>], mid + <span class="number">1</span>, r, cur, a);</span><br><span class="line">    pushUp(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> *data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    root = total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!mPool.empty()) mPool.pop();</span><br><span class="line">    tree[root].rev = tree[root].same = <span class="number">0</span>;</span><br><span class="line">    tree[root].ch[<span class="number">0</span>] = tree[root].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    tree[root].lx = tree[root].rx = tree[root].mx = -INF;</span><br><span class="line">    tree[root].sum = tree[root].add = tree[root].val = <span class="number">0</span>;</span><br><span class="line">    tree[root].pre = tree[root].size = tree[root].sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    newNode(root, <span class="number">0</span>, <span class="number">-1</span>);                           <span class="comment">// 注1</span></span><br><span class="line">    newNode(tree[root].ch[<span class="number">1</span>], root, <span class="number">-1</span>);            <span class="comment">// 注2</span></span><br><span class="line"></span><br><span class="line">    buildTree(key_value, <span class="number">0</span>, n - <span class="number">1</span>, tree[root].ch[<span class="number">1</span>], data);</span><br><span class="line"></span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现单旋</span></span><br><span class="line"><span class="comment">// com == 0 时， 对 cur 节点进行左旋</span></span><br><span class="line"><span class="comment">// com == 1 时， 对 cur 节点进行右旋</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> com)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = tree[cur].pre;</span><br><span class="line">    pushDown(pre);</span><br><span class="line">    pushDown(cur);</span><br><span class="line"></span><br><span class="line">    tree[pre].ch[!com] = tree[cur].ch[com];</span><br><span class="line">    tree[tree[cur].ch[com]].pre = pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上面的语句可以展开成下面的语句</span></span><br><span class="line"><span class="comment">    if(com)&#123;</span></span><br><span class="line"><span class="comment">        tree[pre].ch[0] = tree[cur].ch[1];    </span></span><br><span class="line"><span class="comment">        tree[tree[cur].ch[1]].pre = pre;</span></span><br><span class="line"><span class="comment">    &#125;else&#123;</span></span><br><span class="line"><span class="comment">        tree[pre].ch[1] = tree[cur].ch[0];   </span></span><br><span class="line"><span class="comment">        tree[tree[cur].ch[0]].pre = pre;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tree[pre].pre)&#123;</span><br><span class="line">        tree[tree[pre].pre].ch[tree[tree[pre].pre].ch[<span class="number">1</span>] == pre] = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tree[cur].pre = tree[pre].pre;</span><br><span class="line">    tree[cur].ch[com] = pre;</span><br><span class="line">    tree[pre].pre = cur;</span><br><span class="line">    pushUp(pre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现树的调整</span></span><br><span class="line"><span class="comment">// 将 rt 节点调整到 tar 下面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> tar)</span></span>&#123;</span><br><span class="line">    pushDown(rt);</span><br><span class="line">    <span class="keyword">while</span>(tree[rt].pre != tar)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[tree[rt].pre].pre == tar)&#123;</span><br><span class="line">            pushDown(tree[rt].pre);</span><br><span class="line">            pushDown(rt);</span><br><span class="line">            rotate(rt, tree[tree[rt].pre].ch[<span class="number">0</span>] == rt);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pushDown(tree[tree[rt].pre].pre);</span><br><span class="line">            pushDown(tree[rt].pre);</span><br><span class="line">            pushDown(rt);</span><br><span class="line">            <span class="keyword">int</span> pre = tree[rt].pre;</span><br><span class="line">            <span class="keyword">int</span> com = tree[tree[pre].pre].ch[<span class="number">0</span>] == pre;</span><br><span class="line">            <span class="keyword">if</span>(tree[pre].ch[com] == rt)&#123;</span><br><span class="line">                rotate(rt, !com);</span><br><span class="line">                rotate(rt, com);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rotate(pre, com);</span><br><span class="line">                rotate(rt, com);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pushUp(rt);</span><br><span class="line">    <span class="keyword">if</span>(tar == <span class="number">0</span>) root = rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    pushDown(rt);</span><br><span class="line">    <span class="keyword">int</span> tmp = tree[tree[rt].ch[<span class="number">0</span>]].size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tmp == k) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tmp &gt; k) <span class="keyword">return</span> getKth(tree[rt].ch[<span class="number">0</span>], k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> getKth(tree[rt].ch[<span class="number">1</span>], k - tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValMinPos</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Min = INF;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">        pushDown(rt);</span><br><span class="line">        <span class="keyword">if</span>(tree[rt].val == val) <span class="keyword">return</span> rt;</span><br><span class="line">        <span class="keyword">if</span>(tree[rt].val &gt; val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Min &gt; tree[rt].val)&#123;</span><br><span class="line">                Min = tree[rt].val;</span><br><span class="line">                pos = rt;</span><br><span class="line">            &#125;</span><br><span class="line">            rt = tree[rt].ch[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> rt = tree[rt].ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 val 的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValPos</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[rt].val == val) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tree[rt].val &gt; val)</span><br><span class="line">        <span class="keyword">return</span> getValPos(tree[rt].ch[<span class="number">0</span>], val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getValPos(tree[rt].ch[<span class="number">1</span>], val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValRank</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = getValPos(root, val);</span><br><span class="line">    splay(pos, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[root].ch[<span class="number">0</span>]) res += tree[tree[root].ch[<span class="number">0</span>]].size;</span><br><span class="line">    res += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    pushDown(rt);</span><br><span class="line">    <span class="keyword">while</span>(tree[rt].ch[<span class="number">0</span>])&#123;</span><br><span class="line">        rt = tree[rt].ch[<span class="number">0</span>];</span><br><span class="line">        pushDown(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    pushDown(rt);</span><br><span class="line">    <span class="keyword">while</span>(tree[rt].ch[<span class="number">1</span>])&#123;</span><br><span class="line">        rt = tree[rt].ch[<span class="number">1</span>];</span><br><span class="line">        pushDown(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第 x 个数后面插入 val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertOne</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, x + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, x + <span class="number">2</span>), root);</span><br><span class="line">    newNode(key_value, tree[root].ch[<span class="number">1</span>], val);</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt)&#123;</span><br><span class="line">        mPool.push(rt);</span><br><span class="line">        erase(tree[rt].ch[<span class="number">0</span>]);</span><br><span class="line">        erase(tree[rt].ch[<span class="number">1</span>]);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第 k 个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteOne</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, k), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, k + <span class="number">2</span>), root);</span><br><span class="line">    erase(key_value);</span><br><span class="line">    tree[key_value].pre = <span class="number">0</span>;</span><br><span class="line">    key_value = <span class="number">0</span>;</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第 pos 个数后开始插入 val 数组中的数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt, <span class="keyword">int</span> *val)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, pos + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, pos + <span class="number">2</span>), root);</span><br><span class="line">    buildTree(key_value, <span class="number">0</span>, cnt - <span class="number">1</span>, tree[root].ch[<span class="number">1</span>], val);</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 pos 个数开始连续删除 cnt 个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, pos), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, pos + cnt + <span class="number">1</span>), root);</span><br><span class="line">    erase(key_value);</span><br><span class="line">    tree[key_value].pre = <span class="number">0</span>;</span><br><span class="line">    key_value = <span class="number">0</span>;</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 [l, r] 的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, l), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    <span class="keyword">return</span> tree[key_value].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 [l, r] 区间循环右移 T 个单位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revolve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    T = (T % len + len) % len;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> c = r - T + <span class="number">1</span>;</span><br><span class="line">    splay(getKth(root, c), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    <span class="keyword">int</span> tmp = key_value;</span><br><span class="line">    key_value = <span class="number">0</span>;</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">    splay(getKth(root, l), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, l + <span class="number">1</span>), root);</span><br><span class="line">    key_value = tmp;</span><br><span class="line">    tree[key_value].pre = tree[root].ch[<span class="number">1</span>];</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, l), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    updateRev(key_value);</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSame</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, pos), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, pos + cnt + <span class="number">1</span>), root);</span><br><span class="line">    updateSame(key_value, val);</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 [l, r] 区间的所有值都增加 val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAdd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, l), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, r + <span class="number">2</span>), root);</span><br><span class="line">    updateAdd(key_value, val);</span><br><span class="line">    pushUp(tree[root].ch[<span class="number">1</span>]);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 pos 开始连续 cnt 长度的区间内子序列的最大和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxSum</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    splay(getKth(root, pos), <span class="number">0</span>);</span><br><span class="line">    splay(getKth(root, pos + cnt + <span class="number">1</span>), root);</span><br><span class="line">    <span class="keyword">return</span> tree[key_value].mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        init(data);</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'I'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y; i++)</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data[i]);</span><br><span class="line">                insert(x, y, data);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'D'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">                Delete(x, y);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; op[<span class="number">2</span>] == <span class="string">'K'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">                makeSame(x, y, z);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'R'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">                reverse(x, x + y - <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'G'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getSum(x, x + y - <span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getMaxSum(<span class="number">1</span>, tree[root].size - <span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;树的遍历&lt;/li&gt;
&lt;li&gt;二叉树的基本知识&lt;/li&gt;
&lt;li&gt;排序二叉树的基本知识&lt;/li&gt;
&lt;li&gt;线段树区间更新和区间查询知识&lt;/li&gt;
&lt;li&gt;平衡排序二叉树的基本知识(非必须)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;伸展树(SplayTree) 是一种经过改进的平衡排序二叉树, 他跟平衡二叉树的操作非常类似，同时也有很多不同。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://blog.andrewei.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="伸展树" scheme="https://blog.andrewei.me/tags/%E4%BC%B8%E5%B1%95%E6%A0%91/"/>
    
      <category term="树" scheme="https://blog.andrewei.me/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="https://blog.andrewei.me/2016/07/05/binary-indexed-trees/"/>
    <id>https://blog.andrewei.me/2016/07/05/binary-indexed-trees/</id>
    <published>2016-07-05T08:23:22.000Z</published>
    <updated>2018-04-09T01:16:07.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>早就听说过这个数据结构，但是他所做的事情线段树都可以做。年少无知的我以为知道了线段树就可以不去理会这个数据结构，然而每次做题，都要敲长长的线段树，心里苦啊。 不就是一个树状数组么，去看！</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>树状数组可以做什么，树状数组可以维护一个序列的前缀和，并且在 $log(n)$ 的时间复杂度内进行更新和查询区间和。<br>它主要有两种操作：</p><ul><li>1&gt; add(i, val); 将第 i 个元素加上 val, 复杂度为 $log(n)$</li><li>2&gt; sum(i); 统计 $[1, n]$ 的和</li></ul><p>对，这些事情线段树都可以做到，那么树状数组的优势在哪，接着往下看。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="结构与节点含义"><a href="#结构与节点含义" class="headerlink" title="结构与节点含义"></a>结构与节点含义</h3><p>树状数组的结构是由线段树的结构简化而来，也就是说他的结构是线段树的结构的一部分，如图所示<img src="/images/binary-indexed-trees/bit1.png" alt="树状数组的结构">其中，A为普通数组，C为树状数组。<br>下面我们来看一下树状数组每个节点的含义:</p><table><thead><tr><th>节点</th><th>下标二进制</th><th>含义</th></tr></thead><tbody><tr><td>C1</td><td>0001</td><td>C1 = A1</td></tr><tr><td>C2</td><td>0010</td><td>C2 = C1 + A2 = A1 + A2</td></tr><tr><td>C3</td><td>0011</td><td>C3 = A3</td></tr><tr><td>C4</td><td>0100</td><td>C4 = C2 + C3 + A4 = A1 + … + A4</td></tr><tr><td>C5</td><td>0101</td><td>C5 = A5</td></tr><tr><td>C6</td><td>0110</td><td>C6 = C5 + A6 = A5 + A6</td></tr><tr><td>C7</td><td>0111</td><td>C7 = A7</td></tr><tr><td>C8</td><td>1000</td><td>C8 = C4 + C6 + C7 + A8 = A1 + … + A8</td></tr></tbody></table><p>通过观察表格我们发现，树状数组里面的每一个节点其实代表的都是一个区间的和，设有一个下标为 $i$ 的节点 $C_i$, 并且假定 $i$ 的二进制表示中末尾有 $k$ 个 $0$, 则, $C_i$ 代表的是从第 $i$ 个数向前数 $2^k$ 个数的和，即 $C_i$为: </p><p>$$\sum_{j=i-2^k+1}^{i}A_j$$</p><h3 id="求和操作"><a href="#求和操作" class="headerlink" title="求和操作"></a>求和操作</h3><p>在我们明白了树状数组中每个节点的含义之后，我们来构造求区间$[1, i], 1 &lt;= i &lt;= n$ 的和(记为<code>sum(i)</code>)的方法，首先我们先假定 <code>int lowbit(int i);</code> 函数用来表示 $2^k$(其中 $k$ 为 $i$ 的二进制中末尾 $0$ 的个数)，他的实现方式我们稍后再讲。 那么:</p><p>$$ sum(i) = sum(i - lowbit(i)) + C_i$$</p><p>该式可递归求解也可迭代求解，结束的条件是 $ i &lt;= 0 $</p><blockquote><p>下面以求区间 $[1,7]$ 的和(即 sum(6)的值)为例介绍求和操作的步骤:</p><ul><li><code>lowbit(7) = 1</code> 即 $C_7=A_7$, 故 $sum(7)=sum(7-1)+C_7$;</li><li><code>lowbit(6) = 2</code> 即 $C_6=A_6+A_5$, 故 $sum(6)=sum(6-2)+C_6$;</li><li><code>lowbit(4) = 4</code> 即 $C_4=A_1+A_2+A_3+A_4$, 故 $sum(4)=sum(4-4)+C_4$;<br>由于 $4-4==0$, 故算法停止，最后得知 $sum(7)=C_7+C_6+C_4$;</li></ul></blockquote><p>现在我们已经学会了求区间 $[1,n]$ 的和，对于任意的区间 $[l,r]$的和, 只需要求 $sum(r)-sum(l-1)$ 即可。</p><p>求和操作的参考代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代求解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= lowbit(i))&#123;</span><br><span class="line">        sum += C[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归求解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? C[x] + getSum(x - lowbit(x)) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>介绍完了求和操作，下面介绍更新操作。上文中已经提到，树状数组中的每一个节点维护的都是一个区间和，那么当一个节点的值发生变化的时候也就意味着会有一系列与之相关的节点的值也要发生变化，这一点从树状数组的结构图中也可以看出。</p><blockquote><p>比如 $C_1$ 节点发生变化，那么 $C_1, C_2, C_4, C_8, …$ 都要跟着变化，如何维护好这个变化是我们需要关注的事情。</p></blockquote><p>由结构图我们知道，当一个节点变化时影响到的是本节点和该节点的直接和间接父节点，而对于一个节点 $i$, 它的父节点的下标为 <code>i + lowbit(i)</code>, 所以更新操作跟求和操作非常相似，只需要不断的寻找父节点然后更新它即可。</p><p>更新操作参考代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代求解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line">        C[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归求解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= n)&#123;</span><br><span class="line">        C[x] += val;</span><br><span class="line">        update(x + lowbit(x), val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="lowbit-函数的实现"><a href="#lowbit-函数的实现" class="headerlink" title="lowbit 函数的实现"></a>lowbit 函数的实现</h3><p>上文中我们一直在用 <code>lowbit(x)</code> 这个函数来求 $2^k$(其中 k 为 x 二进制表示中末尾0的个数), 那么这个函数怎么实现最方便快捷呢？<br>当然，完全可以用循环的方式从 <code>x</code> 的最后一位遍历，但是还有更好的方法，那就是 <code>x &amp; (-x)</code>。<br>下面解释一下这个表达式为什么可以求出我们所需要的东西, 这里假定 <code>x</code> 为 <code>n</code> 位有符号整数且非负, 则：<br><img src="/images/binary-indexed-trees/bit2.png" alt="lowbit原理"></p><p>当然 <code>lowbit</code> 函数还可以用 <code>((i-1)^i)&amp;i</code> 来实现，都是利用了二进制的性质，这里不再解释。</p><p>lowbit函数参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现方式1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现方式2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x - <span class="number">1</span>) ^ i) &amp; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>讲到这里大家肯定已经感觉出树状数组的优势来了，代码简单的已经跟 <code>a + b</code> 差不多了，那么除了刚刚所描述的基本用法之外，哪些地方还可以巧妙地利用树状数组呢?</p><h3 id="应用一-单点更新，区间查询"><a href="#应用一-单点更新，区间查询" class="headerlink" title="应用一 单点更新，区间查询"></a>应用一 单点更新，区间查询</h3><p><strong> 问题： </strong><br>一个长度为 $n(1 &lt;= n &lt;= 500000)$ 的元素序列，一开始都为 0，现给出三种操作:</p><ul><li><strong> add x v </strong>, 给第 x 个元素的值加上 v;</li><li><strong> sub x v </strong>, 给第 x 个元素的值减去 v;</li><li><strong> sum x y </strong>, 求出第 x 个元素到第 y 个元素的和;</li></ul><p><strong> 解答: </strong><br>这是最基本的树状数组的用法，前两种操作都可以直接使用 <code>update(x, v);</code>来实现，第三种操作就用 <code>getSum(y) - getSum(x - 1)</code>来实现</p><h3 id="应用二-区间更新，单点查询"><a href="#应用二-区间更新，单点查询" class="headerlink" title="应用二 区间更新，单点查询"></a>应用二 区间更新，单点查询</h3><p><strong> 问题： </strong><br>一个长度为 $n(1 &lt;= n &lt;= 500000)$ 的元素序列，一个开始都为 0, 现给出两种操作:</p><ul><li><strong> add x y v </strong>, 给第 x 个元素到第 y 个元素的值都加上 v;</li><li><strong> get x </strong>, 查询第 x 个元素的值;</li></ul><p><strong> 解答: </strong><br>这个问题可以转换到单点更新，区间查询上去，转换方法如下:<br>第一种操作，我们用两步 <code>update</code> 来实现, 分别为 <code>update(x, v)</code> 和 <code>update(y + 1, -v)</code>;<br>第二种操作, 查询第 <code>x</code> 个元素的值时，直接调用 <code>getSum(x)</code> 即可。</p><blockquote><p>注意: 此时 <code>getSum(x)</code> 得到的其实是 <code>x</code> 元素的 <strong>增量</strong>。</p></blockquote><p><strong> 拓展: </strong><br>如果原始数据不为 0, 则 <code>get x</code> 时应当写为 <code>getSum(x) + data[x]</code>, 其中 <code>data[x]</code> 为第 <code>x</code> 个元素的初始值。</p><h3 id="应用三-区间更新，区间查询"><a href="#应用三-区间更新，区间查询" class="headerlink" title="应用三 区间更新，区间查询"></a>应用三 区间更新，区间查询</h3><p><strong> 问题： </strong><br>一个长度为 $n(1 &lt;= n &lt;= 500000)$ 的元素序列，现给出两种操作:</p><ul><li><strong> add x y v </strong>, 给第 x 个元素到第 y 个元素的值都加上 v;</li><li><strong> sum x y </strong>, 求出第 x 个元素到第 y 个元素的和;</li></ul><p><strong> 解答: </strong><br>首先说明树状数组是可以解决这个问题的，但是感觉这种问题已经违背了树状数组的本意，所以建议这种问题用线段树来做。<br>下面介绍树状数组的做法:<br>设 $s(i) = $加上 $v$ 之前的 $\sum_{j=1}^{i}a_j$</p><p>设 $s’(i) = $加上 $v$ 之后的 $\sum_{j=1}^{i}a’_j$<br>那么:</p><p>$i &lt; x : s’(i) = s(i)$</p><p>$x &lt;= i &lt;= y : s’(i) = s(i) + v * (i - x + 1)$ </p><p>$y &lt; i : s’(i) = s(i) + v * (y - x + 1)$</p><p>我们构建两个树状数组 <code>bit0</code>, <code>bit1</code>，并且满足：<br>$$\sum_{j=1}^{i}a_j = sum(bit1, i) * i + sum(bit0, i)$$<br>于是，在区间 $[l,r]$ 上同时加上 $x$ 就可以看作是:</p><blockquote><p>在 <code>bit0</code> 上的 <code>l</code> 位置上加上 <code>-x(l-1)</code><br>在 <code>bit1</code> 上的 <code>l</code> 位置上加上 <code>x</code><br>在 <code>bit0</code> 上的 <code>r+1</code> 位置上加上 <code>x*r</code><br>在 <code>bit1</code> 上的 <code>r+1</code> 位置上加上 <code>-x</code></p></blockquote><p>这四个操作都可以在 $log(n)$ 内完成。<br>下面实现一下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];                <span class="comment">// 原始数据</span></span><br><span class="line"><span class="keyword">int</span> bit0[MAXN], bit1[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> *bit, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= lowbit(i))&#123;</span><br><span class="line">        sum += bit[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> *bit, <span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line">        bit[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        update(bit0, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新操作 [x, y] 区间内加上 val;</span></span><br><span class="line">    update(bit0, x, -val * (x - <span class="number">1</span>));</span><br><span class="line">    update(bit1, x, val);</span><br><span class="line">    update(bit0, y + <span class="number">1</span>, val * y);</span><br><span class="line">    update(bit1, y + <span class="number">1</span>, -val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求和操作 求 [x, y] 区间和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum += getSum(bit0, y) + getSum(bit1, y) * y;</span><br><span class="line">    sum -= getSum(bit0, x - <span class="number">1</span>) + getSum(bit1, x - <span class="number">1</span>) * (x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="应用四-求逆序对数"><a href="#应用四-求逆序对数" class="headerlink" title="应用四 求逆序对数"></a>应用四 求逆序对数</h3><p><strong> 问题1： </strong><br>一个长度为 $n(1 &lt;= n &lt;= 500000)$ 的元素序列，给定每个数的值, 求它的逆序对数</p><p><strong> 解答: </strong><br>求逆序对可以用 <code>归并排序</code> 来解，复杂度为 $nlog(n)$, 如果用树状数组的话, 怎么做呢?<br>我们用一个例子来介绍求解的步骤，比如我们要求 4, 2, 1, 3, 6, 5 这个序列的逆序对。</p><blockquote><p>首先，我们要声明一个数组，初始化为 0, 大小为我们要求的那个序列的最大值(如果最大值太大的话，建议离散化), 并将答案记录在 ans 中;</p><ol><li>将 4 插入到序列中，执行 <code>update(4, 1)</code>, <code>cnt += (1 - getSum(4))</code>;</li><li>将 2 插入到序列中，执行 <code>update(2, 1)</code>, <code>cnt += (2 - getSum(2))</code>;</li><li>将 1 插入到序列中，执行 <code>update(1, 1)</code>, <code>cnt += (3 - getSum(1))</code>;</li><li>将 3 插入到序列中，执行 <code>update(3, 1)</code>, <code>cnt += (4 - getSum(3))</code>;</li><li>将 6 插入到序列中，执行 <code>update(6, 1)</code>, <code>cnt += (5 - getSum(6))</code>;</li><li>将 5 插入到序列中，执行 <code>update(5, 1)</code>, <code>cnt += (6 - getSum(5))</code>;<br>当这些操作做完后，<code>cnt</code> 就是我们要求的值.</li></ol></blockquote><p><strong> 问题2： </strong><br>给定$N(N &lt;= 100000)$个区间，定义两个区间$(S_i, E_i)$和$(S_j, E_j)$的<code>&gt;</code>如下：如果 $S_i &lt;= S_j and E_j &lt;= E_i and E_i - S_i &gt; E_j - S_j$,则 $(S_i, E_i) &gt; (S_j, E_j)$，现在要求每个区间有多少区间<code>&gt;</code>它。<br>简化这个问题的话就是求, 有多少个区间 $i$ 完全覆盖 $j$, 并且这两个区间不能相等(如下图所示)。<br><img src="/images/binary-indexed-trees/bit3.png" alt="应用四题目"><br><strong> 解答: </strong> </p><ol><li>对区间进行排序，排序规则为：左端点递增，如果左端点相同，则右端点递减。</li><li>枚举区间，不断插入区间右端点，因为区间左端点是保持递增的，所以对于某个区间$(S_i, E_i)$，只需要查询树状数组中$[Ei, MAX]$这一段有多少已经插入的数据，就能知道有多少个区间是比它大的，这里需要注意的是多个区间相等的情况，因为有排序，所以它们在排序后的数组中一定是相邻的，所以在遇到有相等区间的情况，需要”延迟”插入。等下一个不相等区间出现时才把之前保存下来的区间右端点进行插入。插入完毕再进行统计。<br>备注: 这里的插入即$(E_j, 1)$，统计则是$getSum(n) - getSum(E_i - 1)$ (其中 $j &lt; i$ )。</li></ol><h4 id="关于逆序对的种种讨论"><a href="#关于逆序对的种种讨论" class="headerlink" title="关于逆序对的种种讨论"></a>关于逆序对的种种讨论</h4><p>既然提到了逆序对，那么我们现在来讨论一下当一个序列发生改变时其逆序对的变化<br><strong> 问题1: </strong><br>现在考虑这样一个问题：在序列 $a[]$ 中，交换 $a[i]$ 与 $a<a href="i &lt; j">j</a>$，则序列的逆序对数奇偶性有何变化？<br><strong> 解答: </strong><br>为了简化问题，我们首先考虑 $i, j$ 相邻的情况:<br>我们可以肯定的是如果 $i, j$ 相邻， 那么 $a[i], a[j]$ 的交换不会引起 $a[k], k &lt; i$ 和 $a[k], k &gt; j$ 的逆序对, 那么: 当 $a[i] &gt; a[j]$时，$a[i], a[j]$ 的交换会导致整体的逆序对数 $-1$, 反之会导致整体的逆序对数 $+1$, 也就是说 <strong> $a[i], a[j]$ 的交换会导致整体逆序对数的变化，即相邻两个数的交换会导致整体逆序对数的变化 </strong>(在这里我们不考虑 $a[i] == a[j]$)。<br>假设 $a[i]$ 与 $a[j]$ 之间有 $m(m &gt;= 1)$ 个数:<br>这种情况下，我们可以考虑 $a[i], a[j]$ 的交换是下面三种情况的叠加,</p><ol><li>$a[i]$ 依次与其后面的 $m$ 个数交换直到 $a[j]$, 共进行 $m$ 次交换;</li><li>$a[i], a[j]$ 进行交换，共$1$次;</li><li>$a[j]$ 依次与其前面的 $m$ 个数交换直到 $a[i]$ 之前的位置，共进行 $m$ 次交换;</li></ol><p>如此可知，共进行了 $2 \ast m + 1$ 次交换, 综合两种情况可知 <strong>任何两个数的交换会导致整体逆序对数的变化</strong>(不考虑 $a[i] == a[j]$ 的情况).</p><p><strong> 问题2: </strong><br>在问题1的基础上我们接着考虑，$a[i], a[j]$交换后对整体逆序对数量的影响。<br><strong> 解答: </strong><br>可以很容易的想到想要解决这个问题，必须要知道在区间 $[l, r]$ 中比 $a[i]$ 小的数的个数 <code>num_less_i</code>, 比 $a[i]$ 大的数的个数 <code>num_larger_i</code>, 比 $a[j]$ 小的数的个数 <code>num_less_j</code>, 比 $a[j]$ 大的数的个数 <code>num_larger_j</code>, 则逆序对的变化为:<br><code>change_num = -num_less_i + num_larger_i + num_less_j - num_larger_j</code><br>现在的问题是如何快速的求出这些值。<br>令 <code>cnt[i][j]</code> 表示到位置 <code>i</code> 为止(包括<code>i</code>), 比 <code>j</code> 小的数的个数，并且假定对任意的 $a[i], a[i] &lt;= m$, 那么<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_less_i = cnt[j][a[i]] - cnt[i][a[i]];</span><br><span class="line">num_larger_i = j - i - num_less_i;</span><br><span class="line">num_less_j = cnt[j][a[j]] - cnt[i][a[j]];</span><br><span class="line">num_larger_j = j - i  - <span class="number">1</span> - num_less_j;</span><br><span class="line"><span class="comment">//第四行的减一是减去a[j]本身也算一个数</span></span><br></pre></td></tr></table></figure></p><p>至于 <code>cnt</code> 数组可以预处理出来:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递推求cnt数组, 复杂度比较大</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=m; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; j)cnt[i][j] = cnt[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> cnt[i][j] = cnt[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题解决.</p><p><strong> 问题3: </strong><br>现在已知这样一个序列 <code>b</code>, $b[i], (1 &lt;= i &lt;= n)$ 表示 $i$ 在另外一个序列中的逆序对数，试问能否构造出这样的一个$1 - n $的排列，满足<code>b</code>序列？<br><strong> 解答: </strong><br>这个问题刚好和求逆序对数反了过来。举个例子，<code>b</code> 序列 <code>1 ,2 , 0, 1, 0</code>.如何构造呢？<br>不妨试一试.<code>1</code>的逆序对数是<code>1</code>，也就是说，<code>1</code>在新序列中他的前面只能有<code>1</code>个比他大的数，但是<code>1</code>已经是最小数了，所以<code>1</code>必定处在第<code>2</code>的位置.构造序列： <code>_ 1 _ _</code> <code>2</code>的逆序对数是<code>2</code>，依照前面的分析方法，<code>2</code>必定处在第<code>4</code>的位置，即 <code>_ 1 _ 2</code> 。换句话说，<code>2要找到第</code>3<code>个空位.再换个角度，对于位置序列</code>（1,2,3,4,5）<code>，数字</code>1<code>已经占据了第</code>2<code>的位置，所以将序列中的</code>2<code>删除-&gt;</code>(1,3,4,5)<code>，那么我们要寻找的</code>2<code>的插入位置不就是第</code>3<code>小的元素，也就是第</code>b[i]<code>小元素么.求第</code>K`小元素上面已经分析过了，树状数组可以搞定.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ans为构造的序列</span></span><br><span class="line"><span class="comment">//c[]为位置序列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = find_kth_element(k);</span><br><span class="line">    ans[pos] = c[i];</span><br><span class="line">    update(pos, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> 问题4: </strong><br>仍是上一题中的序列<code>b</code>，<code>b[i]</code>表示原序列中位置 <code>i</code> 处的逆序对数，问你能否构造出原序列？(原序列为<code>1-n</code>的一个排列)<br><strong> 解答: </strong><br>此题和上一题的不同.但是可以采用和上一题的相同的思路去解决.比如<code>b</code>序列 <code>0, 1, 2, 0, 1</code></p><p>因为一个序列的第一个数的逆序对数总是为<code>0</code>，所以从前往后的分析不太靠谱.那么我们试一试从后向前分析.最后一个数的逆序对数为<code>1</code>，说明他前面只能有一个数比他大，显然最后一个数只能是<code>4</code>.即序列变成 <code>_ _ _ _ 4</code>. 倒数第二个数的逆序对数为<code>0</code>，则同样可确定该数只能是<code>5</code>.序列变成 <code>_ _ _5 4</code>. 倒数第三个数的逆序对数为<code>2</code>，可确定该数为<code>1</code>.有什么规律呢？用<code>cnt</code>表示还剩下的数，每次要填的数，是不是第<code>cnt - b[i]</code>小的数呢？倒数第一个数的逆序对数为<code>1</code>，要填的是第 <code>5 - 1</code>小的数，也就是<code>4</code>. 然后倒数第二个数的逆序对数为<code>0</code>，要填第 <code>4-0</code>小的数，在剩余的数里面就是<code>5</code>.以此类推.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法伪代码</span></span><br><span class="line"><span class="comment">//ans为构造的序列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">int</span> num = find_kth_element(i - b[i]);</span><br><span class="line">    ans[i] = num;</span><br><span class="line">    update(num, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="应用五-求第k大数"><a href="#应用五-求第k大数" class="headerlink" title="应用五 求第k大数"></a>应用五 求第k大数</h3><p><strong> 问题：</strong><br>给定一个空的栈，现对他进行如下操作:</p><ol><li><strong> push x </strong>, 将 x(0 &lt;= x &lt;= 1000) 放于栈顶;</li><li><strong> pop </strong>, 将栈顶元素弹出;</li><li><strong> query k </strong>, 查询栈中第 k 大元素;</li></ol><p><strong> 解答: </strong><br>开一个大小为 <code>1000</code> 的数组并初始化为 0, </p><ol><li>当进行 <code>push x</code> 操作的时候调用 <code>update(x, 1)</code>;</li><li>当进行 <code>pop</code> 操作的时候调用 <code>update(x, -1)</code>;</li><li>对于 <code>query k</code> 操作，实际上就是找到一个右端点 <code>r</code>, 使得 $[1, r]$ 的和为 <code>k</code>, 故我们可以用二分与树状数组相结合来查找 <code>r</code>;</li></ol><p>具体实现:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; MAXN; i += lowbit(i))&#123;</span><br><span class="line">        a[i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= lowbit(i))&#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindMid</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = MAXN;</span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(getSum(mid) &lt; k) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(!sta.empty()) sta.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push x 操作</span></span><br><span class="line">    sta.push(x);</span><br><span class="line">    update(x, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pop 操作</span></span><br><span class="line">    top = sta.top();</span><br><span class="line">    update(top, <span class="number">-1</span>);</span><br><span class="line">    sta.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// query k 操作</span></span><br><span class="line">    ans = Find(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="应用六-二维树状数组"><a href="#应用六-二维树状数组" class="headerlink" title="应用六 二维树状数组"></a>应用六 二维树状数组</h3><p><strong> 问题: </strong><br>给定一个矩阵 $mp(n * m, (1 &lt;= n, m &lt;= 1000))$, 初始情况元素均为 $0$, 有两种操作:</p><ol><li><strong> add x y v </strong>, 表示 $ mp[x][y] += v $;</li><li><strong> query x1 y1 x2 y2 </strong>, 表示询问由 x1, y1, x2, y2 围成的矩形中所有数的和;</li></ol><p><strong> 解答: </strong><br>可以把普通的一维树状数组改写为二维的树状数组:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = y; j &lt;= m; j += lowbit(j))&#123;</span><br><span class="line">            c[i][j] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= lowbit(i))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = y; j; j -= lowbit(j))&#123;</span><br><span class="line">            sum += c[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仔细观察即可发现，二维树状数组的实现和一维的实现极其相似，二维仅仅比一维多了一个循环，并且数据用二维数组实现。那么同样地，对于三维的情况，也只是在数组的维度上再增加一维，更新和求和时都各加一个循环而已。</p><p>此时，如果需要求 $(x1, y1), (x2, y2)$ 这两个点所框定的矩阵中的和则会有以下公式:<br>$$ sum = getSum(x2, y2) - getSum(x1 - 1, y2) - getSum(x2, y1 - 1) + getSum(x1 - 1, y1 - 1)$$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>罗嗦了这么多，我们来总结一下树状数组的优势:</p><ol><li>编码复杂度极低，跟它的功能比起来性价比超高;</li><li>运用非常灵活，功能强大;</li><li>一维树状数组的各种操作的复杂度均为 $O(log(n))$;</li><li>只需要线性的空间，空间复杂度为 $O(n)$;</li><li>可以拓展成为 $n$ 维的情况.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;早就听说过这个数据结构，但是他所做的事情线段树都可以做。年少无知的我以为知道了线段树就可以不去理会这个数据结构，然而每次做题，都要敲长长的线段树，心里苦啊。 不就是一个树状数组么，去看！&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://blog.andrewei.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://blog.andrewei.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树状数组" scheme="https://blog.andrewei.me/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数与多态性</title>
    <link href="https://blog.andrewei.me/2016/06/07/cplusplus-virtual-function/"/>
    <id>https://blog.andrewei.me/2016/06/07/cplusplus-virtual-function/</id>
    <published>2016-06-07T04:06:56.000Z</published>
    <updated>2018-04-09T01:16:07.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本文转自 <a href="http://www.cppblog.com/dawnbreak/archive/2009/03/10/76084.aspx" target="_blank" rel="noopener">http://www.cppblog.com/dawnbreak/archive/2009/03/10/76084.aspx</a> 感谢作者<br>总觉得C++很神奇，在继承和多态性方面比JAVA要灵活的许多，今天看到了上面这个介绍虚函数的文章觉得写的很好，分享到这里。</p><hr><a id="more"></a><h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1><p>对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。 在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了 这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。<br>这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。<br>下面我们通过一个例子来说明一下:<br>假设我们有这样的一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面我们通过 Base 的实例来获取虚函数表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>; Base b;</span><br><span class="line">Fun pFun = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表地址："</span> &lt;&lt; (<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"虚函数表 — 第一个函数地址："</span> &lt;&lt; (<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b));</span><br><span class="line"></span><br><span class="line">pFun();</span><br></pre></td></tr></table></figure></p><p>本程序的测试环境为: Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3<br>实际运行结果如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚函数表地址：0012FED4</span><br><span class="line">虚函数表 — 第一个函数地址：0044F148</span><br><span class="line">Base::f</span><br></pre></td></tr></table></figure></p><p>通过这个示例，我们可以看到，我们可以通过强行把<code>&amp;b</code>转成<code>int *</code>，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是<code>Base::f()</code>，这在上面的程序中得到了验证（把<code>int*</code>强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用<code>Base::g()</code>和<code>Base::h()</code>，其代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">0</span>); <span class="comment">// Base::f()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">1</span>); <span class="comment">// Base::g()</span></span><br><span class="line">(Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;b)+<span class="number">2</span>); <span class="comment">// Base::h()</span></span><br></pre></td></tr></table></figure></p><p>下面通过图片来说明虚函数表在内容中的分布情况<br><img src="/images/cpluscplus_virtual_function/o_vtable1.jpg" alt="虚函数分布"><br><strong> 注意：</strong>在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符<code>&#39;\0&#39;</code>一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在<code>WinXP+VS2003</code>下，这个值是<code>NULL</code>。而在<code>Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3</code>下，这个值是如果<code>1</code>，表示还有下一个虚函数表，如果值是<code>0</code>，表示是最后一个虚函数表。<br>下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。</p><h1 id="一般继承（无虚函数覆盖）"><a href="#一般继承（无虚函数覆盖）" class="headerlink" title="一般继承（无虚函数覆盖）"></a>一般继承（无虚函数覆盖）</h1><p>下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：<br><img src="/images/cpluscplus_virtual_function/o_vtable2.jpg" alt="虚函数分布"><br>请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：<br>对于实例：Derive d; 的虚函数表如下：<br><img src="/images/cpluscplus_virtual_function/o_vtable3.jpg" alt="虚函数分布"><br>我们可以看到下面几点：</p><blockquote><p>1）虚函数按照其声明顺序放于表中。<br>2）父类的虚函数在子类的虚函数前面。<br>我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。</p></blockquote><h1 id="一般继承（有虚函数覆盖）"><a href="#一般继承（有虚函数覆盖）" class="headerlink" title="一般继承（有虚函数覆盖）"></a>一般继承（有虚函数覆盖）</h1><p>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。<br><img src="/images/cpluscplus_virtual_function/o_vtable4.jpg" alt="虚函数分布"><br>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：<code>f()</code>.那么，对于派生类的实例，其虚函数表会是下面的一个样子：<br><img src="/images/cpluscplus_virtual_function/o_vtable5.jpg" alt="虚函数分布"><br>我们从表中可以看到下面几点:</p><blockquote><p>1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。<br>2）没有被覆盖的函数依旧。<br>这样，我们就可以看到对于下面这样的程序，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> Derive();</span><br><span class="line">b-&gt;f();</span><br></pre></td></tr></table></figure></p></blockquote><p>由<code>b</code>所指的内存中的虚函数表的<code>f()</code>的位置已经被<code>Derive::f()</code>函数地址所取代，于是在实际调用发生时，是<code>Derive::f()</code>被调用了。这就实现了多态。</p><h1 id="多重继承（无虚函数覆盖）"><a href="#多重继承（无虚函数覆盖）" class="headerlink" title="多重继承（无虚函数覆盖）"></a>多重继承（无虚函数覆盖）</h1><p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。<br><img src="/images/cpluscplus_virtual_function/o_vtable6.jpg" alt="虚函数分布"><br>对于子类实例中的虚函数表，是下面这个样子：<br><img src="/images/cpluscplus_virtual_function/o_vtable7.jpg" alt="虚函数分布"><br>我们可以看到：</p><blockquote><p>1）每个父类都有自己的虚表。<br>2）子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）<br>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p></blockquote><h1 id="多重继承（有虚函数覆盖）"><a href="#多重继承（有虚函数覆盖）" class="headerlink" title="多重继承（有虚函数覆盖）"></a>多重继承（有虚函数覆盖）</h1><p>下面我们再来看看，如果发生虚函数覆盖的情况。<br>下图中，我们在子类中覆盖了父类的<code>f()</code>函数。<br><img src="/images/cpluscplus_virtual_function/o_vtable8.jpg" alt="虚函数分布"><br>下面是对于子类实例中的虚函数表的图：<br><img src="/images/cpluscplus_virtual_function/o_vtable9.jpg" alt="虚函数分布"><br>我们可以看见，三个父类虚函数表中的<code>f()</code>的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的<code>f()</code>了。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Derive d;</span><br><span class="line">Base1 *b1 = &amp;d;</span><br><span class="line">Base2 *b2 = &amp;d;</span><br><span class="line">Base3 *b3 = &amp;d;</span><br><span class="line">b1-&gt;f(); <span class="comment">//Derive::f()</span></span><br><span class="line">b2-&gt;f(); <span class="comment">//Derive::f()</span></span><br><span class="line">b3-&gt;f(); <span class="comment">//Derive::f()</span></span><br><span class="line">b1-&gt;g(); <span class="comment">//Base1::g()</span></span><br><span class="line">b2-&gt;g(); <span class="comment">//Base2::g()</span></span><br><span class="line">b3-&gt;g(); <span class="comment">//Base3::g()</span></span><br></pre></td></tr></table></figure><h1 id="基类的析构函数为什么通常写为虚函数"><a href="#基类的析构函数为什么通常写为虚函数" class="headerlink" title="基类的析构函数为什么通常写为虚函数"></a>基类的析构函数为什么通常写为虚函数</h1><p>我们通过一个例子来说明这个问题，假设有如下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"class Base: func(), do something!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Base()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Base()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"class Base: ~Base(), do something!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"class Derived: func(), do something!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Derived()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~Derived()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"class Derived: ~Derived(), do something!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Base *b = <span class="keyword">new</span> Derived();</span><br><span class="line">    b -&gt; func();</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Derived: func(), do something!</span><br><span class="line">class Derived: ~Derived(), do something!</span><br><span class="line">class Base: ~Base(), do something!</span><br></pre></td></tr></table></figure><p>如果此时将 class Base 析构函数的 virtual 去掉， 则输出的结果为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Derived: func(), do something!</span><br><span class="line">class Base: ~Base(), do something!</span><br></pre></td></tr></table></figure><p>即此时并没有调用 Derived 的析构函数, 然而我们在 main 函数中确确实实 new 了一个 Derived 对象，也就是说这个时候发生了内存泄漏。</p><h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。</p><h2 id="通过父类型的指针访问子类自己的虚函数"><a href="#通过父类型的指针访问子类自己的虚函数" class="headerlink" title="通过父类型的指针访问子类自己的虚函数"></a>通过父类型的指针访问子类自己的虚函数</h2><p>我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base1 *b1 = <span class="keyword">new</span> Derive();</span><br><span class="line">b1-&gt;g1(); <span class="comment">//编译出错</span></span><br></pre></td></tr></table></figure><p>任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。</p><h2 id="访问non-public的虚函数"><a href="#访问non-public的虚函数" class="headerlink" title="访问non-public的虚函数"></a>访问non-public的虚函数</h2><p>另外，如果父类的虚函数是<code>private</code>或是<code>protected</code>的，但这些非<code>public</code>的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些<code>non-public</code>的虚函数，这是很容易做到的。<br>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive d;</span><br><span class="line">    Fun pFun = (Fun)*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)(&amp;d)+<span class="number">0</span>);</span><br><span class="line">    pFun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;本文转自 &lt;a href=&quot;http://www.cppblog.com/dawnbreak/archive/2009/03/10/76084.aspx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cppblog.com/dawnbreak/archive/2009/03/10/76084.aspx&lt;/a&gt; 感谢作者&lt;br&gt;总觉得C++很神奇，在继承和多态性方面比JAVA要灵活的许多，今天看到了上面这个介绍虚函数的文章觉得写的很好，分享到这里。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.andrewei.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++" scheme="https://blog.andrewei.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
      <category term="C++" scheme="https://blog.andrewei.me/tags/C/"/>
    
      <category term="虚函数" scheme="https://blog.andrewei.me/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="多态性" scheme="https://blog.andrewei.me/tags/%E5%A4%9A%E6%80%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>解决ubuntu下sublime中无法输入中文的问题</title>
    <link href="https://blog.andrewei.me/2016/05/05/sublime-input-Chinese/"/>
    <id>https://blog.andrewei.me/2016/05/05/sublime-input-Chinese/</id>
    <published>2016-05-05T12:11:39.000Z</published>
    <updated>2018-04-09T01:16:07.269Z</updated>
    
    <content type="html"><![CDATA[<p>sublime是一款非常好用的代码编辑器, 支持多种语言的语法高亮, 支持多种插件拓展, 但是最近在使用sublime写博客的时候发现, 不能在里面输入中文, 特地找了一波方法, 现整理如下:</p><a id="more"></a><p><strong> 方法一 : </strong><br>为了解决这个问题一些大牛已经开始写一些自动化的脚本, 比如 <a href="https://github.com/lyfeyaj/sublime-text-imfix" target="_blank" rel="noopener">sublime-text-imfix</a>具体的使用方法作者也已经给出:</p><ol><li><p>你需要用git或其他方法把代码下载到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade <span class="comment"># 更新一下系统</span></span><br><span class="line">sudo apt-get install git <span class="comment"># 安装 git 工具</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/lyfeyaj/sublime-text-imfix.git <span class="comment"># 克隆代码</span></span><br></pre></td></tr></table></figure></li><li><p>进入代码根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> sublime-text-imfix</span><br></pre></td></tr></table></figure></li><li><p>执行脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sublime-imfix</span><br></pre></td></tr></table></figure></li><li><p>重启你的 sublime, 查看问题有没有解决</p></li></ol><p>这个方法非常简单, 但是在我电脑上用这个方法后, sublime 在用命令行 <code>subl</code> 启动的时候可以在里面输入中文, 但是直接点击快捷方式打开的时候就不行了; 感觉一般写代码的话这样就够了, 所以接下来的工作我没做, 但是不确定效果, 仅供参考</p><p><strong> 方法二 ：</strong><br><a href="https://www.sinosky.org/linux-sublime-text-fcitx.html" target="_blank" rel="noopener">美解决 Linux 下 Sublime Text 中文输入</a>，写的较为详细, 可以试一下;</p><p>** 方法三 ：××<br><a href="http://jingyan.baidu.com/article/f3ad7d0ff8731609c3345b3b.html" target="_blank" rel="noopener">如何解决在Ubuntu14.04下Sublime Text 3无法输入中文的问题</a>, 写的很详细, 全程有截图</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sublime是一款非常好用的代码编辑器, 支持多种语言的语法高亮, 支持多种插件拓展, 但是最近在使用sublime写博客的时候发现, 不能在里面输入中文, 特地找了一波方法, 现整理如下:&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://blog.andrewei.me/categories/Linux/"/>
    
      <category term="软件" scheme="https://blog.andrewei.me/categories/Linux/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="sublime" scheme="https://blog.andrewei.me/categories/Linux/%E8%BD%AF%E4%BB%B6/sublime/"/>
    
    
      <category term="Linux" scheme="https://blog.andrewei.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 安装 deb 的方法</title>
    <link href="https://blog.andrewei.me/2016/04/27/ubuntu-install-deb/"/>
    <id>https://blog.andrewei.me/2016/04/27/ubuntu-install-deb/</id>
    <published>2016-04-27T13:12:15.000Z</published>
    <updated>2018-04-09T01:16:07.269Z</updated>
    
    <content type="html"><![CDATA[<p>ubuntu 安装 deb 软件包的方法有两种</p><ol><li>直接双击 deb 文件, 此时会自动调用系统的软件中心然后根据提示进行安装</li><li>作为程序员当然要用一种逼格高的方法来解决这个问题——用命令行来安装。ubuntu 下可以使用 dpkg 命令来安装, 下面是 dpkg 常用的几个命令:<a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -I iptux.deb <span class="comment">#查看iptux.deb软件包的详细信息，包括软件名称、版本以及大小等（其中-I等价于--info）</span></span><br><span class="line">sudo dpkg -c iptux.deb <span class="comment">#查看iptux.deb软件包中包含的文件结构（其中-c等价于--contents）</span></span><br><span class="line">sudo dpkg -i iptux.deb <span class="comment">#安装iptux.deb软件包（其中-i等价于--install）</span></span><br><span class="line">sudo dpkg -l iptux <span class="comment">#查看iptux软件包的信息（软件名称可通过dpkg -I命令查看，其中-l等价于--list）</span></span><br><span class="line">sudo dpkg -L iptux <span class="comment">#查看iptux软件包安装的所有文件（软件名称可通过dpkg -I命令查看，其中-L等价于--listfiles）</span></span><br><span class="line">sudo dpkg -s iptux <span class="comment">#查看iptux软件包的详细信息（软件名称可通过dpkg -I命令查看，其中-s等价于--status）</span></span><br><span class="line">sudo dpkg -r iptux<span class="comment">#卸载iptux软件包（软件名称可通过dpkg -I命令查看，其中-r等价于--remove）</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注：</strong>dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ubuntu 安装 deb 软件包的方法有两种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接双击 deb 文件, 此时会自动调用系统的软件中心然后根据提示进行安装&lt;/li&gt;
&lt;li&gt;作为程序员当然要用一种逼格高的方法来解决这个问题——用命令行来安装。ubuntu 下可以使用 dpkg 命令来安装, 下面是 dpkg 常用的几个命令:
    
    </summary>
    
      <category term="Linux" scheme="https://blog.andrewei.me/categories/Linux/"/>
    
      <category term="软件" scheme="https://blog.andrewei.me/categories/Linux/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Linux" scheme="https://blog.andrewei.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>POJ1273(Drainage Ditches)</title>
    <link href="https://blog.andrewei.me/2016/04/15/poj1273/"/>
    <id>https://blog.andrewei.me/2016/04/15/poj1273/</id>
    <published>2016-04-15T07:38:39.000Z</published>
    <updated>2018-04-09T01:16:07.268Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://poj.org/problem?id=1273" target="_blank" rel="noopener">http://poj.org/problem?id=1273</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>下雨的时候约翰的田里总是积水，积水把他种的三叶草给淹了，他于是做了若干排水沟，每条沟在起始处安置一个阀门来控制这条沟的最大排水量，现在给出沟的条数以及阀门的个数。并给出每条沟的最大排水量。约翰的田里的积水处是阀门1，排出水的位置是最后一个阀门。求约翰在处理积水时的最大排出量。<br><a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>题意抽象一下即有一个n个点的图, 边权代表最大流量, 求源点为1, 汇点为n的最大流.<br>题目为最大流的裸题, 用于练习算法模板.</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h3 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = ((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> mp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    pre[s] = s;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[u][i] &amp;&amp; !vis[i])&#123;</span><br><span class="line">                pre[i] = u;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                que.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s, t))&#123;</span><br><span class="line">        <span class="keyword">int</span> mi = MAX_INT;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i])&#123;</span><br><span class="line">            mi = min(mi, mp[pre[i]][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i])&#123;</span><br><span class="line">            mp[pre[i]][i] -= mi;</span><br><span class="line">            mp[i][pre[i]] += mi;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">memset</span>(mp, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            mp[u][v] += w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, EK(<span class="number">1</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">430</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, nxt, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ecnt;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line">Node pre[MAXN];</span><br><span class="line">Edge edge[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].w = w;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u] = ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    pre[s].v = s;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; edge[i].w)&#123;</span><br><span class="line">                pre[v].v = u;</span><br><span class="line">                pre[v].id = i;</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(v == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s, t))&#123;</span><br><span class="line">        <span class="keyword">int</span> mi = MAX_INT;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i].v)&#123;</span><br><span class="line">            mi = min(mi, edge[pre[i].id].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i].v)&#123;</span><br><span class="line">            edge[pre[i].id].w -= mi;</span><br><span class="line">            edge[pre[i].id ^ <span class="number">1</span>].w += mi;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n) != EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            addEdge(u, v, w);</span><br><span class="line">            addEdge(v, u, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, EK(<span class="number">1</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=1273&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://poj.org/problem?id=1273&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意:&quot;&gt;&lt;/a&gt;题目大意:&lt;/h2&gt;&lt;p&gt;下雨的时候约翰的田里总是积水，积水把他种的三叶草给淹了，他于是做了若干排水沟，每条沟在起始处安置一个阀门来控制这条沟的最大排水量，现在给出沟的条数以及阀门的个数。并给出每条沟的最大排水量。约翰的田里的积水处是阀门1，排出水的位置是最后一个阀门。求约翰在处理积水时的最大排出量。&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://blog.andrewei.me/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="poj" scheme="https://blog.andrewei.me/categories/%E9%A2%98%E8%A7%A3/poj/"/>
    
    
      <category term="题解" scheme="https://blog.andrewei.me/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="poj" scheme="https://blog.andrewei.me/tags/poj/"/>
    
      <category term="网络流" scheme="https://blog.andrewei.me/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>网络流入门</title>
    <link href="https://blog.andrewei.me/2016/04/11/network-flows/"/>
    <id>https://blog.andrewei.me/2016/04/11/network-flows/</id>
    <published>2016-04-11T08:51:36.000Z</published>
    <updated>2018-04-09T01:16:07.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念-从书上摘抄-可以直接跳过不看"><a href="#基本概念-从书上摘抄-可以直接跳过不看" class="headerlink" title="基本概念(从书上摘抄,可以直接跳过不看)"></a>基本概念(从书上摘抄,可以直接跳过不看)</h2><h3 id="容量网络和网络最大流"><a href="#容量网络和网络最大流" class="headerlink" title="容量网络和网络最大流"></a>容量网络和网络最大流</h3><p><strong> 容量网络: </strong> 设 <code>G(V, E)</code>是一个有向网络, 在 V 中指定了一个顶点, 称为源点(记为 Vs ), 以及另一个顶点, 称为汇点(记为 Vt); 对于每一条弧 <code>&lt;u, v&gt;∈E</code>, 对应有一个权值 c(u, v)&gt;0, 称为<code>弧的容量</code>, 通常把这样的有向网络 G 称为容量网络。</p><blockquote><p>也就是指: 一个拥有源点、汇点并且可以容纳流量的图.</p></blockquote><p><strong> 弧的流量: </strong> 通过容量网络 G 中每条弧 <code>&lt;u, v&gt;</code> 上的实际流量(简称流量), 记为 <code>f(u, v)</code>。<br><strong> 网络流: </strong> 所有弧上流量的集合 <code>f = { f(u, v) }</code>,称为该容量网络 G 的一个网络流。<br><strong> 可行流: </strong> 在容量网络 <code>G(V, E)</code> 中, 满足以下条件的网络流 f, 称为可行流:</p><ul><li><strong> 弧流量限制条件: </strong> $ 0 ≤ f(u, v) ≤ c(u, v)$</li><li><strong> 平衡条件: </strong> 除了 Vs, Vt 外, 其余的点流入的流量总和等于流出的流量总和, 其中 <code>Vs 流出的流量总和 - 流出的流量总和 = f</code>, <code>Vt 流入的流量总和 - 流出的流量总和 = f</code>, 并且称 <code>f</code> 为可性流的流量.</li></ul><blockquote><p>也就是指: 在图中有一条从 Vs 到 Vt 的路径, 这条路径上起点 $f_o - f_i = f$, 终点 $f_i - f_o = f$， 其他的点 $f_i == f_o$, 并且所有的边的当前流量小于等于最大流量.(其中 $f_i$ 代表流入流量, $f_o$ 代表流出流量)<br><a id="more"></a></p></blockquote><p><strong> 伪流: </strong> 如果一个网络流只满足弧流量限制条件, 不满足平衡条件, 则这种网络流称为伪流, 或称为容量可行流。<br><strong> 最大流: </strong> 在容量网络 <code>G(V, E)</code> 中, 满足弧流量限制条件和平衡条件、且具有最大流量的可行流, 称为网络最大流, 简称最大流。</p><h3 id="链与增广路"><a href="#链与增广路" class="headerlink" title="链与增广路"></a>链与增广路</h3><p>在容量网络 <code>G(V, E)</code> 中, 设有一可行流 <code>f = { f(u, v) }</code>, 根据每条弧上流量的多少、以及流量和容量的关系,可将弧分四种类型:</p><ul><li>饱和弧, 即 $f(u, v) = c(u, v)$;</li><li>非饱和弧,即 $f(u, v) &lt; c(u, v)$;</li><li>零流弧, 即 $f(u, v) = 0$;</li><li>非零流弧, 即 $f(u, v) &gt; 0$。</li></ul><p><strong> 链: </strong> 在容量网络中,称顶点序列$(u, u_1, u_2, …, u_n, v)$为一条链,要求相邻两个顶点之间有一条弧, 如 <code>&lt;u, u1&gt;</code> 或 <code>&lt;u1, u&gt;</code> 为容量网络中一条弧。沿着 Vs 到 Vt 的一条链, 各弧可分为两类:</p><ul><li><strong> 前向弧: </strong> 方向与链的正方向一致的弧, 其集合记为 <code>P+</code>; </li><li><strong> 后向弧: </strong> 方向与链的正方向相反的弧, 其集合记为 <code>P-</code>;</li></ul><p><strong> 增广路: </strong> 设 f 是一个容量网络 G 中的一个可行流, P 是从 Vs 到 Vt 的一条链, 若 P 满足下列条件:</p><ul><li>在 P 的所有前向弧 <code>&lt;u, v&gt;</code> 上, $0 ≤ f(u, v) &lt; c(u, v)$, 即 <code>P+</code> 中每一条弧都是非饱和弧;</li><li>在 P 的所有后向弧 <code>&lt;u, v&gt;</code> 上, $0 &lt; f(u, v) ≤ c(u, v)$, 即 <code>P–</code> 中每一条弧是非零流弧。</li></ul><p>则称 P 为关于可行流 f 的一条增广路, 简称为 <code>增广路(或称为增广链、可改进路)</code>。沿着增广路改进可行流的操作称为<code>增广</code></p><h3 id="残留容量与残留网络"><a href="#残留容量与残留网络" class="headerlink" title="残留容量与残留网络"></a>残留容量与残留网络</h3><p><strong> 残留容量: </strong> 给定容量网络 <code>G(V, E)</code> 及可行流 f, 弧 <code>&lt;u, v&gt;</code> 上的残留容量记为 $c’(u, v)=c(u, v)–f(u, v)$。每条弧的残留容量表示该弧上可以增加的流量。因为从顶点 u 到顶点 v 流量的减少, 等效于顶点 v 到顶点 u 流量增加, 所以每条弧 <code>&lt;u, v&gt;</code> 上还有一个反方向的残留容量 $c’(v, u) =– f(u, v)$。</p><blockquote><p>一个容量网络中还可以压入的流量称为残留容量</p></blockquote><p><strong> 残留网络: </strong> 设有容量网络 <code>G(V, E)</code> 及其上的网络流 f,G 关于 f 的残留网络(简称残留网络)记为 <code>G&#39;(V&#39;, E&#39;)</code>, 其中 G’的顶点集 V’和 G 的顶点集 V 相同,即 V’=V, 对于 G 中的任何一条弧 <code>&lt;u, v&gt;</code>, 如果 $f(u, v) &lt; c(u, v)$, 那么在 G’中有一条弧 <code>&lt;u, v&gt;∈E&#39;</code>, 其容量为 $c’(u, v) = c(u, v) – f(u, v)$, 如果 $f(u, v) &gt; 0$,则在 G’中有一条弧 <code>&lt;v, u&gt;∈E&#39;</code>, 其容量为 $c’(v, u) = f(u, v)$, 残留网络也称为<code>剩余网络</code>.</p><blockquote><p>由残留的容量以及源点汇点构成的网络。</p></blockquote><h3 id="割与最小割"><a href="#割与最小割" class="headerlink" title="割与最小割"></a>割与最小割</h3><p><strong> 割: </strong> 在容量网络 <code>G(V, E)</code> 中, 设 <code>E&#39;⊆E</code>, 如果在 G 的基图中删去 E’ 后不再连通, 则称 E’ 是 G 的割。割将 G 的顶点集 V 划分成两个子集 S 和 T = V - S。将割记为(S, T)。<br><strong> s-t 割: </strong> 更进一步, 如果割所划分的两个顶点子集满足源点 <code>Vs ∈ S</code>,汇点 <code>Vt ∈ T</code>, 则称该割为 <code>s-t 割</code>。 s-t 割(S, T)中的弧 <code>&lt;u, v&gt;(u∈S, v∈T)</code> 称为割的前向弧, 弧 <code>&lt;u, v&gt;( u∈T, v∈S)</code> 称为割的反向弧。<br><strong> 割的容量: </strong> 设 <code>(S, T)</code> 为容量网络 <code>G(V, E)</code> 的一个割, 其容量定义为所有前向弧的容量总和, 用 <code>c(S, T)</code> 表示。<br><strong> 最小割: </strong> 容量网络 <code>G(V, E)</code> 的最小割是指容量最小的割。</p><h3 id="相关定理"><a href="#相关定理" class="headerlink" title="相关定理"></a>相关定理</h3><h4 id="残留网络与原网络的关系"><a href="#残留网络与原网络的关系" class="headerlink" title="残留网络与原网络的关系"></a>残留网络与原网络的关系</h4><p>设 f 是容量网络 G(V, E) 的可行流, f’ 是残留网络 G’ 的可行流, 则 f + f’ 仍是容量网络 G 的一个可行流。(f + f’ 表示对应弧上的流量相加)</p><h4 id="网络流流量与割的净流量之间的关系"><a href="#网络流流量与割的净流量之间的关系" class="headerlink" title="网络流流量与割的净流量之间的关系"></a>网络流流量与割的净流量之间的关系</h4><p>在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 关于 f 的任意一个割为(S, T), 则有 $f(S, T) = | f |$,即网络流的流量等于任何割的净流量。</p><h4 id="网络流流量与割的容量之间的关系"><a href="#网络流流量与割的容量之间的关系" class="headerlink" title="网络流流量与割的容量之间的关系"></a>网络流流量与割的容量之间的关系</h4><p>在一个容量网络 G(V, E) 中, 设其任意一个流为 f, 任意一个割为(S, T), 则必有 $f(S, T) ≤ c(S, T)$,即网络流的流量小于或等于任何割的容量。</p><h4 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h4><p>对容量网络 G(V, E), 其最大流的流量等于最小割的容量。</p><h4 id="增广路定理"><a href="#增广路定理" class="headerlink" title="增广路定理"></a>增广路定理</h4><p>设容量网络 G(V, E) 的一个可行流为 f, f 为最大流的充要条件是在容量网络中不存在增广路。</p><h4 id="几个等价命题"><a href="#几个等价命题" class="headerlink" title="几个等价命题"></a>几个等价命题</h4><p>设容量网络 G(V, E)的一个可行流为 f 则:</p><ul><li>1) f 是容量网络 G 的最大流;</li><li>2) | f |等于容量网络最小割的容量;</li><li>3) 容量网络中不存在增广路;</li><li>4) 残留网络 G’中不存在从源点到汇点的路径。</li></ul><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>最大流相关算法有两种解决思想, 一种是<code>增广路算法</code>思想, 另一种是<code>预流推进</code>算法思想。 下面将分别介绍这两种算法思想。</p><h3 id="增广路算法-Ford-Fulkerson"><a href="#增广路算法-Ford-Fulkerson" class="headerlink" title="增广路算法(Ford-Fulkerson)"></a>增广路算法(Ford-Fulkerson)</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>根据增广路定理, 为了得到最大流, 可以从任何一个可行流开始, 沿着增广路对网络流进行增广, 直到网络中不存在增广路为止,这样的算法称为增广路算法。问题的关键在于如何有效地找到增广路, 并保证算法在有限次增广后一定终止。<br>增广路算法的基本流程是 :</p><ul><li>(1) 取一个可行流 f 作为初始流(如果没有给定初始流,则取零流 f= { 0 }作为初始流);</li><li>(2) 寻找关于 f 的增广路 P,如果找到,则沿着这条增广路 P 将 f 改进成一个更大的流, 并建立相应的<strong>反向弧</strong>;</li><li>(3) 重复第(2)步直到 f 不存在增广路为止。</li></ul><p>图示如下:<br><img src="/images/network-flows/FFalgo1.png" alt="Ford-Fulkerson算法过程"><br><img src="/images/network-flows/FFalgo2.png" alt="Ford-Fulkerson算法过程"></p><p>增广路算法的关键是 <code>寻找增广路</code> 和 <code>改进网络流</code>。<br><strong> 问题: 为什么要创建反向弧呢? </strong><br><strong> 原因: 为程序提供一次反悔的机会 </strong> 什么意思, 如下图所示:<br>在图中如果程序找到了一条增广路 1 -&gt; 2 -&gt; 4 -&gt; 6, 此时得到一个流量为 2 的流并且无法继续进行增广,<br>但是如果在更新可行流的同时建立反向弧的话, 就可以找到 1 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 5 -&gt; 6 的可行流, 流量为1, 这样就可以得到最大流为 3.<br><img src="/images/network-flows/FFalgo7.jpg" alt="Ford-Fulkerson算法过程"></p><h4 id="一般增广路算法-EdmondsKarp"><a href="#一般增广路算法-EdmondsKarp" class="headerlink" title="一般增广路算法(EdmondsKarp)"></a>一般增广路算法(EdmondsKarp)</h4><h5 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h5><p>在一般的增广路算法中, 程序的实现过程与增广路求最大流的过程基本一致. 即每一次更新都进行一次找增广路然后更新路径上的流量的过程。但是我们可以从上图中发现一个问题, 就是每次找到的增广路曲曲折折非常长, 此时我们往往走了冤枉路(即：明明我们可以从源点离汇点越走越进的，可是中间的几条边却向离汇点远的方向走了), 此时更新增广路的复杂度就会增加。EK 算法为了规避这个问题使用了 bfs 来寻找增广路, 然后在寻找增广路的时候总是向离汇点越来越近的方向去寻找下一个结点。 </p><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = ((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;                                      <span class="comment">// 图中点的数目</span></span><br><span class="line"><span class="keyword">int</span> pre[MAXN];                              <span class="comment">// 从 s - t 中的一个可行流中, 节点 i 的前序节点为 Pre[i];</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];                             <span class="comment">// 标记一个点是否被访问过</span></span><br><span class="line"><span class="keyword">int</span> mp[MAXN][MAXN];                         <span class="comment">// 记录图信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    pre[s] = s;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[u][i] &amp;&amp; !vis[i])&#123;</span><br><span class="line">                pre[i] = u;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                que.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s, t))&#123;</span><br><span class="line">        <span class="keyword">int</span> mi = MAX_INT;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i])&#123;</span><br><span class="line">            mi = min(mi, mp[pre[i]][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i])&#123;</span><br><span class="line">            mp[pre[i]][i] -= mi;</span><br><span class="line">            mp[i][pre[i]] += mi;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">430</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, nxt, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ecnt;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line">Node pre[MAXN];</span><br><span class="line">Edge edge[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].w = w;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u] = ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    pre[s].v = s;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; edge[i].w)&#123;</span><br><span class="line">                pre[v].v = u;</span><br><span class="line">                pre[v].id = i;</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(v == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                que.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s, t))&#123;</span><br><span class="line">        <span class="keyword">int</span> mi = MAX_INT;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i].v)&#123;</span><br><span class="line">            mi = min(mi, edge[pre[i].id].w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i].v)&#123;</span><br><span class="line">            edge[pre[i].id].w -= mi;</span><br><span class="line">            edge[pre[i].id ^ <span class="number">1</span>].w += mi;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += mi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加边</span></span><br><span class="line">addEdge(u, v, w);</span><br><span class="line">addEdge(v, u, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">int</span> ans = EK(s, t);</span><br></pre></td></tr></table></figure><h5 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h5><p>每进行一次增广需要的时间复杂度为 bfs 的复杂度 + 更新残余网络的复杂度, 大约为 O(m)(m为图中的边的数目), 需要进行多少次增广呢, 假设每次增广只增加1, 则需要增广 nW 次(n为图中顶点的数目, W为图中边上的最大容量), .</p><h4 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h4><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>DINIC 在找增广路的时候也是找的最短增广路, 与 EK 算法不同的是 DINIC 算法并不是每次 bfs 只找一个增广路, 他会首先通过一次 bfs 为所有点添加一个标号, 构成一个层次图， 然后在层次图中寻找增广路进行更新。</p><h5 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h5><blockquote><ol><li>利用 BFS 对原来的图进行分层，即对每个结点进行标号， 这个标号的含义是当前结点距离源点的最短距离(假设每条边的距离都为1)，注意：构建层次图的时候所走的边的残余流量必须大于0</li><li>用 DFS 寻找一条从源点到汇点的增广路, 注意: 此处寻找增广路的时候要按照层次图的顺序, 即如果将边(u, v)纳入这条增广路的话必须满足$dis[u] = dis[v] - 1$, 其中 $dis[i]$为结点 $i$的编号。找到一条路后要根据这条增广路径上的所有边的残余流量的最小值$l$更新所有边的残余流量(即正向弧 - l, 反向弧 + l).</li><li>重复步骤 2, 当找不到一条增广路的时候, 重复步骤 1, 重新建立层次图, 直到从源点不能到达汇点为止。</li></ol></blockquote><p>算法流程如下图所示:<br><img src="/images/network-flows/FFalgo8.jpg" alt="DINIC算法过程"></p><h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN_INT = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">int</span> mp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> top = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] &lt; <span class="number">0</span> &amp;&amp; mp[top][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dis[i] = dis[top] + <span class="number">1</span>;</span><br><span class="line">                que.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> low)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == n) <span class="keyword">return</span> low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[x][i] &gt; <span class="number">0</span> </span><br><span class="line">            &amp;&amp; dis[i] == dis[x] + <span class="number">1</span></span><br><span class="line">            &amp;&amp; (a = Find(i, min(low, mp[x][i]))))&#123;</span><br><span class="line">            mp[x][i] -= a;</span><br><span class="line">            mp[i][x] += a;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp, <span class="number">0</span>, <span class="keyword">sizeof</span>(mp));</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            mp[u][v] += w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, tmp;</span><br><span class="line">        <span class="keyword">while</span>(bfs(<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">while</span>(tmp = Find(<span class="number">1</span>, MAXN_INT))</span><br><span class="line">                ans += tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 当前弧优化和多路增广:</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">101000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN_INT = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, nxt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"><span class="keyword">int</span> n, m, ecnt;</span><br><span class="line">Edge edge[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN], dis[MAXN], curEdge[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].w = w;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u] = ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dis[t] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(t);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[i].v] == <span class="number">-1</span> &amp;&amp; edge[i ^ <span class="number">1</span>].w &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dis[edge[i].v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">                que.push(edge[i].v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[s] != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> delta = flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i = curEdge[u]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[u] == dis[edge[i].v] + <span class="number">1</span> &amp;&amp; edge[i].w)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = dfs(edge[i].v, v, min(delta, edge[i].w));</span><br><span class="line">            edge[i].w -= d, edge[i ^ <span class="number">1</span>].w += d;</span><br><span class="line">            delta -= d;</span><br><span class="line">            <span class="keyword">if</span>(delta == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow - delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            curEdge[i] = head[i];</span><br><span class="line">        ans += dfs(s, t, MAXN_INT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            addEdge(u, v, w);</span><br><span class="line">            addEdge(v, u, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dinic());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>$O(V^2E)</p><h4 id="最短增广路算法-SAP"><a href="#最短增广路算法-SAP" class="headerlink" title="最短增广路算法(SAP)"></a>最短增广路算法(SAP)</h4><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>最短增广路算法是一种运用距离标号使寻找增广路的时间复杂度下降的算法。所谓的距离标号就是某个点到汇点的最少的弧的数量(即当边权为1时某个点的最短路径长度). 设点i的标号为d[i], 那么如果将满足d[i] = d[j] + 1, 且增广时只走允许弧, 那么就可以达到”怎么走都是最短路”的效果. 每个点的初始标号可以在一开始用一次从汇点沿所有反向的BFS求出.</p><h5 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h5><blockquote><p>1) 定义节点的标号为到汇点的最短距离;<br>2) 每次沿可行边进行增广, 可行边即: 假设有两个点 i, j 若 d[i] = 3, d[j] = 4, 则d[j] = d[i] + 1, 也就是从 j 到 i 有一条边.<br>3) 找到增广路后，将路径上所有边的流量更新.<br>4) 遍历完当前结点的可行边后更新当前结点的标号为 $d[now] = min(d[next] | Flow(now, next) &gt; 0) + 1$，使下次再搜的时候有路可走。<br>5) 图中不存在增广路后即退出程序，此时得到的流量值就是最大流。</p></blockquote><p>需要注意的是, 标号的更新过程首先我们要理解更新标号的目的。标号如果需要更新，说明在当前的标号下已经没有增广路可以继续走，这时更新标号就可以使得我们有继续向下走的可能，并且每次找的都是能走到的点中标号最小的那个点，这样也使得每次搜索长度最小.<br>下面的图演示了标号的更新过程:</p><ol><li>首先我们假设有个图如下，为了简化没有标箭头也没有写流量:<br><img src="/images/network-flows/FFalgo3.png" alt="SAP算法过程"></li><li>为图标号, 每个点的标号为其到汇点的最短距离(这里把每条边看作1)<br><img src="/images/network-flows/FFalgo4.png" alt="SAP算法过程"></li><li>第一遍遍历时，找到了1-&gt;2-&gt;9这样一条增广路以后，更新边上流量值, 得到下图<br>棕色字体为边上的流量值。这时按照标号再搜一遍,发现从1出发已经找不到增广路了，因为flow(1,2)等于0不可以走，$ h[1]=2,h[3]=2≠h[1]+1,h[5]=4≠h[1]+1 $，所以这时更新1的标号，按照 $min(h[next]|Flow(now,next)&gt;0)+1$，修改后 $h[1]=h[3]+1=3$.<br><img src="/images/network-flows/FFalgo5.png" alt="SAP算法过程"></li><li>第二遍遍历以后找到了这样一条增广路：1-&gt;3-&gt;4-&gt;9,做完这条路以后又发现无法找到可行边了，这时再更新标号使图中有路可走，如上文所说的那样做，再次修改后$h[1]=h[5]+1=5$，就这样搜索并更新直到变成下图<br><img src="/images/network-flows/FFalgo6.png" alt="SAP算法过程"></li><li>这时再更新h[1]发现没有点可以用来更新h[1]了，于是此时$h[1]=∞$，使程序退出。</li></ol><p><strong> GAP 优化: </strong> 由于可行边定义为：$ (now, next) | h[now] = h[next]+1 $，所以若标号出现“断层”即有的标号对应的顶点个数为0，则说明剩余图中不存在增广路，此时便可以直接退出，降低了无效搜索。举个栗子：若结点标号为3的结点个数为0，而标号为4的结点和标号为2的结点都大于 0,那么在搜索至任意一个标号为4的结点时，便无法再继续往下搜索，说明图中就不存在增广路。此时我们可以以将$ h[1] = n$形式来变相地直接结束搜索</p><h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN_INT = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, nxt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isFind;</span><br><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line">Edge edge[MAXN];</span><br><span class="line"><span class="keyword">int</span> dis[MAXN], gap[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, ecnt, aug, maxFlow;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ecnt = maxFlow = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(gap, <span class="number">0</span>, <span class="keyword">sizeof</span>(gap));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    gap[<span class="number">0</span>] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].w = w;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u] = ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx, augc, minDis;</span><br><span class="line">    <span class="keyword">if</span>(s == n)&#123;</span><br><span class="line">        isFind = <span class="literal">true</span>;</span><br><span class="line">        maxFlow += aug;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    augc = aug;</span><br><span class="line">    minDis = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[i]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].w &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[s] == dis[edge[i].v] + <span class="number">1</span>)&#123;</span><br><span class="line">                aug = min(aug, edge[i].w);</span><br><span class="line">                Find(edge[i].v);</span><br><span class="line">                <span class="keyword">if</span>(dis[<span class="number">1</span>] &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span>(isFind)&#123;</span><br><span class="line">                    dx = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                aug = augc;</span><br><span class="line">            &#125;</span><br><span class="line">            minDis = min(minDis, dis[edge[i].v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isFind)&#123;</span><br><span class="line">        gap[dis[s]]--;</span><br><span class="line">        <span class="keyword">if</span>(gap[dis[s]] == <span class="number">0</span>) dis[<span class="number">1</span>] = n;</span><br><span class="line">        dis[s] = minDis + <span class="number">1</span>;</span><br><span class="line">        gap[dis[s]]++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        edge[dx].w -= aug;</span><br><span class="line">        edge[dx ^ <span class="number">1</span>].w += aug;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            addEdge(u, v, w);</span><br><span class="line">            addEdge(v, u, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(dis[<span class="number">1</span>] &lt; n)&#123;</span><br><span class="line">            isFind = <span class="number">0</span>;</span><br><span class="line">            aug = MAXN_INT;</span><br><span class="line">            Find(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; maxFlow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>$O(V^2E)$</p><h3 id="预流推进算法"><a href="#预流推进算法" class="headerlink" title="预流推进算法"></a>预流推进算法</h3><p>预流推进算法是从一个预流出发对活跃顶点沿着允许弧进行流量增广,每次增广称为一次推进。在推进过程中,流一定满足流量限制条件,但一般不满足流量平衡条件, 因此只是一个伪流。此外, 如果一个伪流中, 从每个顶点(除源点 V s 、汇点 V t 外)流出的流量之和总是小于等于流入该顶点的流量之和, 称这样的伪流为预流。因此这类算法被称为预流推进算法。</p><h4 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h4><blockquote><ol><li>首先用一边 BFS 为图中每个顶点一个标号dis[v], 表示该点到v的最短路.</li><li>将与 S 相连的边设为满流, 并将这时产生的活动结点加入队列Q。</li><li>选出 Q 的一个活动结点 u 并依次判断残量网咯 G’ 中每条边(u, v), 若 $dis[u] = min(dis[v] + 1)$, 则顺着这些边推流, 直到 Q 变成非活动结点(不存在多余流量). </li><li>如果 u 还是活动结点，则需要对 u 进行重新标号: $dis[u] = min(dis[v] + 1)$, 其中边 (u, v) 存在于 G’ 中,然后再将 u 加入队列。</li><li>重复3, 4两个步骤直到队列 Q 为空。</li></ol></blockquote><h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1</span> &lt;&lt; <span class="number">15</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> graph[size][size];</span><br><span class="line"><span class="keyword">int</span> label[size];        <span class="comment">//标号</span></span><br><span class="line"><span class="keyword">bool</span> visited[size];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(label, <span class="number">-1</span>, <span class="keyword">sizeof</span>(label));</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">    label[st] = <span class="number">0</span>;</span><br><span class="line">    visited[st] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt;plist;</span><br><span class="line">    plist.push_back(st);</span><br><span class="line">    <span class="keyword">while</span> (plist.size()) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = plist[<span class="number">0</span>];</span><br><span class="line">    plist.erase(plist.begin());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[i][p] &gt; <span class="number">0</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">        plist.push_back(i);</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        label[i] = label[p] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (label[ed] == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> inflow[size];       <span class="comment">//流入量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inflow, <span class="number">0</span>, <span class="keyword">sizeof</span>(inflow));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//hights</span></span><br><span class="line">    bfs(size - <span class="number">1</span>, <span class="number">0</span>);       <span class="comment">//end point: size - 1, start point: 0</span></span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//prepare()</span></span><br><span class="line">    <span class="built_in">vector</span> &lt; <span class="keyword">int</span> &gt;plist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (graph[start][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        inflow[i] = graph[start][i];</span><br><span class="line">        graph[start][i] -= inflow[i];</span><br><span class="line">        graph[i][start] += inflow[i];</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">        plist.push_back(i);</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (plist.size()) &#123;</span><br><span class="line">    <span class="keyword">int</span> p = plist[<span class="number">0</span>];</span><br><span class="line">    plist.erase(plist.begin());</span><br><span class="line">    visited[p] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> minLabel = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[p][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (label[p] == label[i] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> flow = min(inflow[p], graph[p][i]);</span><br><span class="line">            inflow[p] -= flow;</span><br><span class="line">            inflow[i] += flow;</span><br><span class="line">            graph[p][i] -= flow;</span><br><span class="line">            graph[i][p] += flow;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (!visited[i] &amp;&amp; inflow[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            plist.push_back(i);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inflow[p] &gt; <span class="number">0</span> &amp;&amp; p != end) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[p][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minLabel == <span class="number">-1</span> || minLabel &gt; label[i] + <span class="number">1</span>) &#123;</span><br><span class="line">            minLabel = label[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!visited[p] &amp;&amp; minLabel != <span class="number">-1</span> &amp;&amp; minLabel &lt; size)    <span class="comment">//minLabel &lt; size, 这个条件需要加上, 因为经过测试发现有死循环的可能</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (label[i] + <span class="number">1</span> == minLabel &amp;&amp; graph[p][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            visited[p] = <span class="literal">true</span>;</span><br><span class="line">            label[p] = minLabel;</span><br><span class="line">            plist.push_back(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inflow[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>如果该算法的Q是标准的FIFO队列，则时间复杂度为$(n^2m)$，最高标号不会超过$n$（超过时必无到汇的路径），所以$n$个点每个最多重新标号$n$次，两次标号之间$m$条边每条最多推流一次。如果是优先队列，并且标号最高的点优先的话，我们就得到了最高标号预流推进算法，其时间复杂度仅为$n^2\sqrt{m}$.</p><h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>最小费用最大流是解决这么一种问题: 对于图中的每一条边来说, 除了有一个最大容量的属性以外，还有一个费用属性, 即流过这条边的单位流量的花费。求解的问题为在保证从源点到汇点的流量最大的前提下使得花费最少。</p><h3 id="求解思想"><a href="#求解思想" class="headerlink" title="求解思想"></a>求解思想</h3><p>我们来考虑这么一个问题: 在最短路的一些变形的题目中往往有这种题，每条路不仅仅有一个长度还有一个建设的费用， 最终求从起点到终点在保证路最短的前提下，使得花费的钱最少。当时我们是怎么求解的呢？<br>首先我们知道，最短路的长度是一定的，但是组成一条最短路的边是不一定的，所以我们在搜索这条最短路的时候只要通过调整待选边的优先级来控制搜索的方向就可以满足上述问题的要求。<br>这个问题跟我们现在求解的最小费用最大流问题神似啊，只要我们在寻找增广路的时候调整待选边的优先级来控制寻找方向，这个问题就可以解决了啊。我们直到对于一条增广路来说, 花费满足: $cost = minFlow * \sum w_i(i\in 增广路上的边)$, 实际上这里的优先级就是每条边的长度认为是其单位流量的花费的最短路。</p><h3 id="求解算法"><a href="#求解算法" class="headerlink" title="求解算法"></a>求解算法</h3><p>基于最大流的三种算法，求解最小费用最大流也具有三种算法，我们来对比一下这三对算法:</p><blockquote><p><strong> 最大流 EK 算法:</strong> 每次用广搜寻找一条最短的增广路（即包含最少的边），然后沿其增广。<br><strong> 费用流 E’K’ 算法:</strong> 每次用spfa计算图的距离标号，然后沿着可行边进行增广。</p></blockquote><blockquote><p><strong> 最大流 DINIC 算法:</strong> 用广搜获得每个点到源点的距离标号，增广时沿距离标号严格减1的路径增广，直到网络中不再存在这么一条路径，那么重新广搜计算距离标号，如果广搜发现整个源点到汇点已经不连通那么退出算法。<br><strong> 费用流 原始对偶 算法:</strong> 用 SPFA 获得每个点到源点的最短路，增广时沿着最短路前进的方向增广, 直到网络中不存在一条路径时重新 SPFA 求最短路, 直到没有一条最短路可以到达汇点为止。</p></blockquote><blockquote><p><strong> 最大流 SAP 算法:</strong> 与 dinic 一样基于距离标号，不过这里保存的是到汇点的距离标号。并且考虑每次增广对网络的影响，发现增广只会使点的距离标号变大，并且并不会破坏距离标号 $dis[u] &lt;= dis[v] + w[u, v]$ 的性质，只会使得等号不再成立。找不到可行边就是因为没有一个结点v使得$dis[u] == dis[v] + w[u, v]$。那么重新使等号成立的方法也很简单，并不需要重新计算整个图的距离标号，只需要调整距离标号：如果从u点开始寻找增广路没有成功，即没有一个v使得$dis[u] == dis[v] + w[u, v]$那么在所有&lt;u,v&gt;（v∈V）中找到距离标号最小的一个v，使$dis[u] = dis[v] + w[u, v]$即可。<br><strong> 费用流 ZKW 算法:</strong>  每次增广，同样不会破坏距离标号$dis[u] &lt;= dis[v] + w[u, v]$，只会使得等号不再成立。并且被破坏的点并没有很多（只有在增广路上的点有可能被破坏）。因此并不需要SPFA来重新计算全部的距离标号。如果某一次寻找可行边组成增广路的尝试进行到点u失败，那么在所有的边$&lt;u,v&gt;（v∈V$中找到距离标号最小的一个v，使$dis[v] == dis[v] + w[u, v]&amp;成立即可。</p></blockquote><h3 id="费用流-E’K’-算法"><a href="#费用流-E’K’-算法" class="headerlink" title="费用流 E’K’ 算法"></a>费用流 E’K’ 算法</h3><p>思想上面说过了, 就是把最大流 EK 算法里面的 bfs 替换为 SPFA, 改变遍历的优先级来实现:</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>与 EK 算法相同, 只不过将 bfs 换成 spfa求最短路, 边权为该边的单位流量花费.<br>如下图所示<br><img src="/images/network-flows/FFalgo9.jpg" alt="SAP算法过程"></p><h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN_INT = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, c, nxt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">Node pre[MAXN];</span><br><span class="line">Edge edge[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, ecnt, sumFlow;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], dis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].w = w;</span><br><span class="line">    edge[ecnt].c = c;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u] = ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    fill(dis, dis + MAXN, MAXN_INT);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u =que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].c &amp;&amp; dis[v] &gt; dis[u] + edge[i].c)&#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].c;</span><br><span class="line">                pre[v].v = u;</span><br><span class="line">                pre[v].id = i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[t] == MAXN_INT) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MCMF</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(SPFA(s, t, n))&#123;</span><br><span class="line">        <span class="keyword">int</span> minFlow = MAXN_INT + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i].v)&#123;</span><br><span class="line">            minFlow = min(minFlow, edge[pre[i].id].w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i != s; i = pre[i].v)&#123;</span><br><span class="line">            edge[pre[i].id].w -= minFlow;</span><br><span class="line">            edge[pre[i].id ^ <span class="number">1</span>].w += minFlow;</span><br><span class="line">        &#125;</span><br><span class="line">        minCost += dis[t] * minFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    sumFlow = flow;</span><br><span class="line">    <span class="keyword">return</span> minCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, c, w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;v, &amp;c, &amp;w);</span><br><span class="line">            addEdge(u, v, c, w);</span><br><span class="line">            addEdge(v, u, -c, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = MCMF(<span class="number">1</span>, n, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念-从书上摘抄-可以直接跳过不看&quot;&gt;&lt;a href=&quot;#基本概念-从书上摘抄-可以直接跳过不看&quot; class=&quot;headerlink&quot; title=&quot;基本概念(从书上摘抄,可以直接跳过不看)&quot;&gt;&lt;/a&gt;基本概念(从书上摘抄,可以直接跳过不看)&lt;/h2&gt;&lt;h3 id=&quot;容量网络和网络最大流&quot;&gt;&lt;a href=&quot;#容量网络和网络最大流&quot; class=&quot;headerlink&quot; title=&quot;容量网络和网络最大流&quot;&gt;&lt;/a&gt;容量网络和网络最大流&lt;/h3&gt;&lt;p&gt;&lt;strong&gt; 容量网络: &lt;/strong&gt; 设 &lt;code&gt;G(V, E)&lt;/code&gt;是一个有向网络, 在 V 中指定了一个顶点, 称为源点(记为 Vs ), 以及另一个顶点, 称为汇点(记为 Vt); 对于每一条弧 &lt;code&gt;&amp;lt;u, v&amp;gt;∈E&lt;/code&gt;, 对应有一个权值 c(u, v)&amp;gt;0, 称为&lt;code&gt;弧的容量&lt;/code&gt;, 通常把这样的有向网络 G 称为容量网络。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是指: 一个拥有源点、汇点并且可以容纳流量的图.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt; 弧的流量: &lt;/strong&gt; 通过容量网络 G 中每条弧 &lt;code&gt;&amp;lt;u, v&amp;gt;&lt;/code&gt; 上的实际流量(简称流量), 记为 &lt;code&gt;f(u, v)&lt;/code&gt;。&lt;br&gt;&lt;strong&gt; 网络流: &lt;/strong&gt; 所有弧上流量的集合 &lt;code&gt;f = { f(u, v) }&lt;/code&gt;,称为该容量网络 G 的一个网络流。&lt;br&gt;&lt;strong&gt; 可行流: &lt;/strong&gt; 在容量网络 &lt;code&gt;G(V, E)&lt;/code&gt; 中, 满足以下条件的网络流 f, 称为可行流:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt; 弧流量限制条件: &lt;/strong&gt; $ 0 ≤ f(u, v) ≤ c(u, v)$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 平衡条件: &lt;/strong&gt; 除了 Vs, Vt 外, 其余的点流入的流量总和等于流出的流量总和, 其中 &lt;code&gt;Vs 流出的流量总和 - 流出的流量总和 = f&lt;/code&gt;, &lt;code&gt;Vt 流入的流量总和 - 流出的流量总和 = f&lt;/code&gt;, 并且称 &lt;code&gt;f&lt;/code&gt; 为可性流的流量.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;也就是指: 在图中有一条从 Vs 到 Vt 的路径, 这条路径上起点 $f_o - f_i = f$, 终点 $f_i - f_o = f$， 其他的点 $f_i == f_o$, 并且所有的边的当前流量小于等于最大流量.(其中 $f_i$ 代表流入流量, $f_o$ 代表流出流量)&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="网络流" scheme="https://blog.andrewei.me/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="图论" scheme="https://blog.andrewei.me/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图的连通性问题</title>
    <link href="https://blog.andrewei.me/2016/04/06/Connectivity-of-Graphs/"/>
    <id>https://blog.andrewei.me/2016/04/06/Connectivity-of-Graphs/</id>
    <published>2016-04-06T15:22:02.000Z</published>
    <updated>2018-04-09T01:16:07.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><a id="more"></a><ul><li><p><strong>连通图和非联通图</strong>： 如果无向图 G 中任意一对顶点都是连通的，则称此图是连通图（connected graph）；相反，如<br>果一个无向图不是连通图，则称为非连通图（disconnected graph）。对非连通图G，其极大连通子图称为连通分量（connected component，或连通分支），连通分支数记为w(G)。</p></li><li><p><strong>割顶集与连通度</strong>： 设V’是连通图G 的一个顶点子集，在G 中删去V’及与V’关联的边后图不连通，则称 V’ 是 G 的割顶集（vertex-cut set）。如果割顶集V’的任何真子集都不是割顶集，则称V’为极小割顶 集。顶点个数最小的极小割顶集称为最小割顶集。最小割顶集中顶点的个数，称作图G 的顶点连通度（vertex connectivity degree），记做κ(G)，且称图G 是κ–连通图（κ–connected graph）。</p></li><li><p><strong>割点</strong>：如果割顶集中只有一个顶点，则该顶点可以称为割点（cut-vertex），或关节点。</p></li><li><p><strong>点双连通图</strong>：如果一个无向连通图 G 没有关节点，或者说点连通度κ(G) &gt; 1，则称 G 为点双 连通图，或者称为重连通图。 </p></li><li><p><strong>点双连通分量</strong>：一个连通图 G 如果不是点双连通图，那么它可以包括几个点双连通分量，也 称为重连通分量（或块）。一个连通图的重连通分量是该图的极大重连通子图，在重连通分量中不存在关节点。 </p></li><li><p><strong>割边集与边连通度</strong>：设 E’ 是连通图 G 的边集的子集，在 G 中删去E’后图不连通，则称E’是G 的割边集 （edge-cut set）。如果割边集 E’ 的任何真子集都不是割边集，则称 E’ 为极小割边集。边数最小的极 小割边集称为最小割边集。最小割边集中边的个数，称作图G 的边连通度（edge connectivity degree），记做λ(G)，且称图G 是λ–边连通图（λ–edge–connected graph）。 </p></li><li><p><strong>割边</strong>：如果割边集中只有一条边，则该边可以称为割边（bridge），或桥。</p></li><li><p><strong>边双连通图</strong>：如果一个无向连通图 G 没有割边，或者说边连通度λ(G) &gt; 1，则称G 为边双连通图。</p></li><li><p><strong>边双连通分量</strong>：边双连通分量：一个连通图 G 如果不是边双连通图，那么它可以包括几个边双连通分量。一 个连通图的边双连通分量是该图的极大重连通子图，在边双连通分量中不存在割边。在连通图中， 把割边删除，则连通图变成了多个连通分量，每个连通分量就是一个边双连通分量。</p></li><li><p><strong>顶点连通性与边连通性的关系</strong>：（顶点连通度、边连通度与图的最小度的关系） 设G 为无向连通图，则存在关系式：$$κ(G) ≤ λ(G) ≤ δ(G)$$</p></li><li><p><strong>割边和割点的联系</strong>：（割边和割点的联系）设 v 是图 G 中与一条割边相关联的顶点，则 v 是 G 的割点当且仅当$$deg(v) ≥ 2$$</p></li></ul><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><ul><li><p><strong>强连通（strongly connected）</strong>：若 G 是有向图，如果对图 G 中任意两个顶点 u 和 v，既存在从 u 到 v 的路径，也存在从 v 到 u 的路径，则称该有向图为强连通有向图。对于非强连通图，其极 大强连通子图称为其强连通分量。</p></li><li><p><strong>单连通（simply connected）</strong>：若 G 是有向图，如果对图 G 中任意两个顶点 u 和 v，存在从 u 到 v 的路径或从 v 到 u 的路径，则称该有向图为单连通有向图。</p></li><li><p><strong>弱连通（weak connected）</strong>：若 G 是有向图，如果忽略图 G 中每条有向边的方向，得到的无向 图（即有向图的基图）连通，则称该有向图为弱连通有向图。</p></li></ul><h2 id="无向图点连通性的求解及应用"><a href="#无向图点连通性的求解及应用" class="headerlink" title="无向图点连通性的求解及应用"></a>无向图点连通性的求解及应用</h2><h3 id="求割点"><a href="#求割点" class="headerlink" title="求割点"></a>求割点</h3><p>Tarjan 算法只需从某个顶点出发进行一次遍历，就可以求得图中所有的关节点，因此其复杂度为O(n^2)。接下来以图(a)所示的无向图为例介绍这种方法。<br>在图(a)中，对该图从顶点 4 出发进行深度优先搜索，实线表示搜索前进方向，虚线表示 回退方向，顶点旁的数字标明了进行深度优先搜索时各顶点的访问次序，即深度优先数。在 DFS 搜索过程中，可以将各顶点的深度优先数记录在数组dfn 中。 图(b)是进行DFS 搜索后得到的根为顶点4 的深度优先生成树。为了更加直观地描述树形结 构，将此生成树改画成图(d)所示的树形形状。在图(d)中，还用虚线画出了两条虽然属于图G、但 不属于生成树的边，即(4, 5)和(6, 8)。 请注意：在深度优先生成树中，如果u 和v 是2 个顶点，且在生成树中u 是v 的祖先，则必 有dfn[u] &lt; dfn[v]，表明u 的深度优先数小于v，u 先于 v 被访问。<br><img src="/images/Connectivity-of-Graphs/1.png" alt=""><br>图G 中的边可以分为3 种：</p><ul><li>1) 生成树的边，如(2, 4)、(6, 7)等。</li><li>2) 回边（back edge）：图(d)中虚线所表示的非生成树的边，称为回边。当且仅当 u 在生成树中是 v 的祖先，或者 v 是 u 的祖先时，非生成树的边(u,v)才成为一条回边。如图(a)及图(d)中的(4, 5)、(6, 8)都是回边。 </li><li>3) 交叉边：除生成树的边、回边外，图G 中的其他边称为交叉边。<br>请特别注意：一旦生成树确定以后，那么原图中的边只可能是回边和生成树的边，交叉边实际上是不存在的。为什么？（说明：对有向图进行DFS 搜索后，非生成树的边可能是交叉边) 假设图G 中存在边(1, 10)，如图(c)所示，这就是所谓的交叉边，那么顶点10（甚至其他顶点都）只能位于顶点4 的左边这棵子树中。另外，如果在图G 中增加两条交叉边(1, 10)和(7, 9)，则图G 就是一个重连通图，如图(c)所示。</li></ul><blockquote><p>顶点u 是关节点的充要条件：<br>1) 如果顶点u 是深度优先搜索生成树的根，则u 至少有2 个子女。为什么呢？因为删除u，它的子女所在的子树就断开了，你不用担心这些子树之间（在原图中）可能存在边，因为交叉边是不存在的。</p></blockquote><blockquote><p>2) 如果 u 不是生成树的根，则它至少有一个子女 w，从 w 出发，不可能通过w、w 的子孙，以及一条回边组成的路径到达 u 的祖先。为什么呢？这是因为如果删除顶点 u 及其 所关联的边，则以顶点 w 为根的子树就从搜索树中脱离了。例如，顶点6 为什么是关节 点？这是因为它的一个子女顶点，如图(d)所示，即顶点7，不存在如前所述的路径到达顶点6 的祖先结点，这样，一旦顶点6 删除了，则以顶点7 为根结点的子树就断开了。 又如，顶点7 为什么不是关节点？这是因为它的所有子女顶点，当然在图(d)中只有顶点 8，存在如前所述的路径到达顶点7 的祖先结点，即顶点6，这样，一旦顶点7 删除了， 则以顶点8 为根结点的子树仍然跟图G 连通。</p></blockquote><p>因此，可对图 G 的每个顶点 u 定义一个 low 值：low[u]是从 u 或 u 的子孙出发通过回边可以到达的最低深度优先数。low[u]的定义如下： </p><blockquote><p>low[u] = Min<br>{<br>dfn[u],<br>Min{ low[w] | w 是u 的一个子女}, (8-2)<br>Min{ dfn[v] | v 与u 邻接，且(u,v)是一条回边 }<br>}</p></blockquote><p>即low[u]是取以上三项的最小值，其中：</p><ul><li>第1 项为它本身的深度优先数；</li><li>第2 项为它的（可能有多个）子女顶点w 的low[w]值的最小值，因为它的子女可以到达的最低深度优先数，则它也 可以通过子女到达；</li><li>第 3 项为它直接通过回边可以到达的最低优先数。</li></ul><p>因此，<strong>顶点u 是关节点的充要条件是：u 或者是具有两个以上子女的深度优先生成树的根， 或者虽然不是一个根，但它有一个子女w，使得 low[w]&gt;=dfn[u]。</strong><br>其中，“low[w]&gt;=dfn[u]”的含义是：顶点u 的子女顶点w，能够通过如前所述的路径到达顶 点的最低深度优先数大于等于顶点u 的深度优先数（注意在深度优先生成树中，顶点m 是顶点n 的祖先，则必有dfn[m] &lt; dfn[n]），即w 及其子孙不存在指向顶点u 的祖先的回边。这时删除顶点 u 及其所关联的边，则以顶点 w 为根的子树就从搜索树中脱离了。 每个顶点的深度优先数dfn[n]值可以在搜索前进时进行统计，而low[n]值是在回退的时候进行计算的。<br>接下来结合图和表解释在回退过程中计算每个顶点 n 的low[n]值的方法 (当前计算出来的low[n]值用粗体、斜体及下划线标明）：</p><ul><li>1) 在图(a)中，访问到顶点1 后，要回退，因为顶点1 没有子女顶点，所以low[1]就等于它的深度优先数dfn[1]，为5；</li><li>2) 从顶点1 回退到顶点5 后，要继续回退，此时计算顶点5 的low 值，因为顶点5 可以直接通过回边(5, 4)到达根结点，而根结点的深度优先数为1，所以顶点5 的low 值为1； </li><li>3) 从顶点5 回退到顶点3 后，要继续回退，此时计算顶点3 的low 值，因为它的子女顶点， 即顶点5 的low 值为1，则顶点3 的low 值也为1；</li><li>4) 从顶点3 回退到顶点2 后，要继续回退，此时计算顶点2 的low 值，因为它的子女顶点， 即顶点3 的low 值为1，则顶点2 的low 值也为1；</li><li><p>5) 从顶点2 回退到顶点4 后，要继续访问它的右子树中的顶点，此时计算顶点4 的low 值，因为它的子女顶点，即顶点2 的low 值为1，则顶点4 的low 值也为1； 根结点4 右子树在回退过程计算顶点的low[n]，方法类似。<br><img src="/images/Connectivity-of-Graphs/2.png" alt=""><br>求出关节点u 后，还有一个问题需要解决：去掉该关节点u，将原来的连通图分成了几个连通分量？答案是：</p></li><li><p>1) 如果关节点 u 是根结点，则有几个子女，就分成了几个连通分量；</p></li><li>2) 如果关节点 u 不是根结点，则有 d 个子女 w ，使得low[w] &gt;= dfn[u]，则去掉该结点，分成了d + 1 个连通分量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 res[i] &gt; 0 时说明 i 是割点， 并且去掉 i 之后图的连通分量的个数为 res[i];</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> son = <span class="number">0</span>;</span><br><span class="line">    dfn[u] = low[u] = ++tdfn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>((fa ^ <span class="number">1</span>) == i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v, i);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt;= dfn[u]) son++;</span><br><span class="line">        &#125;<span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u != root &amp;&amp; son) res[u] = son + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(u == root &amp;&amp; son &gt; <span class="number">1</span>) res[u] = son;</span><br><span class="line">    <span class="keyword">else</span> res[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line">root = <span class="number">1</span>;</span><br><span class="line">Tarjan(root, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><h3 id="点双连通分量的求解"><a href="#点双连通分量的求解" class="headerlink" title="点双连通分量的求解"></a>点双连通分量的求解</h3><p>在求关节点的过程中就能顺便把每个重连通分量求出。方法是：建立一个栈，存储当前重连通分量，在 DFS 过程中，每找到一条生成树的边或回边，就把这条边加入栈中。如果遇到某个顶点 u 的子女顶点 v 满足 dfn[u] &lt;= low[v]，说明 u 是一个割点，同时把边从栈顶一条条取出，直到遇到了边(u, v)，取出的这些边与其关联的顶点，组成一个重连通分量。割点可以属于多个重连通分量，其余顶点和每条边属于且只属于一个重连通分量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bcc_cnt 即连通分支数目</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    sta.push(u);</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    low[u] = dfn[u] = ++tdfn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>((fa ^ <span class="number">1</span>) == i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v, i);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;<span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">        bcc_cnt++;</span><br><span class="line">        <span class="keyword">int</span> top;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            top = sta.top();</span><br><span class="line">            sta.pop();</span><br><span class="line">            instack[top] = <span class="literal">false</span>;</span><br><span class="line">            belong[top] = bcc_cnt;</span><br><span class="line">        &#125;<span class="keyword">while</span>(u != top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶点连通度求解"><a href="#顶点连通度求解" class="headerlink" title="顶点连通度求解"></a>顶点连通度求解</h3><p>待补充。。。。</p><h3 id="割边的求解"><a href="#割边的求解" class="headerlink" title="割边的求解"></a>割边的求解</h3><p>割边的求解过程与求割点的过程类似，判断方法是：无向图中的一条边(u, v)是桥，当且仅当(u, v)为生成树中的边，且满足dfn[u] &lt; low[v]。<br>例如，图(a)所示的无向图，如果从顶点 4 开始进行DFS 搜索，各顶点的   <code>dfn[]</code> 值和 <code>low[]</code> 值如图(a)所示（每个顶点旁的两个数值分别表示 <code>dfn[]</code> 值和 <code>low[]</code> 值），深度优先搜索树如图(b)所 示。根据上述判断方法，可判断出边(1, 5)、(4, 6)、(8, 9)和(9, 10)为无向图中的割边。<br><img src="/images/Connectivity-of-Graphs/3.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求桥的模板， res数组存储的是桥的编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    low[u] = dfn[u] = ++tdfn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>((fa ^ <span class="number">1</span>) == i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v, i);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v] &gt; dfn[u]) res[cnt++] = edge[i].id;</span><br><span class="line">        &#125;<span class="keyword">else</span> low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用时  Tarjan(1, -1);</span></span><br></pre></td></tr></table></figure><h3 id="边双连通分量的求解"><a href="#边双连通分量的求解" class="headerlink" title="边双连通分量的求解"></a>边双连通分量的求解</h3><p>在求出所有的桥以后，把桥删除，原图变成了多个连通块，则每个连通块就是一个边双连通分量。桥不属于任何一个边双连通分量，其余的边和每个顶点都属于且只属于一个边双连通分量。 </p><h3 id="边连通度的求解"><a href="#边连通度的求解" class="headerlink" title="边连通度的求解"></a>边连通度的求解</h3><h2 id="有向图强连通性的求解及应用"><a href="#有向图强连通性的求解及应用" class="headerlink" title="有向图强连通性的求解及应用"></a>有向图强连通性的求解及应用</h2><h3 id="有向图强连通分量的求解算法"><a href="#有向图强连通分量的求解算法" class="headerlink" title="有向图强连通分量的求解算法"></a>有向图强连通分量的求解算法</h3><h4 id="Tarjan-算法"><a href="#Tarjan-算法" class="headerlink" title="Tarjan 算法"></a><strong>Tarjan 算法</strong></h4><p>Tarjan 算法是基于 DFS 算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索 树中未处理的节点加入一个栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。当 dfn(u) = low(u)时，以 u 为根的搜索子树上所有节点是一个强连通分量。<br>接下来以图(a)所示的有向图为例解释 Tarjan 算法的思想和执行过程，在该有向图中，{ 1, 2, 5, 3 }为一个强连通分量，{ 4 }、{ 6 }也分别是强连通分量。 图(b)为从顶点1 出发进行深度优先搜索后得到的深度优先搜索树。约定：如果某个顶点有多 个未访问过的邻接顶点，按顶点序号从小到大的顺序进行选择。各顶点旁边的两个数值分别为顶 点的深度优先数（dfn[]）值和low[]值。在图(b)中，虚线表示非生成树的边，其中边&lt;5, 6&gt;为交 叉边，边&lt;5, 1&gt;和&lt;3, 5&gt;是回边<br><img src="/images/Connectivity-of-Graphs/4.png" alt=""><br>图(c)～(f)演示了 Tarjan 算法的执行过程。在图(c)中，沿着实线箭头所指示的方向搜索到顶点 6，此时无法再前进下去了，并且因为此时 dfn[6] = low[6] = 4，所以找到了一个强连通分量。退栈到u == v 为止，{ 6 }为一个强连通分量。<br>在图(d)中，沿着虚线箭头所指示的方向回退到顶点4，发现dfn[4] == low[4]，为3，退栈后{ 4 } 为一个强连通分量。<br>在图(e)中，回退到顶点2 并继续搜索到顶点5，把顶点5 加入栈。发现顶点5 有到顶点 1 的有向边，顶点 1 还在栈中，所以 low[5] = 1，有向边 &lt;5, 1&gt; 为回边。顶点 6 已经出栈，所以 &lt;5, 6&gt; 是交叉边，返回顶点 2，&lt;2, 5&gt;为生成树的边，所以low[2] = low[5] = 1。<br>在图(f)中，先回退到顶点 1，接着访问顶点 3。发现顶点 3 到顶点有一条有向边，顶点 5 已经访问过了、且 5 还在栈中，因此边 &lt;3, 5&gt; 为回边，所以low[3] = dfn[5] = 5。返回顶点 1 后，发现 dfn[1] == low[1]，把栈中的顶点全部弹出，组成一个连通分量{ 3, 5, 2, 1 }。 至此，Tarjan 算法结束，求出了图中全部的三个强连通分量为{ 6 }、{ 4 }和{ 3, 5, 2, 1 }。<br>Tarjan 算法的时间复杂度分析：假设用邻接表存储图，在 Tarjan 算法的执行过程中，每个顶点都被访问了一次，且只进出了一次栈，每条边也只被访问了一次，所以该算法的时间复杂度为 O(n + m)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码模板</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sta.push(u);</span><br><span class="line">    instack[u] = <span class="literal">true</span>;</span><br><span class="line">    dfn[u] = low[u] = ++tdfn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(instack[v]) low[u] = min(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u] == dfn[u])&#123;</span><br><span class="line">        <span class="keyword">int</span> top;</span><br><span class="line">        scc_cnt++;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            top = sta.top();</span><br><span class="line">            sta.pop();</span><br><span class="line">            instack[top] = <span class="literal">false</span>;</span><br><span class="line">            belong[top] = scc_cnt;</span><br><span class="line">        &#125;<span class="keyword">while</span>(u != top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br></pre></td></tr></table></figure></p><h4 id="Kosaraju-算法"><a href="#Kosaraju-算法" class="headerlink" title="Kosaraju 算法"></a><strong>Kosaraju 算法</strong></h4><p>Kosaraju 算法是基于对有向图 G 及其逆图 GT（各边反向得到的有向图）进行两次 DFS 的方 法，其时间复杂度也是 O(n + m)。与 Trajan 算法相比，Kosaraju 算法的思想更为直观。<br>Kosaraju 算法的原理为：如果有向图 G 的一个子图 G’ 是强连通子图，那么各边反向后没有任何影响，G’ 内各顶点间仍然连通，G’ 仍然是强连通子图。但如果子图G’是单向连通的，那么各边反向后可能某些顶点间就不连通了，因此，各边的反向处理是对非强连通块的过滤。<br>Kosaraju 算法的执行过程为：</p><ul><li>(1) 对原图G 进行深度优先搜索，并记录每个顶点的 dfn[] 值。</li><li>(2) 将图G 的各边进行反向，得到其逆图GT。</li><li>(3) 选择从当前dfn[ ]值最大的顶点出发，对逆图GT 进行DFS 搜索，删除能够遍历到的顶点，这些顶点构成一个强连通分量。</li><li>(4) 如果还有顶点没有删除，继续执行第(3)步，否则算法结束。<br>接下来以图(a)所示的有向图 G 为例分析 Kosaraju 算法的执行过程。图(b)为正向搜索过程，搜索完毕后，得到各顶点的 dfn[ ]值。图(c)为逆图GT。图(d)为从顶点3 出发对逆图GT 进行 DFS 搜索，得到第1 个强连通分量{ 1, 2, 5, 3 }，图(e)和(f)分别从顶点4 和6 出发进行DFS 搜索得到另外两个强连通分量。<br><img src="/images/Connectivity-of-Graphs/5.png" alt=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法模板</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(!vis[edge[i].v]) dfs(edge[i].v);</span><br><span class="line">    vs[vscnt++] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    belong[u] = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = rhead[u]; i + <span class="number">1</span>; i = redge[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(!vis[redge[i].v]) rdfs(redge[i].v, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    vscnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) dfs(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> scc_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = vscnt - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(!vis[vs[i]]) rdfs(vs[i], scc_cnt++);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> scc_cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="连通性算法的应用2-SAT"><a href="#连通性算法的应用2-SAT" class="headerlink" title="连通性算法的应用2_SAT"></a>连通性算法的应用2_SAT</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>现有一个由 N 个布尔值组成的序列 A，给出一些限制关系，比如 A[x] AND A[y]=0 A[x] OR A[y] OR A[z] = 1 等，要确定 A[0..N-1] 的值，使得其满足所有限制关系。这个称为 SAT 问题，特别的，若每种限制关系中最多只对两个元素进行限制，则称为 2-SAT 问题。</p><h3 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h3><p>由于在2-SAT问题中，最多只对两个元素进行限制，所以可能的限制关系共有11种：<br>A[x]<br>NOT A[x]<br>A[x] AND A[y]<br>A[x] AND NOT A[y]<br>A[x] OR A[y]<br>A[x] OR NOT A[y]<br>NOT (A[x] AND A[y])<br>NOT (A[x] OR A[y])<br>A[x] XOR A[y]<br>NOT (A[x] XOR A[y])<br>A[x] XOR NOT A[y]<br>进一步，A[x] AND A[y]相当于(A[x]) AND (A[y])（也就是可以拆分成A[x]与A[y]两个限制关系），NOT(A[x] OR A[y])相当于NOT A[x] AND NOT A[y]（也就是可以拆分成NOT A[x]与NOT A[y]两个限制关系）。因此，可能的限制关系最多只有9种。</p><p>在实际问题中，2-SAT问题在大多数时候表现成以下形式：有N对物品，每对物品中必须选取一个，也只能选取一个，并且它们之间存在某些限制关系（如某两个物品不能都选，某两个物品不能都不选，某两个物品必须且只能选一个，某个物品必选）等，这时，可以将每对物品当成一个布尔值（选取第一个物品相当于0，选取第二个相当于1），如果所有的限制关系最多只对两个物品进行限制，则它们都可以转化成9种基本限制关系，从而转化为2-SAT模型。</p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>其实 2-SAT 问题的建模是和实际问题非常相似的。建立一个 2N 阶的有向图，其中的点分为 N 对，每对点表示布尔序列 A 的一个元素的 0、1 取值（以下将代表 A[i] 的 0 取值的点称为 i，代表 A[i] 的 1 取值的点称为i’）。显然每对点必须且只能选取一个。然后，图中的边具有特定含义。若图中存在边 &lt;i, j&gt;，则表示若选了 i 必须选 j。可以发现，上面的 9 种限制关系中，后7种二元限制关系都可以用连边实现，比如NOT(A[x] AND A[y])需要连两条边&lt;x, y’&gt;和&lt;y, x’&gt;，A[x] OR A[y]需要连两条边&lt;x’, y&gt;和&lt;y’, x&gt;。而前两种一元关系，对于A[x]（即x必选），可以通过连边<x', x="">来实现，而NOT A[x]（即x不能选），可以通过连边<x, x'="">来实现。</x,></x',></p><h3 id="O-NM-算法：求字典序最小的解"><a href="#O-NM-算法：求字典序最小的解" class="headerlink" title="O(NM)算法：求字典序最小的解"></a>O(NM)算法：求字典序最小的解</h3><p>根据 2-SAT 建成的图中边的定义可以发现，若图中 i 到 j 有路径，则若 i 选，则 j 也要选；或者说，若 j 不选，则 i 也不能选；<br>因此得到一个很直观的算法：</p><ul><li><p>（1）给每个点设置一个状态 V，V = 0 表示未确定，V = 1 表示确定选取，V = 2 表示确定不选取。称一个点是已确定的当且仅当其 V 值非 0。设立两个队列 Q1 和 Q2，分别存放本次尝试选取的点的编号和尝试不选的点的编号。</p></li><li><p>（2）若图中所有的点均已确定，则找到一组解，结束，否则，将 Q1、Q2 清空，并任选一个未确定的点 i，将 i 加入队列 Q1，将 i’ 加入队列 Q2；</p></li><li><p>（3）找到 i 的所有后继。对于后继 j，若 j 未确定，则将 j 加入队列 Q1；若 j’（这里的 j’ 是指与 j 在同一对的另一个点）未确定，则将 j’ 加入队列 Q2；</p></li><li><p>（4）遍历 Q2 中的每个点，找到该点的所有前趋（这里需要先建一个补图），若该前趋未确定，则将其加入队列 Q2；</p></li><li><p>（5）在（3）（4）步操作中，出现以下情况之一，则本次尝试失败，否则本次尝试成功：</p><ul><li><1>某个已被加入队列 Q1 的点被加入队列 Q2;</1></li><li><2>某个已被加入队列 Q2 的点被加入队列 Q1;</2></li><li><3>某个 j 的状态为 2；</3></li><li><4>某个 i’ 或 j’ 的状态为 1 或某个 i’ 或 j’ 的前趋的状态为 1 ;</4></li></ul></li><li><p>（6）若本次尝试成功，则将Q1中的所有点的状态改为1，将Q2中所有点的状态改为2，转（2），否则尝试点i’，若仍失败则问题无解。</p></li></ul><p>该算法的时间复杂度为 O(NM)（最坏情况下要尝试所有的点，每次尝试要遍历所有的边），但是在多数情况下，远远达不到这个上界。<br>具体实现时，可以用一个数组 vst 来表示队列 Q1 和 Q2。设立两个标志变量 i1 和 i2（要求对于不同的 i，i1 和 i2 均不同，这样可以避免每次尝试都要初始化一次，节省时间），若 vst[i] = i1 则表示 i 已被加入 Q1，若 vst[i] = i2 则表示 i 已被加入 Q2。不过 Q1 和 Q2 仍然是要设立的，因为遍历（BFS）的时候需要队列，为了防止重复遍历，加入 Q1（或Q2）中的点的 vst 值必然不等于 i1（或i2）。中间一旦发生矛盾，立即中止尝试，宣告失败。</p><p>该算法虽然在多数情况下时间复杂度到不了 O(NM)，但是综合性能仍然不如下面的 O(M) 算法。不过，该算法有一个很重要的用处：求字典序最小的解！<br>如果原图中的同一对点编号都是连续的（01、23、45……）则可以依次尝试第 0 对、第 1 对……点，每对点中先尝试编号小的，若失败再尝试编号大的。这样一定能求出字典序最小的解（如果有解的话），因为一个点一旦被确定，则不可更改。<br>如果原图中的同一对点编号不连续（比如03、25、14……）则按照该对点中编号小的点的编号递增顺序将每对点排序，然后依次扫描排序后的每对点，先尝试其编号小的点，若成功则将这个点选上，否则尝试编号大的点，若成功则选上，否则（都失败）无解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板代码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HDU 1814</span></span><br><span class="line"><span class="comment">求出字典序最小的解</span></span><br><span class="line"><span class="comment">C++ 2652ms 2316K</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">16010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">100000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,pre,next;</span><br><span class="line">&#125;E[MAXM],E2[MAXM];</span><br><span class="line"><span class="keyword">int</span> _n,n,m;</span><br><span class="line"><span class="keyword">int</span> V[MAXN],ST[MAXN][<span class="number">2</span>],Q[MAXN],Q2[MAXN],vst[MAXN];</span><br><span class="line"><span class="keyword">bool</span> res_ex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_d</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">      E[i].a=E[i].pre=E[i].next=E2[i].a=E2[i].pre=E2[i].next=i;</span><br><span class="line">    m=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[m].a=a;E[m].b=b;E[m].pre=E[a].pre;E[m].next=a;E[a].pre=m;E[E[m].pre].next=m;</span><br><span class="line">    E2[m].a=b;E2[m].b=a;E2[m].pre=E2[b].pre;E2[m].next=b;E2[b].pre=m;E2[E2[m].pre].next=m;</span><br><span class="line">    m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        V[i]=<span class="number">0</span>;</span><br><span class="line">        vst[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res_ex=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i,i1,i2,j,k,front,rear,front2,rear2;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">bool</span> ff;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _i=<span class="number">0</span>;_i&lt;_n;_i++)</span><br><span class="line">    &#123;<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span>(V[_i&lt;&lt;<span class="number">1</span>]==<span class="number">1</span>||V[(_i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>]==<span class="number">1</span>)<span class="keyword">continue</span>;<span class="comment">//找一对未确定的点</span></span><br><span class="line">        i=_i&lt;&lt;<span class="number">1</span>;len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!V[i])</span><br><span class="line">        &#123;<span class="comment">//3</span></span><br><span class="line">            ST[len][<span class="number">0</span>]=i;</span><br><span class="line">            ST[len++][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!V[i^<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                ST[len][<span class="number">0</span>]=i^<span class="number">1</span>;</span><br><span class="line">                ST[len++][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q[front=rear=<span class="number">0</span>]=i;</span><br><span class="line">            vst[i]=i1=n+i;</span><br><span class="line">            Q2[front2=rear2=<span class="number">0</span>]=i^<span class="number">1</span>;</span><br><span class="line">            vst[i^<span class="number">1</span>]=i2=(n&lt;&lt;<span class="number">1</span>)+i;</span><br><span class="line">            ff=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(;front&lt;=rear;front++)</span><br><span class="line">            &#123;<span class="comment">//4</span></span><br><span class="line">                j=Q[front];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=E[j].next;p!=j;p=E[p].next)</span><br><span class="line">                &#123;<span class="comment">//5</span></span><br><span class="line">                    k=E[p].b;</span><br><span class="line">                    <span class="keyword">if</span>(V[k]==<span class="number">2</span>||vst[k]==i2||V[k^<span class="number">1</span>]==<span class="number">1</span>||vst[k^<span class="number">1</span>]==i1)</span><br><span class="line">                    &#123;ff=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                    <span class="keyword">if</span>(vst[k]!=i1)</span><br><span class="line">                    &#123;<span class="comment">//6</span></span><br><span class="line">                        Q[++rear]=k;vst[k]=i1;</span><br><span class="line">                        <span class="keyword">if</span>(!V[k])</span><br><span class="line">                        &#123;</span><br><span class="line">                            ST[len][<span class="number">0</span>]=k;</span><br><span class="line">                            ST[len++][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">//6</span></span><br><span class="line">                    <span class="keyword">if</span>(vst[k^<span class="number">1</span>]!=i2)</span><br><span class="line">                    &#123;<span class="comment">//6</span></span><br><span class="line">                        Q2[++rear2]=k^<span class="number">1</span>;vst[k^<span class="number">1</span>]=i2;</span><br><span class="line">                        <span class="keyword">if</span>(!V[k])</span><br><span class="line">                        &#123;</span><br><span class="line">                            ST[len][<span class="number">0</span>]=k^<span class="number">1</span>;</span><br><span class="line">                            ST[len++][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">//6</span></span><br><span class="line">                &#125;<span class="comment">//5</span></span><br><span class="line">                <span class="keyword">if</span>(!ff)<span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//4</span></span><br><span class="line">            <span class="keyword">if</span>(ff)</span><br><span class="line">            &#123;<span class="comment">//4</span></span><br><span class="line">                <span class="keyword">for</span>(;front2&lt;=rear2;front2++)</span><br><span class="line">                &#123;<span class="comment">//5</span></span><br><span class="line">                    j=Q2[front2];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> p=E2[j].next;p!=j;p=E2[p].next)</span><br><span class="line">                    &#123;<span class="comment">//6</span></span><br><span class="line">                        k=E2[p].b;</span><br><span class="line">                        <span class="keyword">if</span>(V[k]==<span class="number">1</span>||vst[k]==i1)</span><br><span class="line">                        &#123;ff=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                        <span class="keyword">if</span>(vst[k]!=i2)</span><br><span class="line">                        &#123;</span><br><span class="line">                            vst[k]=i2;Q2[++rear]=k;</span><br><span class="line">                            <span class="keyword">if</span>(!V[k])</span><br><span class="line">                            &#123;</span><br><span class="line">                                ST[len][<span class="number">0</span>]=k;</span><br><span class="line">                                ST[len++][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">//6</span></span><br><span class="line">                    <span class="keyword">if</span>(!ff)<span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="comment">//5</span></span><br><span class="line">                <span class="keyword">if</span>(ff)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)V[ST[j][<span class="number">0</span>]]=ST[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//4</span></span><br><span class="line">        &#125;<span class="comment">//3</span></span><br><span class="line">        i=(_i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;len=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//********************************************</span></span><br><span class="line"><span class="comment">//下面这段和上面完全一样的，可以复制。但是要保证上面写对</span></span><br><span class="line"><span class="comment">//********************************************</span></span><br><span class="line">        <span class="keyword">if</span>(!V[i])</span><br><span class="line">        &#123;<span class="comment">//3</span></span><br><span class="line">            ST[len][<span class="number">0</span>]=i;</span><br><span class="line">            ST[len++][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!V[i^<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                ST[len][<span class="number">0</span>]=i^<span class="number">1</span>;</span><br><span class="line">                ST[len++][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q[front=rear=<span class="number">0</span>]=i;</span><br><span class="line">            vst[i]=i1=n+i;</span><br><span class="line">            Q2[front2=rear2=<span class="number">0</span>]=i^<span class="number">1</span>;</span><br><span class="line">            vst[i^<span class="number">1</span>]=i2=(n&lt;&lt;<span class="number">1</span>)+i;</span><br><span class="line">            ff=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(;front&lt;=rear;front++)</span><br><span class="line">            &#123;<span class="comment">//4</span></span><br><span class="line">                j=Q[front];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=E[j].next;p!=j;p=E[p].next)</span><br><span class="line">                &#123;<span class="comment">//5</span></span><br><span class="line">                    k=E[p].b;</span><br><span class="line">                    <span class="keyword">if</span>(V[k]==<span class="number">2</span>||vst[k]==i2||V[k^<span class="number">1</span>]==<span class="number">1</span>||vst[k^<span class="number">1</span>]==i1)</span><br><span class="line">                    &#123;ff=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                    <span class="keyword">if</span>(vst[k]!=i1)</span><br><span class="line">                    &#123;<span class="comment">//6</span></span><br><span class="line">                        Q[++rear]=k;vst[k]=i1;</span><br><span class="line">                        <span class="keyword">if</span>(!V[k])</span><br><span class="line">                        &#123;</span><br><span class="line">                            ST[len][<span class="number">0</span>]=k;</span><br><span class="line">                            ST[len++][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">//6</span></span><br><span class="line">                    <span class="keyword">if</span>(vst[k^<span class="number">1</span>]!=i2)</span><br><span class="line">                    &#123;<span class="comment">//6</span></span><br><span class="line">                        Q2[++rear2]=k^<span class="number">1</span>;vst[k^<span class="number">1</span>]=i2;</span><br><span class="line">                        <span class="keyword">if</span>(!V[k])</span><br><span class="line">                        &#123;</span><br><span class="line">                            ST[len][<span class="number">0</span>]=k^<span class="number">1</span>;</span><br><span class="line">                            ST[len++][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">//6</span></span><br><span class="line">                &#125;<span class="comment">//5</span></span><br><span class="line">                <span class="keyword">if</span>(!ff)<span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//4</span></span><br><span class="line">            <span class="keyword">if</span>(ff)</span><br><span class="line">            &#123;<span class="comment">//4</span></span><br><span class="line">                <span class="keyword">for</span>(;front2&lt;=rear2;front2++)</span><br><span class="line">                &#123;<span class="comment">//5</span></span><br><span class="line">                    j=Q2[front2];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> p=E2[j].next;p!=j;p=E2[p].next)</span><br><span class="line">                    &#123;<span class="comment">//6</span></span><br><span class="line">                        k=E2[p].b;</span><br><span class="line">                        <span class="keyword">if</span>(V[k]==<span class="number">1</span>||vst[k]==i1)</span><br><span class="line">                        &#123;ff=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">                        <span class="keyword">if</span>(vst[k]!=i2)</span><br><span class="line">                        &#123;</span><br><span class="line">                            vst[k]=i2;Q2[++rear]=k;</span><br><span class="line">                            <span class="keyword">if</span>(!V[k])</span><br><span class="line">                            &#123;</span><br><span class="line">                                ST[len][<span class="number">0</span>]=k;</span><br><span class="line">                                ST[len++][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">//6</span></span><br><span class="line">                    <span class="keyword">if</span>(!ff)<span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="comment">//5</span></span><br><span class="line">                <span class="keyword">if</span>(ff)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)V[ST[j][<span class="number">0</span>]]=ST[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//4</span></span><br><span class="line">        &#125;<span class="comment">//3</span></span><br><span class="line"><span class="comment">//**************************************************************</span></span><br><span class="line">        <span class="keyword">if</span>(V[_i&lt;&lt;<span class="number">1</span>]+V[(_i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>]!=<span class="number">3</span>)&#123;res_ex=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;<span class="comment">//2</span></span><br><span class="line">&#125;<span class="comment">//1</span></span><br><span class="line"><span class="comment">//点的编号必须从0开始，2*i和2*i+1是一对sat</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;_n,&amp;M)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        n=_n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        init_d();</span><br><span class="line">        <span class="keyword">while</span>(M--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            x--;</span><br><span class="line">            y--;</span><br><span class="line">            <span class="keyword">if</span>(x!=(y^<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                add_edge(x,y^<span class="number">1</span>);</span><br><span class="line">                add_edge(y,x^<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="keyword">if</span>(res_ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//V为0为不确定，1为确定选择，2为确定不选择</span></span><br><span class="line">            <span class="keyword">if</span>(V[i]==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NIE\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//网上另解</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">const int MAXN = 16005;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct Edge&#123;</span></span><br><span class="line"><span class="comment">    int v, nxt;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int cnt, ecnt, n, m;</span></span><br><span class="line"><span class="comment">Edge edge[4 * MAXN];</span></span><br><span class="line"><span class="comment">int head[MAXN], col[MAXN], res[MAXN];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void init()&#123;</span></span><br><span class="line"><span class="comment">    cnt = ecnt = 0;</span></span><br><span class="line"><span class="comment">    memset(res, 0, sizeof(res));</span></span><br><span class="line"><span class="comment">    memset(col, 0, sizeof(col));</span></span><br><span class="line"><span class="comment">    memset(edge, 0, sizeof(edge));</span></span><br><span class="line"><span class="comment">    memset(head, -1, sizeof(head));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void addEdge(int u, int v)&#123;</span></span><br><span class="line"><span class="comment">    edge[ecnt].v = v;</span></span><br><span class="line"><span class="comment">    edge[ecnt].nxt = head[u];</span></span><br><span class="line"><span class="comment">    head[u] = ecnt++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">bool dfs(int u)&#123;</span></span><br><span class="line"><span class="comment">    if(col[u] == 2) return false;</span></span><br><span class="line"><span class="comment">    if(col[u] == 1) return true;</span></span><br><span class="line"><span class="comment">    col[u] = 1;</span></span><br><span class="line"><span class="comment">    col[u ^ 1] = 2;</span></span><br><span class="line"><span class="comment">    res[cnt++] = u;</span></span><br><span class="line"><span class="comment">    for(int i = head[u]; i + 1; i = edge[i].nxt)&#123;</span></span><br><span class="line"><span class="comment">        int v = edge[i].v;</span></span><br><span class="line"><span class="comment">        if(!dfs(v)) return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">bool solve()&#123;</span></span><br><span class="line"><span class="comment">    memset(col, 0, sizeof(col));</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line"><span class="comment">        if(col[i]) continue;</span></span><br><span class="line"><span class="comment">        cnt = 0;</span></span><br><span class="line"><span class="comment">        if(!dfs(i))&#123;</span></span><br><span class="line"><span class="comment">            for(int j = 0; j &lt; cnt; j++)&#123;</span></span><br><span class="line"><span class="comment">                col[res[j]] = 0;</span></span><br><span class="line"><span class="comment">                col[res[j] ^ 1] = 0;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(!dfs(i ^ 1)) return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    while(scanf("%d%d", &amp;n, &amp;m) != EOF)&#123;</span></span><br><span class="line"><span class="comment">        init();</span></span><br><span class="line"><span class="comment">        n &lt;&lt;= 1;</span></span><br><span class="line"><span class="comment">        int u, v;</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; m; i++)&#123;</span></span><br><span class="line"><span class="comment">            scanf("%d%d", &amp;u, &amp;v);</span></span><br><span class="line"><span class="comment">            u--, v--;</span></span><br><span class="line"><span class="comment">            addEdge(u, v ^ 1);</span></span><br><span class="line"><span class="comment">            addEdge(v, u ^ 1);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(solve())&#123;</span></span><br><span class="line"><span class="comment">            for(int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">                if(col[i] == 1) printf("%d\n", i + 1);</span></span><br><span class="line"><span class="comment">        &#125; else printf("NIE\n");</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="只输出一组可行解-O-n-m"><a href="#只输出一组可行解-O-n-m" class="headerlink" title="只输出一组可行解(O(n + m))"></a>只输出一组可行解(O(n + m))</h3><p>根据《挑战程序设计竞赛》的说法，如果不存在 x 与 NOTx 同在一个强连通分量， 那么对于每一个布尔变量 x , 让 $$ x 所在的强连通分量的拓扑序在 NOTx 所在的强连通分量之后 &lt;=&gt; x 为真 $$ 就是使得该公式的值为真的一组合适的布尔变量赋值。</p><h3 id="一些例题"><a href="#一些例题" class="headerlink" title="一些例题"></a>一些例题</h3><h4 id="POJ-2117"><a href="#POJ-2117" class="headerlink" title="POJ 2117"></a><a href="http://poj.org/submit?problem_id=2117" target="_blank" rel="noopener">POJ 2117</a></h4><p>未完待续。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;无向图&quot;&gt;&lt;a href=&quot;#无向图&quot; class=&quot;headerlink&quot; title=&quot;无向图&quot;&gt;&lt;/a&gt;无向图&lt;/h3&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="图论" scheme="https://blog.andrewei.me/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="连通性" scheme="https://blog.andrewei.me/tags/%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL简介</title>
    <link href="https://blog.andrewei.me/2016/04/06/cppSTL/"/>
    <id>https://blog.andrewei.me/2016/04/06/cppSTL/</id>
    <published>2016-04-06T12:19:31.000Z</published>
    <updated>2018-04-09T01:16:07.246Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自: <a href="https://www.zybuluo.com/comzyh/note/138935" target="_blank" rel="noopener">https://www.zybuluo.com/comzyh/note/138935</a></p><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><p>推荐大家去这些网站查询自己需要的东西</p><ul><li><a href="http://www.cplusplus.com/reference/" target="_blank" rel="noopener">cpluscplus</a></li><li><a href="http://en.cppreference.com/w/" target="_blank" rel="noopener">cppreference</a></li><li><a href="http://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">cppreferne中文</a></li></ul><p>STL中有很多好用的容器和算法，非常好用。<br>简单介绍一下</p><a id="more"></a><ul><li><code>vector</code> 向量(可以理解成可变长数组)</li><li><code>utility</code> (pair)</li><li><code>algorithm</code> (sort)</li><li><code>queue 队列</code> (queue，priority_queue)</li><li><code>list</code> (链表)</li><li><code>map</code> (key-value映射)</li><li><code>bitset</code> (用int各位表示的数组)</li></ul><h2 id="C-模板简单介绍"><a href="#C-模板简单介绍" class="headerlink" title="C++ 模板简单介绍"></a>C++ 模板简单介绍</h2><p>我们来看看 cplusplus 上对 <a href="http://www.cplusplus.com/reference/vector/" target="_blank" rel="noopener">vector</a> 的介绍</p><blockquote><p>template &lt; class T, class Alloc = allocator &gt; class vector; // generic template</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr; </span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; ponints; <span class="comment">// 注意那个空格</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; reflect;</span><br></pre></td></tr></table></figure><p>使用typedef 可以缩短代码长度，但是会降低可读性<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; points;</span><br></pre></td></tr></table></figure></p><h3 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h3><p>迭代器是C++的重要组成部分，但是这里不细讲，只是很多STL容器的方法都返回迭代器，不对迭代器有些了解是不行的<br>比如遍历一个 <code>vector</code>，可以这么做</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;:: it=n.begin();it!=n.end();it++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>访问 <code>iterator</code> 指向的内容可以直接用 <code>*it</code> 访问，如果访问其成员的话，也可以用 <code>-&gt;</code> 访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; points;</span><br><span class="line"><span class="keyword">for</span> （<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator = n.begin();it != n.end();it++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"x: "</span> &lt;&lt;  it-&gt;first &lt;&lt; <span class="string">"y: "</span> &lt;&lt; (*it).second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>当然，我们平常是不会这么遍历数组的，这里只是演示下 <code>iterator</code> 的用法</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 是C++中最常用的数据结构，相当于可变长数组，效率和使用数组没有明显差别<br>cpluscplus 上对 <a href="http://www.cplusplus.com/reference/vector/" target="_blank" rel="noopener">vector</a> 的介绍</p><p>常见用法，建立邻接表样例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tab[MAXN+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        tab[i].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;M；i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        tab[a].push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一看上面发生了什么</p><p>声明: <code>vector&lt;int&gt; arrary</code> ;声明了一个 <code>vector</code> ，而 <code>vector&lt;int&gt; tab[101]</code>  则声明了一个 vector 的数组，访问5点能引出的第0条边使用 <code>tab[5][0]</code> 就可以了<br><code>tab[i].clear</code> 是将一个 vector 清空。 这一句在这个程序里是没有用的，但是很多题目需要多组输入输出，上一个Case的邻接表没有清空是要死得很惨的。<br><code>tab[a].push_back(b)</code>  在 <code>vector tab[a]</code> 最后添加一个元素，值为 b 如何使用这张邻接表呢</p><p>遍历a点所有连接的点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vecotr&lt;<span class="keyword">int</span>&gt; tab[<span class="number">100</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;tab[a].size();i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tab[a][i] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>注意坑<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= tab[a].size()<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>这样是有可能会跪掉的，因为 <code>vector</code> 的 <code>size()</code> 返回的是一个 <code>size_t</code> 也就是 <code>unsigned int</code> ，即32位无符号数 类型，这样如果 <code>vector</code> 为空的话，<code>size()</code> 返回 <code>0</code>，然而32位无符号数 <code>0 - 1 = 4294967295</code>，这样会导致访问越界然后开心的RE掉</p><h4 id="其他重要的成员"><a href="#其他重要的成员" class="headerlink" title="其他重要的成员"></a>其他重要的成员</h4><ul><li><code>vector::resize()</code> 如果你想立即得到一个长度为100的数组而不想一个一个push_bakc进去的话，直接 <code>xxx.resize(100)</code> 就好了</li><li><code>vector::begin()</code> 返回首个元素的迭代器</li><li><code>vector::end()</code> 返回终止位置的迭代器，注意并非指向最后一个元素，而是比最后一个元素还要往后一个元素的位置</li></ul><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a><a href="http://www.cplusplus.com/reference/utility/" target="_blank" rel="noopener">pair</a></h3><p>使用 <code>pair</code> 需要 <code>#include &lt;utility&gt;</code></p><p><code>pair</code> 代表的是数据对，可以用来表示二维坐标(x，y)，图中的边之类的东西，<code>pair</code> 的两个分量类型可以不同，像下面这样。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; point; <span class="comment">//藐视一个点</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; name_and_id_pair; <span class="comment">// 学生姓名和学号</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; id_to_height pair; <span class="comment">// 学生学号和身高</span></span><br></pre></td></tr></table></figure></p><h4 id="如何制造-pair"><a href="#如何制造-pair" class="headerlink" title="如何制造 pair"></a>如何制造 pair</h4><p>常用的方式有构造函数法和make_pair<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; point1 = make_pair(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; point2 = make_pair(<span class="number">2.0</span>,<span class="number">3.0</span>);</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; point3 = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; point4 = make_pair(<span class="number">1.0</span>,<span class="number">2.0</span>); <span class="comment">// 这句会编译失败，因为make出来的是pair&lt;double,double&gt; 却赋值给了pair&lt;int,int&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="如何使用-pair"><a href="#如何使用-pair" class="headerlink" title="如何使用 pair"></a>如何使用 pair</h4><p><code>pair</code> 有两个主要成员 <code>first</code> 和 <code>second</code>，类型分别和为 <code>pair</code> 里 <code>U</code>，<code>V</code> 的类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; yz = make_pair(<span class="number">1</span>, <span class="number">179.99999</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; yz.first &lt;&lt; <span class="string">":"</span> &lt;&lt; yz.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(yz.first) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="keyword">sizeof</span>(yz.second) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>输出</p><blockquote><p>1:179.999<br>4 8</p></blockquote><h3 id="sort-的姿势"><a href="#sort-的姿势" class="headerlink" title="sort 的姿势"></a>sort 的姿势</h3><p><code>cplusplus</code> 上关于 <a href="http://www.cplusplus.com/reference/algorithm/sort/" target="_blank" rel="noopener">srot</a> 的页面<br><code>sort</code> 是 <code>STL</code> 里面一个非常重要的算法函数，排序效率非常高，几乎在任何时候都不会需要手敲，所以，需要排序的时候，用 <code>sort</code> 吧！</p><p><code>std::sort</code> 需要 <code>#include &lt;algorithm&gt;</code></p><h4 id="基本排序姿势"><a href="#基本排序姿势" class="headerlink" title="基本排序姿势"></a><strong>基本排序姿势</strong></h4><p>第一种用法原型如下，传入两个 <code>RandomAccessIterator</code>，对 <code>[first,last)</code>区间的元素进行排序，<strong>注意区间左闭右开</strong>，也就是<strong>传入的 <code>last</code> 迭代器指向的位置不会参与排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span> (<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>);</span></span><br></pre></td></tr></table></figure><p>对 <code>int</code> 数组从大到小排序<br>因为指针也是 <code>RandomAccessIterator</code> 的一种，所以 <code>sort</code> 直接传入指针就好了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> arr[N];</span><br><span class="line">sort(arr , arr + N); <span class="comment">// 注意arr + N 指向的位置已经越界，但是sort传入的last参数就是指向最后一个元素后的一个位置</span></span><br></pre></td></tr></table></figure><h4 id="排序vector"><a href="#排序vector" class="headerlink" title="排序vector"></a><strong>排序vector</strong></h4><p><code>vector</code> 直接能返回迭代器，很方便</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</span><br><span class="line">sort(<span class="built_in">array</span>.begin(), <span class="built_in">array</span>.end());</span><br></pre></td></tr></table></figure><h4 id="从大到小排序"><a href="#从大到小排序" class="headerlink" title="从大到小排序"></a><strong>从大到小排序</strong></h4><p>我们来看看 sort 的第二个原型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">sort</span> (<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">Compare</span> <span class="title">comp</span>);</span></span><br></pre></td></tr></table></figure></p><p>这里出现了第三个参数 <code>Compare comp comp</code> 是一个比较器，可以有很多种玩法<br>如果我们想从大到小排序，把 <code>greater</code> 比较器传给<code>sort</code> 就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; height;</span><br><span class="line">sort(height.begin(), begin.end(), greater&lt;<span class="keyword">double</span>&gt;());</span><br></pre></td></tr></table></figure><p>注意：比较器的使用方法，比较器 <code>std::greater</code> 是一个使用模板的结构体</p><p>参见 <code>cplusplus</code> 对 <a href="http://www.cplusplus.com/reference/functional/greater/" target="_blank" rel="noopener">std::greater</a> 的介绍</p><p><code>greater</code> 的原型为 <code>template &lt;class T&gt; struct greater</code>;</p><p>我们需要传入的实际上是是一个 <code>greater</code> 类型的变量,所以需要调用 <code>greater</code> 的构造函数，最后写成 <code>greater&lt;double&gt;()</code></p><h4 id="排序-pair"><a href="#排序-pair" class="headerlink" title="排序 pair"></a><strong>排序 pair</strong></h4><p>排序 <code>pair</code> 非常容易，直接 <code>sort</code> 的时候默认以 <code>first</code> 为第一关键字，<code>second</code> 为第二关键字排序</p><p>比如我们要对一系列事件已开始时间为第一关键字，结束时间为第二关键字排序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; events;</span><br><span class="line">sort(events.begin(),events.end());</span><br></pre></td></tr></table></figure></p><p>搞定~</p><h4 id="对自定义结构体进行排序（重载运算符方案）"><a href="#对自定义结构体进行排序（重载运算符方案）" class="headerlink" title="对自定义结构体进行排序（重载运算符方案）"></a><strong>对自定义结构体进行排序（重载运算符方案）</strong></h4><p>我们只需要重载结构体的 <code>&lt;</code> 运算符即可</p><p>例如，对事件以开始时间排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> begin_at, end_at;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> T_event &amp;other)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> begin &lt; other.begin；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;T_event&gt; events;</span><br><span class="line">sort(events.begin(),events.end());</span><br></pre></td></tr></table></figure><p>注意：比较重载运算符的两处 <code>const</code>，和引用 <code>&amp;</code> 。<code>const T_event &amp;other</code> 防止比较函数对 <code>other</code> 进行修改，第二个 <code>const</code> 是限制比较函数不得修改所在的结构体的成员。如果不加这两个 <code>const</code>    限定就会爆满屏幕的编译错误。而比较的时候，另一个变量必须以引用方式 <code>&amp;</code> 传递</p><h4 id="双（多）关键字排序"><a href="#双（多）关键字排序" class="headerlink" title="双（多）关键字排序"></a><strong>双（多）关键字排序</strong></h4><p>比如我们要对一个结构体 <code>vector</code> 排序，要求很复杂，首先按照 <code>a</code> 降序，然后按照 <code>c</code> 升序，再按照 <code>b</code> 降序，而且 <code>c</code> 是 <code>double</code> 值，排序的时候认为如果两个结构体的 <code>c</code> 下去正一样就算 <code>c</code> 一样，怎么搞？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Three_key</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">    <span class="keyword">bool</span> opeartor &lt; (<span class="keyword">const</span> Three_key &amp;other)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a != other.a)</span><br><span class="line">            <span class="keyword">return</span> a &gt; other.a;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>)c != (<span class="keyword">int</span>)other.c)</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)c &lt; (<span class="keyword">int</span>)other.c;</span><br><span class="line">        <span class="keyword">return</span> b &gt; other.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就可以了;</p><h4 id="使用比较函数排序"><a href="#使用比较函数排序" class="headerlink" title="使用比较函数排序"></a><strong>使用比较函数排序</strong></h4><p>有的时候我们需要对一个数组进行多次排序，每次排序标准还不一样，怎么搞？</p><p>比如坐标，第一次按照X坐标升序排序，搞点什么，然后再按照Y坐标降序排序，那么可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; points;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_x_inc</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.first &lt; p2.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_y_dec</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">&#125;</span><br><span class="line">sort(points.begin(),points.end(),cmp_x_inc);<span class="comment">//X 升序</span></span><br><span class="line"><span class="comment">//do something...</span></span><br><span class="line">sort(points.begin(),points.end(),cmp_y_dec);<span class="comment">//Y 降序</span></span><br></pre></td></tr></table></figure><p>向sort传入比较函数的函数指针就可以了~</p><h4 id="对字符串排序（使用结构体，不推荐）"><a href="#对字符串排序（使用结构体，不推荐）" class="headerlink" title="对字符串排序（使用结构体，不推荐）"></a><strong>对字符串排序（使用结构体，不推荐）</strong></h4><p>首先定义结构体<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; // strcmp 函数在这里</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T_String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> T_String &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str,s.str) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;T_String&gt; strs;</span><br><span class="line">sort(strs.begin(),strs.end());</span><br></pre></td></tr></table></figure></p><p>这种方法虽然简单，但是有很多缺陷，比如</p><ul><li>因为字符串存储在结构体中，造成结构体很大，交换结构体的开销很大</li><li>不能对常量字符串排序</li><li>一般不推荐使用</li></ul><h4 id="对字符串排序（使用-char-数组）"><a href="#对字符串排序（使用-char-数组）" class="headerlink" title="对字符串排序（使用 char* 数组）"></a><strong>对字符串排序（使用 char* 数组）</strong></h4><p>由于交换字符串开销很大，但是字符串本身是不会改变的，我们并不需要交换字符串本身，最终只需要能顺字典序访问所有字符串就行了，那么，可以对每个字符串建立一个指针，然后采用上面的比较函数方法对指针进行排序即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> strs[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span> *&gt; strs_sorted;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">char_ptr_cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a,b) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, strs[N++]) != EOF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        strs_sorted.push_back(strs[i]);</span><br><span class="line">    sort(strs_sorted.begin(), strs_sorted.end(), char_ptr_cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sorted strs are:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">char</span>*&gt;::iterator it = strs_sorted.begin(); it != strs_sorted.end(); it++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *it);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展-使用自定义比较器（伪函数）"><a href="#拓展-使用自定义比较器（伪函数）" class="headerlink" title="(拓展) 使用自定义比较器（伪函数）"></a><strong>(拓展) 使用自定义比较器（伪函数）</strong></h4><p>如果我们定义了一个结构体，里面有一个长度为10的int数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T_arr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;T_arr&gt; <span class="built_in">array</span>;</span><br></pre></td></tr></table></figure><p>我们需要对 <code>array</code> 进行 10 次排序，每次分别以其中一个下标 <code>（arr[0],arr[1],...）</code> 为关键字进行排序，怎么办？</p><p>写10个比较函数？听起来好靠谱的样子~~ 才怪！</p><p>还记得我们刚才提到的 <code>greater</code> 吗， <code>std::greater</code> 是一个结构体，我们来看看他的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">greater</span> :</span> binary_function &lt;T,T,<span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>能够看到，<code>greater</code> 重载了一个奇怪的运算符 <code>()</code>， <code>sort</code> 比较两个值的时候会使用这个运算符来对两个元素进行比较，我们也可以这么写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T_arr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;T_arr&gt; to_sort;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T_arr_cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    T_arr_cmp(<span class="keyword">int</span> index): index(index) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> T_arr &amp;a, <span class="keyword">const</span> T_arr &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.arr[index] &lt; b.arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    to_sort.resize(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;to_sort[i].arr[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(to_sort.begin(), to_sort.end(), T_arr_cmp(j)); <span class="comment">// 传入比较器,以数组的第j位为关键字</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the to_sort sort by arr[%d] is:\n"</span>, j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%4d %4d %4d %4d\n"</span>, to_sort[i].arr[<span class="number">0</span>], to_sort[i].arr[<span class="number">1</span>], to_sort[i].arr[<span class="number">2</span>], to_sort[i].arr[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码 给 <code>sort</code> 函数传入了一个结构体，结构体有一个成员变量 <code>index</code> ,表示用 <code>arr[index]</code> 为关键字进行比较，而这个 <code>index</code>，这个 <code>index</code> 是在结构体构造的时候由构造函数传进去的<br>相当于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T_arr_cmp <span class="title">cmp</span><span class="params">(j)</span></span>;</span><br><span class="line">sort(<span class="built_in">array</span>.begin(), <span class="built_in">array</span>.end(), cmp);</span><br></pre></td></tr></table></figure><p>可以用下面的数据测试</p><blockquote><p>5<br>1 2 3 4<br>2 3 4 1<br>3 4 1 2<br>4 1 2 3<br>1 2 3 4</p></blockquote><h4 id="拓展-使用lambda函数进行排序（C-11）"><a href="#拓展-使用lambda函数进行排序（C-11）" class="headerlink" title="(拓展)使用lambda函数进行排序（C++11）"></a><strong>(拓展)使用lambda函数进行排序（C++11）</strong></h4><p>每次都要定义一个排序函数太麻烦了有木有！<br>看代码的时候找比较函数往上滚滚轮都快疯了，还打断思路有木有！！<br>写比较器好多行好麻烦有木有！！！</p><p>然而C++11标准提供了 <code>lambda</code> 函数（匿名函数，现声明现调用），写出的代码就好看多了</p><p>参见：<a href="http://zh.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">Lambda函数（C++11 起）</a></p><p>上面的使用比较器对数组多处排序可以改成这样，注意使用 <code>g++ xxx.cpp -std=c++11</code> 来编译（启用C++11标准）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T_arr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;T_arr&gt; to_sort;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    to_sort.resize(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;to_sort[i].arr[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(to_sort.begin(), to_sort.end(), [&amp;j](<span class="keyword">const</span> T_arr &amp;a, <span class="keyword">const</span> T_arr &amp;b)-&gt;<span class="keyword">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.arr[j] &lt; b.arr[j]; </span><br><span class="line">        &#125;); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the to_sort sort by arr[%d] is:\n"</span>, j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%4d %4d %4d %4d\n"</span>, to_sort[i].arr[<span class="number">0</span>], to_sort[i].arr[<span class="number">1</span>], to_sort[i].arr[<span class="number">2</span>], to_sort[i].arr[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看cppreference中给出的第一种lambda函数语法</p><blockquote><p>[ capture ] ( params ) mutable exception attribute -&gt; ret { body }</p></blockquote><p>再看看我们在sort最后一个参数写了什么？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(to_sort.begin(), to_sort.end(), [&amp;j](<span class="keyword">const</span> T_arr &amp;a, <span class="keyword">const</span> T_arr &amp;b)-&gt;<span class="keyword">bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.arr[j] &lt; b.arr[j]; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>首先我们用 <code>[&amp;j]</code> 捕获了 <code>j</code> ，这样排序函数内部就可以直接使用 <code>lambda</code> 外面的 <code>j</code> 啦，不用构造难用的比较器再传入 <code>index</code> 啦。<br>剩下的和之前说的使用函数比较没什么区别，只是把函数定义放在调用位置而且没起名而已~</p><p>我们再来看看使用指针排序字符串的程序，使用lambda函数可以改成这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort(strs_sorted.begin(), strs_sorted.end(), [](<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">const</span> <span class="keyword">char</span> *b)-&gt;<span class="keyword">bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a,b) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>lambda真好用有没有！！！！</p><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue 是 <code>STL</code> 提供的一个队列类，比手写队列有很多优势</p><p><code>std::queue</code> 需要 <code>#include &lt;queue&gt;</code></p><p>queue 的主要成员</p><ul><li><code>push(const value_type&amp; val)</code> 向队列压入一个元素</li><li><code>pop()</code> 将队头弹出</li><li><code>front()</code> 取出队头</li><li><code>empty()</code> 判断队列是否为空<br>简单的演示</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> h = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">if</span> (h &lt; <span class="number">100</span>)</span><br><span class="line">        q.push(h+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，要及时判断 <code>queue</code> 的 <code>empty()</code>，你只有一次机会，如果队列为空再 <code>pop()</code> 的话之后 <code>empty()</code> 八成是返回 <code>false</code>，因为 <code>size</code> 变成 <code>232−1</code> 了，然后什么奇怪的事情都有可能发生</p><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>顾名思义，优先队列，是算法竞赛中的非常重要数据结构，Dijkstra等算法 少不了它。<br>可以参考<br>cplusplus中的 <a href="http://www.cplusplus.com/reference/queue/priority_queue/" target="_blank" rel="noopener">priority_queue</a> 和 它的<a href="http://www.cplusplus.com/reference/queue/priority_queue/priority_queue/" target="_blank" rel="noopener">构造函数</a></p><p><code>priority_queue</code> 的使用方法和 <code>queue</code> 基本一致，和主要区别是 <code>front()</code> 换成了 <code>top()</code> ，因为 <code>priority_queue</code> 使用堆实现的</p><p>注意，<code>priority_queue</code> 默认是大根堆，也就是大的元素先出队，想让小的元素先出队则应当给出比较器</p><p>重载结构体运算符实现“小根堆”</p><p>我们经常会遇到想要所有元素以某种优先方法出队，比如Dijkstra算法中，想要当前距离小的点先出队，我们可以这样做</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> point,dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> State &amp;s)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; s.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;State&gt; q;</span><br></pre></td></tr></table></figure><p>无论你使用怎样的方法，都不能改变 <code>priority_queue</code> 是一个大根堆的事实，我们只是重载了运算符让小的元素比较起来大了而已，事实上，这是算法竞赛中非常常用的一种写法，一般来说足够用了。</p><h4 id="拓展-自定义priority-queue的比较方法"><a href="#拓展-自定义priority-queue的比较方法" class="headerlink" title="(拓展)自定义priority_queue的比较方法"></a><strong>(拓展)自定义priority_queue的比较方法</strong></h4><p>上面那个例子，明明可以用 <code>pair&lt;int,int&gt;</code>  存下来的嘛，如果我强行要使用 <code>pair&lt;int,int&gt;</code> 这种不能重载运算符的怎么办？<br>或者有的时候我们不能重载某个结构体的 <code>&lt;</code> 运算符怎么办？</p><p>我们先来看看 <code>priority_queue</code> 的原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">vector</span>&lt;T&gt;,</span></span><br><span class="line"><span class="class">  <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;typename Container::value_type&gt; &gt; <span class="title">class</span> <span class="title">priority_queue</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，模板参数有三个，不过后面两参数已经有默认值了，如果我们想自定义比较器，那么三个参数都要填。还记得上面 <code>sort</code> 里面讲的比较器（仿函数）嘛，第三个参数填入一个仿函数就好了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair_cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, pair_cmp&gt; q;</span><br></pre></td></tr></table></figure></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set</code> 是有序集合，使用 <code>set</code> 需要 <code>#include &lt;set&gt;</code></p><p><code>set</code> 是使用平衡树实现的，可以在 <code>O(Log(N))</code> 的时间内完成插入删除修改操作。</p><p><code>set</code> 常用来进行各种判重，比如搜索判重，状态判重等等。</p><p>cplusplus上对 <a href="http://www.cplusplus.com/reference/set/set/" target="_blank" rel="noopener">set</a> 的介绍</p><h4 id="声明一个set"><a href="#声明一个set" class="headerlink" title="声明一个set"></a><strong>声明一个set</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset;</span><br></pre></td></tr></table></figure><p>常用API有：</p><ul><li><p><code>set::insert(val)</code> 插入一个元素</p></li><li><p><code>set::empty()</code> 判定set是否为空</p></li><li><code>set::clear()</code> 清空set</li><li><code>set::size()</code> 取得set大小</li><li><code>set::erase()</code> 删除元素（有三只牛股用法）</li><li><code>set::find(val)</code> 返回指定元素迭代器，不存在的话返返回end()</li><li><code>set::lower_bound(val)</code></li><li><code>set::upperbound(val)</code></li><li><code>set::begin()</code> 返回从左开始的迭代器（从小到大）</li><li><code>set::end()</code> 返回</li><li><code>set::rbegin,set::rend()</code></li><li><code>set::count(val)</code> 返回set指定val的个数<br>显然只能返回1（有）或者0（没有），可以用来判断元素是否存在</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自: &lt;a href=&quot;https://www.zybuluo.com/comzyh/note/138935&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zybuluo.com/comzyh/note/138935&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考网站&quot;&gt;&lt;a href=&quot;#参考网站&quot; class=&quot;headerlink&quot; title=&quot;参考网站&quot;&gt;&lt;/a&gt;参考网站&lt;/h2&gt;&lt;p&gt;推荐大家去这些网站查询自己需要的东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cpluscplus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.cppreference.com/w/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cppreference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cppreferne中文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;STL中有很多好用的容器和算法，非常好用。&lt;br&gt;简单介绍一下&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="https://blog.andrewei.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++" scheme="https://blog.andrewei.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"/>
    
    
      <category term="C++" scheme="https://blog.andrewei.me/tags/C/"/>
    
      <category term="STL" scheme="https://blog.andrewei.me/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #251 (Div. 2)</title>
    <link href="https://blog.andrewei.me/2015/12/16/codeforces-round-251-div-2/"/>
    <id>https://blog.andrewei.me/2015/12/16/codeforces-round-251-div-2/</id>
    <published>2015-12-15T16:24:40.000Z</published>
    <updated>2018-04-09T01:16:07.245Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接: <a href="http://codeforces.com/contest/439" target="_blank" rel="noopener">http://codeforces.com/contest/439</a></p><h2 id="A题-Devu-the-Singer-and-Churu-the-Joker"><a href="#A题-Devu-the-Singer-and-Churu-the-Joker" class="headerlink" title="A题(Devu, the Singer and Churu, the Joker)"></a>A题(<a href="http://codeforces.com/contest/439/problem/A" target="_blank" rel="noopener">Devu, the Singer and Churu, the Joker</a>)</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>Devu 喜欢唱歌，唱一首歌的时间为 t, 每唱完一首歌至少要休息 10 分钟，Churu 喜欢讲笑话，讲一个笑话的时间为 5 分钟, 现给定两个整数 $n(1 &lt;= n &lt;= 100) d(1 &lt;= d &lt;= 10000)$, 分别表示Devu在个人演唱会上要唱 n 首歌，演唱会的总时间为 $d$, 接下来给定$n$个整数表示 $t_i(1 &lt;= t &lt;= 100)$, 表示这$n$首歌的时间，问在保证 Devu 把所有歌唱完的情况下，Churu 最多可以讲多少个笑话，如果 Devu 不能把 $n$ 首歌唱完，输出 -1.</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>Devu 唱完$n$首歌共需要时间 $T=\sum_{i=1}^{n}t_i+10(n-1)$, 此时 Churu 可以讲的笑话为 $ans=2(n-1)+(d-T)/2$.</p><p>参考程序:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;d) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">            sum += v;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (n - <span class="number">1</span>) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; d) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = d - sum;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">2</span> * (n - <span class="number">1</span>) + tmp / <span class="number">5</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="B题-Devu-the-Dumb-Guy"><a href="#B题-Devu-the-Dumb-Guy" class="headerlink" title="B题(Devu, the Dumb Guy)"></a>B题(<a href="http://codeforces.com/contest/439/problem/B" target="_blank" rel="noopener">Devu, the Dumb Guy</a>)</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>Devu 学习东西很慢, 现在他要学习$n(1 &lt;= n &lt;= 10^5)$ 个科目，每个科目有 $c_i(1 &lt;= i &lt;= n)$ 个章节, 他学习有个特点，在学习第一个科目的时候每个章节的学习时间为$x$, 学习第二个科目的时候学习每个章节的时间为$x - 1$, 一次类推，$x$ 递减，直到$x == 1$时，他的学习速度将维持不变, 问他学完这$n$个科目所需要的最小时间为多少.</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>贪心，先学习章节少的科目， 然后学习章节多的科目, 注意答案会超出 int 范围。</p><p>参考程序:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;x) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">        sort(a, a + n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ans += a[i] * x;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; <span class="number">1</span>) x--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C题-Devu-and-Partitioning-of-the-Array"><a href="#C题-Devu-and-Partitioning-of-the-Array" class="headerlink" title="C题(Devu and Partitioning of the Array)"></a>C题(<a href="http://codeforces.com/contest/439/problem/C" target="_blank" rel="noopener">Devu and Partitioning of the Array</a>)</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>给定三个整数$n, k, p(1 &lt;= k &lt;= n &lt;= 10^5, 0 &lt;= p &lt;= k)$表示有$n$个整数$a_i(1 &lt;= a_i &lt;= 10^9)$，要把这些整数分成恰好$k$组，并且满足和为偶数的组的数目为$p$, 问有没有一种方案可以满足题目要求， 有的话输出YES, 并输出任意一种方案, 没有的话，输出NO.</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>构造题:</p><ol><li>先考虑构造$k-p$组奇数，首先每个奇数为一组, 如果不够$k-p$ 组输出 NO.</li><li>如果多余的奇数的个数为奇数个，输出 NO, 如果多余奇数的个数的一半加上所有偶数的个数小于$p$, 输出NO;</li><li>将多余的奇数两两一组作为和为偶数的分组;</li><li>每个偶数作为一个和为偶数的分组直到凑够$p$组，多余的偶数放在最后一组即可。<br>参考代码:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, k, p, eNum, oNum;</span><br><span class="line"><span class="keyword">int</span> even[MAXN], odd[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">        ans[i].clear();</span><br><span class="line">    eNum = oNum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, dx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(oNum &lt; k - p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k - p; i++)</span><br><span class="line">        ans[dx++].push_back(odd[i]);</span><br><span class="line">    <span class="keyword">if</span>((oNum - i) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>((eNum + ((oNum - i) &gt;&gt; <span class="number">1</span>)) &lt; p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; oNum; i += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dx == k) <span class="keyword">break</span>;</span><br><span class="line">        ans[dx].push_back(odd[i]);</span><br><span class="line">        ans[dx++].push_back(odd[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dx == k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; oNum; i += <span class="number">2</span>)&#123;</span><br><span class="line">            ans[dx - <span class="number">1</span>].push_back(odd[i]);</span><br><span class="line">            ans[dx - <span class="number">1</span>].push_back(odd[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; eNum; i++)</span><br><span class="line">            ans[dx - <span class="number">1</span>].push_back(even[i]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; eNum; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dx &lt; k) ans[dx++].push_back(even[i]);</span><br><span class="line">            <span class="keyword">else</span> ans[dx - <span class="number">1</span>].push_back(even[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;p) != EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(v &amp; <span class="number">1</span>) odd[oNum++] = v;</span><br><span class="line">            <span class="keyword">else</span> even[eNum++] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(solve())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = ans[i].size();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>, t);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; j++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" %d"</span>, ans[i][j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛链接: &lt;a href=&quot;http://codeforces.com/contest/439&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/439&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;A题-Devu-the-Singer-and-Churu-the-Joker&quot;&gt;&lt;a href=&quot;#A题-Devu-the-Singer-and-Churu-the-Joker&quot; class=&quot;headerlink&quot; title=&quot;A题(Devu, the Singer and Churu, the Joker)&quot;&gt;&lt;/a&gt;A题(&lt;a href=&quot;http://codeforces.com/contest/439/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Devu, the Singer and Churu, the Joker&lt;/a&gt;)&lt;/h2&gt;&lt;h3 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意:&quot;&gt;&lt;/a&gt;题目大意:&lt;/h3&gt;&lt;p&gt;Devu 喜欢唱歌，唱一首歌的时间为 t, 每唱完一首歌至少要休息 10 分钟，Churu 喜欢讲笑话，讲一个笑话的时间为 5 分钟, 现给定两个整数 $n(1 &amp;lt;= n &amp;lt;= 100) d(1 &amp;lt;= d &amp;lt;= 10000)$, 分别表示Devu在个人演唱会上要唱 n 首歌，演唱会的总时间为 $d$, 接下来给定$n$个整数表示 $t_i(1 &amp;lt;= t &amp;lt;= 100)$, 表示这$n$首歌的时间，问在保证 Devu 把所有歌唱完的情况下，Churu 最多可以讲多少个笑话，如果 Devu 不能把 $n$ 首歌唱完，输出 -1.&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://blog.andrewei.me/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://blog.andrewei.me/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="Codefource" scheme="https://blog.andrewei.me/tags/Codefource/"/>
    
      <category term="题解" scheme="https://blog.andrewei.me/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #249 (Div. 2)</title>
    <link href="https://blog.andrewei.me/2015/12/10/codeforces-round-249-div-2/"/>
    <id>https://blog.andrewei.me/2015/12/10/codeforces-round-249-div-2/</id>
    <published>2015-12-10T15:36:49.000Z</published>
    <updated>2018-04-09T01:16:07.244Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接: <a href="http://codeforces.com/contest/435" target="_blank" rel="noopener">http://codeforces.com/contest/435</a></p><h2 id="A题-Queue-on-Bus-Stop"><a href="#A题-Queue-on-Bus-Stop" class="headerlink" title="A题(Queue on Bus Stop)"></a>A题(<a href="http://codeforces.com/contest/435/problem/A" target="_blank" rel="noopener">Queue on Bus Stop</a>)</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>已知每辆公交车最多可以载 $m(1 &lt;= m &lt;= 100)$ 个人，给出 $n(1 &lt;= n &lt;= 100)$ 组人, 人数分别为 $a_i(1 &lt;= i &lt;= m)$, 每辆公交车尽量可以载更多的组, 但是不能把每组人分开载， 问把这 $n$ 组人全部载上最少需要多少辆公交车。注意: 要按顺序一组一组的上车。<a id="more"></a></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>模拟一下上车的过程即可, 每辆车尽量让更多的组上车，实在放不下再等下一辆车。</p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        a[n] = <span class="number">111111</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; tmp)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                tmp = (m - a[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp -= a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="B题-Pasha-Maximizes"><a href="#B题-Pasha-Maximizes" class="headerlink" title="B题(Pasha Maximizes)"></a>B题(<a href="http://codeforces.com/contest/435/problem/B" target="_blank" rel="noopener">Pasha Maximizes</a>)</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>给定两个数字 $a(1 &lt;= a &lt;= 10^{18}), k(0 &lt;= k &lt;= 100), a$ 是一个没有前导零的整数, 现在对数字 $a$ 进行操作, 每次操作可以把 $a$ 中两个相邻的数字交换位置, 问经过 $k$ 次操作后，$a$ 的值最大是多少。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>贪心, 但是要注意贪心的方法。假设我们现在考虑第 $i$ 位，比 $i$ 更高的位已经是最大的数字, 我们需要找到 $k$ 步以内的最大的数字把它移到第 $i$ 位，然后再考虑下一位。具体看代码。</p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, ch, &amp;k) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ch);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ma = ch[i] - <span class="string">'0'</span>, <span class="built_in">map</span> = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= i + k &amp;&amp; j &lt; len; j++)</span><br><span class="line">                <span class="keyword">if</span>(ch[j] - <span class="string">'0'</span> &gt; ma) ma = ch[j] - <span class="string">'0'</span>, <span class="built_in">map</span> = j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="built_in">map</span>; j &gt; i; j--)&#123;</span><br><span class="line">                swap(ch[j], ch[j - <span class="number">1</span>]);</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C题-Cardiogram"><a href="#C题-Cardiogram" class="headerlink" title="C题(Cardiogram)"></a>C题(<a href="http://codeforces.com/contest/435/problem/C" target="_blank" rel="noopener">Cardiogram</a>)</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>输出一个心电图，给定 $n(2 &lt;= n &lt;= 1000)$ 步操作，对于第 $i(1 &lt;= i &lt;= n)$ 步操作，当 $i$ 为奇数时输出’/‘, 当 $i$ 为偶数时输出’\’, 例如:<img src="/images/2015/12/2015-12-13-231745.png" alt=""></p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>模拟，虽然题目说 $\sum_{n}^{i=1}a_i &lt;= 1000$, 但是出于保险考虑还是开了一个 2000 * 2000 的数组。</p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        fill(ch[<span class="number">0</span>], ch[MAXN], <span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">int</span> ma = <span class="number">1000</span>, mi = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> dx = <span class="number">0</span>, dy = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>)&#123; </span><br><span class="line">                <span class="keyword">while</span>(v--)&#123; </span><br><span class="line">                    ch[dy][dx] = <span class="string">'/'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(v) dy++;</span><br><span class="line">                    dx++;</span><br><span class="line">                &#125;</span><br><span class="line">                ma = max(ma, dy);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(v--)&#123; </span><br><span class="line">                    ch[dy][dx] = <span class="string">'\\'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(v) dy--; </span><br><span class="line">                    dx++;</span><br><span class="line">                &#125;</span><br><span class="line">                mi = min(mi, dy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mi; i &lt;= ma; i++)</span><br><span class="line">            ch[i][dx] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ma; i &gt;= mi; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ch[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛链接: &lt;a href=&quot;http://codeforces.com/contest/435&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/435&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;A题-Queue-on-Bus-Stop&quot;&gt;&lt;a href=&quot;#A题-Queue-on-Bus-Stop&quot; class=&quot;headerlink&quot; title=&quot;A题(Queue on Bus Stop)&quot;&gt;&lt;/a&gt;A题(&lt;a href=&quot;http://codeforces.com/contest/435/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Queue on Bus Stop&lt;/a&gt;)&lt;/h2&gt;&lt;h3 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意:&quot;&gt;&lt;/a&gt;题目大意:&lt;/h3&gt;&lt;p&gt;已知每辆公交车最多可以载 $m(1 &amp;lt;= m &amp;lt;= 100)$ 个人，给出 $n(1 &amp;lt;= n &amp;lt;= 100)$ 组人, 人数分别为 $a_i(1 &amp;lt;= i &amp;lt;= m)$, 每辆公交车尽量可以载更多的组, 但是不能把每组人分开载， 问把这 $n$ 组人全部载上最少需要多少辆公交车。注意: 要按顺序一组一组的上车。
    
    </summary>
    
      <category term="题解" scheme="https://blog.andrewei.me/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://blog.andrewei.me/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="Codefource" scheme="https://blog.andrewei.me/tags/Codefource/"/>
    
      <category term="题解" scheme="https://blog.andrewei.me/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #248 (Div. 2)</title>
    <link href="https://blog.andrewei.me/2015/12/08/codeforces-round-248-div-2/"/>
    <id>https://blog.andrewei.me/2015/12/08/codeforces-round-248-div-2/</id>
    <published>2015-12-07T17:06:39.000Z</published>
    <updated>2018-04-09T01:16:07.244Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接: <a href="http://codeforces.com/contest/433" target="_blank" rel="noopener">http://codeforces.com/contest/433</a></p><h2 id="A题-Kitahara-Haruki’s-Gift"><a href="#A题-Kitahara-Haruki’s-Gift" class="headerlink" title="A题(Kitahara Haruki’s Gift)"></a>A题(<a href="http://codeforces.com/contest/433/problem/A" target="_blank" rel="noopener">Kitahara Haruki’s Gift</a>)</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>有 n(1 &lt;= n &lt;= 100) 个苹果，第 i (1 &lt;= i &lt;= n) 个苹果的价值为 $w_i$ ($w_i$ == 100 or $w_i$ ==200), 求是否可以将苹果分成两部分，使得每一部分的价值相同。(注意：苹果不能分割)</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>题目规定了苹果的价值 w 只有 100 和 200 两种数字大大降低了题目的难度, 只需要贪心一下就可以过。先计算出所有苹果的价值总和 sum,  首先验证 sum 除以 2 后可不可以被 100 整除， 如果不能则肯定不能满足题目要求。如果可以，下面就验证一下用现有苹果可不可以凑出 sum / 2，这个价值就行了。</p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">100</span>) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sort(a, a + n);</span><br><span class="line">            <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(sum &amp;&amp; r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sum - a[r] &gt;= <span class="number">0</span>)&#123; </span><br><span class="line">                    sum -= a[r];</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum == <span class="number">100</span> &amp;&amp; a[<span class="number">0</span>] == <span class="number">100</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="B题-Kuriyama-Mirai’s-Stones"><a href="#B题-Kuriyama-Mirai’s-Stones" class="headerlink" title="B题(Kuriyama Mirai’s Stones)"></a>B题(<a href="http://codeforces.com/contest/433/problem/B" target="_blank" rel="noopener">Kuriyama Mirai’s Stones</a>)</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>题目抽象出来就是给定 n(1 &lt;= n &lt;= 10^5) 个数的序列 $v_i$(1 &lt;= i &lt;= n)，有两种询问，询问 1：输出序列中区间[l, r] 内所有数的和，询问2: 输出按照非递减序列排序后序列中区间[l, r]内所有数的和.</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>维护两个前缀和一个是原来的序列的前缀和，另一个是排序之后的前缀和，然后求区间 [l, r] 中所有数的和只需要 ans = sum[r] - sum[l];</p><p>参考代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum1[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            sum1[i] = sum1[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">        sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            sum2[i] = sum2[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> c, l, r;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; sum1[r] - sum1[l - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; sum2[r] - sum2[l - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C题-Ryouko’s-Memory-Note"><a href="#C题-Ryouko’s-Memory-Note" class="headerlink" title="C题(Ryouko’s Memory Note)"></a>C题(<a href="http://codeforces.com/contest/433/problem/C" target="_blank" rel="noopener">Ryouko’s Memory Note</a>)</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>给定 $n(1 &lt;= n &lt;= 10^5)$ 个数的一个序列 $v_i(1 &lt;= i &lt;=n)$ 现要求改变其中最多一个数,使得$sum=\sum_{i=1}^{m-1}\left| a_{i+1} - a_i \right|$最小。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>对于序列中出现的每一个数，我们为他建立一个临接表，临接表里面记录着这个数所有相邻的数，由数学知识可知当这个数为临接表中所有数的中位数时，得到的差的绝对值之和最小，所以我们只要枚举序列中的每一个数将其变为所有与他相临的数的中位数，找出最佳答案即可。</p><p>参考代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; vec[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ABS</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> -x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">            vec[i].clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max1 = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == a[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            sum += ABS(a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">            vec[a[i - <span class="number">1</span>]].push_back(a[i]);</span><br><span class="line">            vec[a[i]].push_back(a[i - <span class="number">1</span>]);</span><br><span class="line">            max1 = max(max1, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>, tmp1, tmp2, mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> dx = <span class="number">1</span>; dx &lt;= max1; dx++)&#123;</span><br><span class="line">            tmp1 = <span class="number">0</span>, tmp2 = <span class="number">0</span>;</span><br><span class="line">            sort(vec[dx].begin(), vec[dx].end());</span><br><span class="line">            <span class="keyword">int</span> size = vec[dx].size();</span><br><span class="line">            <span class="keyword">if</span>(!size) <span class="keyword">continue</span>;</span><br><span class="line">            mid = vec[dx][size / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                tmp1 += ABS(vec[dx][j] - dx);</span><br><span class="line">                tmp2 += ABS(vec[dx][j] - mid);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(tmp1 - tmp2, ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, sum - ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛链接: &lt;a href=&quot;http://codeforces.com/contest/433&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/433&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;A题-Kitahara-Haruki’s-Gift&quot;&gt;&lt;a href=&quot;#A题-Kitahara-Haruki’s-Gift&quot; class=&quot;headerlink&quot; title=&quot;A题(Kitahara Haruki’s Gift)&quot;&gt;&lt;/a&gt;A题(&lt;a href=&quot;http://codeforces.com/contest/433/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kitahara Haruki’s Gift&lt;/a&gt;)&lt;/h2&gt;&lt;h3 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意:&quot;&gt;&lt;/a&gt;题目大意:&lt;/h3&gt;&lt;p&gt;有 n(1 &amp;lt;= n &amp;lt;= 100) 个苹果，第 i (1 &amp;lt;= i &amp;lt;= n) 个苹果的价值为 $w_i$ ($w_i$ == 100 or $w_i$ ==200), 求是否可以将苹果分成两部分，使得每一部分的价值相同。(注意：苹果不能分割)&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://blog.andrewei.me/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://blog.andrewei.me/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="Codefource" scheme="https://blog.andrewei.me/tags/Codefource/"/>
    
      <category term="题解" scheme="https://blog.andrewei.me/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #334 (Div. 2)</title>
    <link href="https://blog.andrewei.me/2015/12/07/codeforces-round-334-div-2/"/>
    <id>https://blog.andrewei.me/2015/12/07/codeforces-round-334-div-2/</id>
    <published>2015-12-07T15:15:38.000Z</published>
    <updated>2018-04-09T01:16:07.245Z</updated>
    
    <content type="html"><![CDATA[<p>比赛链接: <a href="http://codeforces.com/contest/604" target="_blank" rel="noopener">http://codeforces.com/contest/604</a></p><h2 id="A题-Uncowed-Forces"><a href="#A题-Uncowed-Forces" class="headerlink" title="A题(Uncowed Forces)"></a>A题(<a href="http://codeforces.com/contest/604/problem/A" target="_blank" rel="noopener">Uncowed Forces</a>)</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>根据给定的CF的计分规则，给出5道题下来CF的最终得分。<a id="more"></a></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>模拟一下就好。</p><p>参考程序:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment"># Author:DATASOURCE</span></span><br><span class="line"><span class="comment"># Last modified: 2015-12-01 23:31</span></span><br><span class="line"><span class="comment"># Filename: a.cpp</span></span><br><span class="line"><span class="comment"># Description: </span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, mid, ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid, r, rs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (rt &lt;&lt; 1) + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (rt &lt;&lt; 1) + 2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">500</span>, <span class="number">1000</span>, <span class="number">1500</span>, <span class="number">2000</span>, <span class="number">2500</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hs, hu;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m[<span class="number">0</span>]) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;hs, &amp;hu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            ans += max(<span class="number">3</span> * x[i] / <span class="number">10</span>, (x[i] - m[i] * x[i] / <span class="number">250</span>) - <span class="number">50</span> * w[i]);</span><br><span class="line"></span><br><span class="line">        ans += (<span class="number">100</span> * hs - <span class="number">50</span> * hu);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="B题-More-Cowbell"><a href="#B题-More-Cowbell" class="headerlink" title="B题(More Cowbell)"></a>B题(<a href="http://codeforces.com/contest/604/problem/B" target="_blank" rel="noopener">More Cowbell</a>)</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>把 n 个物品放入箱子里, 一共有 k 个箱子供选择, 可以不全用上, 每个箱子可以放一个或者两个物品, 每件物品都有一个体积 $s_i$,  对于任意的体积 $s_i$ 的物品都可以放入到空间大于或者等于 $s_i$ 的箱子里面去(即不考虑物品的形状), 求一种组合方案, 可以用最多 k 个箱子装下 n 个物品的前提下, 所使用的最大的那个箱子的体积尽可能小, 求出那个体积。</p><p>其中:</p><p>$1 &lt;= n &lt;= 2k ≤ 100000$<br>$1 &lt;= s_1 &lt;= s_2 &lt;= … &lt;= s_n &lt;= 1000000$</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>二分答案, 只要验证二分出来的答案是否满足题意就行了, 找出最小的那个答案。</p><p>参考程序:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment"># Author:DATASOURCE</span></span><br><span class="line"><span class="comment"># Last modified: 2015-12-01 23:50</span></span><br><span class="line"><span class="comment"># Filename: b.cpp</span></span><br><span class="line"><span class="comment"># Description: </span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, mid, ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid, r, rs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (rt &lt;&lt; 1) + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (rt &lt;&lt; 1) + 2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = k;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= l; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i] + a[l] &lt;= x) l++;</span><br><span class="line">        num--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k) != EOF)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = a[<span class="number">0</span>] - <span class="number">1</span>, r = a[n - <span class="number">1</span>] * <span class="number">2</span>, mid;</span><br><span class="line">        <span class="keyword">while</span>(r - l &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="C题-Alternative-Thinking"><a href="#C题-Alternative-Thinking" class="headerlink" title="C题(Alternative Thinking)"></a>C题(<a href="http://codeforces.com/contest/604/problem/C" target="_blank" rel="noopener">Alternative Thinking</a>)</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意:"></a>题目大意:</h3><p>给定一个01串,  长度为 n， 任意选定一个区间(或者不选)将区间内的01反转，使得这个01串中的01子序列最长。比如 10000011 可以反转中间的两个变成 10011011, 此时它拥有最长的01子序列 <strong>10</strong>0<strong>1</strong>1<strong>01</strong>1，答案为 5.</p><p>其中 $1 &lt;= n &lt;= 100000$</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路:"></a>解题思路:</h3><p>选定一个区间翻转后，区间中的01子序列的长度是一定的，整个01串中的01子序列的长度改变是由反转区间的两端的改变造成的，所以只需要记录两端的改变即可，具体看代码。</p><p>参考代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=============================================================================</span></span><br><span class="line"><span class="comment"># Author:DATASOURCE</span></span><br><span class="line"><span class="comment"># Last modified: 2015-12-02 00:39</span></span><br><span class="line"><span class="comment"># Filename: c.cpp</span></span><br><span class="line"><span class="comment"># Description: </span></span><br><span class="line"><span class="comment">=============================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l, mid, ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson mid, r, rs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (rt &lt;&lt; 1) + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (rt &lt;&lt; 1) + 2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %s"</span>, ch);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i] == ch[i - <span class="number">1</span>]) b++;</span><br><span class="line">            <span class="keyword">else</span> a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = a + (b &gt; <span class="number">2</span> ? <span class="number">2</span> : b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛链接: &lt;a href=&quot;http://codeforces.com/contest/604&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://codeforces.com/contest/604&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;A题-Uncowed-Forces&quot;&gt;&lt;a href=&quot;#A题-Uncowed-Forces&quot; class=&quot;headerlink&quot; title=&quot;A题(Uncowed Forces)&quot;&gt;&lt;/a&gt;A题(&lt;a href=&quot;http://codeforces.com/contest/604/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Uncowed Forces&lt;/a&gt;)&lt;/h2&gt;&lt;h3 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意:&quot;&gt;&lt;/a&gt;题目大意:&lt;/h3&gt;&lt;p&gt;根据给定的CF的计分规则，给出5道题下来CF的最终得分。
    
    </summary>
    
      <category term="题解" scheme="https://blog.andrewei.me/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://blog.andrewei.me/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="Codefource" scheme="https://blog.andrewei.me/tags/Codefource/"/>
    
      <category term="题解" scheme="https://blog.andrewei.me/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://blog.andrewei.me/2015/11/03/e6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-2/"/>
    <id>https://blog.andrewei.me/2015/11/03/e6-8e-92-e5-ba-8f-e7-ae-97-e6-b3-95-2/</id>
    <published>2015-11-03T08:56:43.000Z</published>
    <updated>2018-04-09T01:16:07.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序法"><a href="#快速排序法" class="headerlink" title="快速排序法"></a>快速排序法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>快速排序（Quicksort）是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列.<a id="more"></a></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。步骤为：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot），</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。、</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li></ol><h3 id="排序演示"><a href="#排序演示" class="headerlink" title="排序演示"></a>排序演示</h3><p>假设用户输入了如下数组：</p><p><img src="/images/2015/10/9c1976f7f14dcb47ed92648f74b67f2d1.png" alt="9c1976f7f14dcb47ed92648f74b67f2d"><br>创建变量i=0（指向第一个数据）, j=5(指向最后一个数据), k=6(赋值为第一个数据的值)。 我们取走了下标0的数据，于是，我们需要找到一个数字来替换他。由于我们要把所有比6小的数移动到左面，所以我们可以开始寻找比6小的数并从右往左找。别急，我们要按顺序找哦。不断递减j的值，我们发现下标3的数据比6小，于是把3移到下标0（实际是i指向的位置。代码中要用i，因为后面还会循环这个步骤，不用i的话第二次循环就会出问题。），数组和变量变成了以下状态：<img src="/images/2015/10/20151029083808.png" alt="QQ截图20151029083808"><br>$i=0 j=3 k=6$</p><p>由于变量k已经储存了下标0的数据，所以我们可以放心的把下标0覆盖了。如此一来，下标3虽然有数据，但是相当于没有了，因为数据已经复制到别的地方了。于是我们再找一个数据来替换他。这次要变成找比k大的了，而且要从前往后找了。递加变量i，发现下标2是第一个比k大的，于是用下标2的数据7替换j指向的下标3的数据，数据状态变成下表：</p><p><img src="/images/2015/10/9c1976f7b67f2d.png" alt="9c1976f7b67f2d"><br>$i=2 j=3 k=6$</p><p>重复上面的步骤，递减变量 j 。这时，我们发现 i 和 j “碰头”了：他们都指向了下标 2 。于是，循环结束，把 k 填回下标 2 里，即得到结果。 如果i和j没有碰头的话，就递加i找大的，还没有，就再递减j找小的，如此反复，不断循环。注意判断和寻找是同时进行的。</p><p><strong>注意</strong>：快速排序不会直接得到最终结果，只会把比k大和比k小的数分到k的两边。（你可以想象一下i和j是两个机器人，数据就是大小不一的石头，先取走i前面的石头留出回旋的空间，然后他们轮流分别挑选比k大和比k小的石头扔给对面，最后在他们中间把取走的那块石头放回去，于是比这块石头大的全扔给了j那一边，小的全扔给了i那一边。只是这次运气好，扔完一次刚好排整齐。）为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，然后再分解数组，直到数组不能再分解为止（只有一个数据），才能得到正确结果。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123; <span class="comment">// 简单的交换函数;</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="comment">// 快排函数;</span></span><br><span class="line">    <span class="keyword">int</span> t, i, j;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123; <span class="comment">// 递归结束条件;</span></span><br><span class="line">        srand(time(<span class="literal">NULL</span>)); <span class="comment">// 找一个随机数来作为每一个分区的基准数;</span></span><br><span class="line">        t = l + rand()%(r - l + <span class="number">1</span>);</span><br><span class="line">        swap(&amp;a[t], &amp;a[l]); <span class="comment">// 将这个基准数放在数组的末尾;</span></span><br><span class="line">        <span class="keyword">int</span> base = a[l]; <span class="comment">// 用base 来存储这个基准数;</span></span><br><span class="line">        i = l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j]&gt;= base) <span class="comment">// 从右向左找第一个小于x的数 </span></span><br><span class="line">                j--; </span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) </span><br><span class="line">                a[i++] = a[j]; </span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i]&lt; base) <span class="comment">// 从左向右找第一个大于等于x的数 </span></span><br><span class="line">                i++; </span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) </span><br><span class="line">                a[j--] = a[i]; </span><br><span class="line">        &#125; </span><br><span class="line">        a[i] = base; </span><br><span class="line">        quicksort(a, l, i - <span class="number">1</span>);</span><br><span class="line">        quicksort(a, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>快速排序的最坏情况基于每次划分对主元的选择。基本的快速排序选取第一个元素作为主元。这样在数组已经有序的情况下，每次划分将得到最坏的结果。一种比较常见的优化方法是随机化算法，即随机选取一个元素作为主元。这种情况下虽然最坏情况仍然是O(n^2)，但最坏情况不再依赖于输入数据，而是由于随机函数取值不佳。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n)。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn)的期望时间复杂度。一位前辈做出了一个精辟的总结：“随机化快速排序可以满足一个人一辈子的人品需求。” 随机化快速排序的唯一缺点在于，一旦输入数据中有很多的相同数据，随机化的效果将直接减弱。对于极限情况，即对于n个相同的数排序，随机化快速排序的时间复杂度将毫无疑问的降低到O(n^2)。解决方法是用一种方法进行扫描，使没有交换的情况下主元保留在原位置。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>C语言中可直接调用 qsort 快排函数,包含在 <code>#include&lt;algorithm&gt;</code> 头文件中, 它有四个参数，第一个为要排序的数组的 首地址，第二个参数为要排序的元素的个数，第三个参数为每个元素所占的空间大小，第四 个参数是需要自己写的比较函数,即告诉它应该按什么来排序.一种典型的写法如下: <code>qsort(s,n,sizeof(s[0]),cmp)</code> 下面具体介绍它的各种用法,主要是 cmp 函数的写法, cmp 函数有两个参数,均为 const void* 类型，有一个返回值，为 int 类型.</p><h4 id="对一维整型数组排序"><a href="#对一维整型数组排序" class="headerlink" title="对一维整型数组排序:"></a>对一维整型数组排序:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>*b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果整型数组为 a[] ,其中元素个数为n,则 <code>qsort(a,n,sizeof(a[0]),cmp)</code> 即完成了对 a[] 数组的 升序排序. 如果要按降序排列，可将 return <em>(int</em>)a - <em>(int</em>)b; 改为 return <em>(int</em>)b - <em>(int</em>)a;</p><h4 id="对-char-类型数组排序："><a href="#对-char-类型数组排序：" class="headerlink" title="对 char 类型数组排序："></a>对 char 类型数组排序：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">char</span>*)a - *(<span class="keyword">char</span>*)b; </span><br><span class="line">&#125; </span><br><span class="line">charword[<span class="number">100</span>]; </span><br><span class="line">qsort(word,<span class="number">100</span>,<span class="keyword">sizeof</span>(word[<span class="number">0</span>]),cmp);</span><br><span class="line"><span class="comment">//即完成了对word 中的字符按升序排列.</span></span><br></pre></td></tr></table></figure><h4 id="对-double-类型数组排序："><a href="#对-double-类型数组排序：" class="headerlink" title="对 double 类型数组排序："></a>对 double 类型数组排序：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> in[<span class="number">100</span>]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*a, <span class="keyword">const</span> <span class="keyword">void</span>*b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">double</span>*)a &gt; *(<span class="keyword">double</span>*)b ? <span class="number">1</span> : <span class="number">-1</span>; </span><br><span class="line">&#125; </span><br><span class="line">qsort(in,<span class="number">100</span>,<span class="keyword">sizeof</span>(in[<span class="number">0</span>]),cmp);</span><br></pre></td></tr></table></figure><p>值得注意的是，cmp 里不能像对 int 排序那样写 <code>return *(double*)a - *(double*)b</code> ,因为返回值 是整型，这样返回值是 double 会出错且不易察觉.</p><h4 id="对字符串排序："><a href="#对字符串排序：" class="headerlink" title="对字符串排序："></a>对字符串排序：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chars[<span class="number">100</span>][<span class="number">100</span>]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* x, <span class="keyword">const</span> <span class="keyword">void</span>* y)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>((<span class="keyword">char</span>*)x, (<span class="keyword">char</span>*)y); </span><br><span class="line">&#125; </span><br><span class="line">qsort(s, <span class="number">100</span>, <span class="keyword">sizeof</span>(s[<span class="number">0</span>]), cmp);</span><br></pre></td></tr></table></figure><h4 id="对结构体一级排序："><a href="#对结构体一级排序：" class="headerlink" title="对结构体一级排序："></a>对结构体一级排序：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b; </span><br><span class="line">&#125;s[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*x, <span class="keyword">const</span> <span class="keyword">void</span>*y)</span> </span>&#123;</span><br><span class="line">    node xx = *(node*)x;</span><br><span class="line">    node yy= *(node*)y; </span><br><span class="line">    <span class="keyword">return</span> xx.a - yy.a;</span><br><span class="line">&#125; </span><br><span class="line">qsort(s, <span class="number">100</span>, <span class="keyword">sizeof</span>(s[<span class="number">0</span>]), cmp); </span><br><span class="line"><span class="comment">//按 a 的升序对结构体 s 进行排序</span></span><br></pre></td></tr></table></figure><h4 id="对结构体二级排序"><a href="#对结构体二级排序" class="headerlink" title="对结构体二级排序:"></a>对结构体二级排序:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> a; <span class="keyword">int</span> b; </span><br><span class="line">&#125;s[<span class="number">100</span>]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* x, <span class="keyword">const</span> <span class="keyword">void</span>* y)</span> </span>&#123;</span><br><span class="line">    node xx = *(node*)x; </span><br><span class="line">    node yy = *(node*)y; </span><br><span class="line">    <span class="keyword">if</span>(xx.a != yy.a) <span class="keyword">return</span> xx.a - yy.a; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> xx.b - yy.b; </span><br><span class="line">&#125; </span><br><span class="line">qsort(s,<span class="number">100</span>,<span class="keyword">sizeof</span>(s[<span class="number">0</span>]),cmp); </span><br><span class="line"><span class="comment">//先按 a 进行升序排序，如果a 相同,按 b 的升序排列.</span></span><br></pre></td></tr></table></figure><h4 id="计算几何中求凸包的-cmp"><a href="#计算几何中求凸包的-cmp" class="headerlink" title="计算几何中求凸包的 cmp"></a>计算几何中求凸包的 cmp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> <span class="comment">// 重点 cmp 函数，把除了 1 点外的所有点，旋转角度排序 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> *<span class="title">c</span> = (<span class="title">point</span> *)<span class="title">a</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> *<span class="title">d</span> = (<span class="title">point</span> *)<span class="title">b</span>;</span> </span><br><span class="line">    <span class="keyword">if</span>(calc(*c,*d,p[<span class="number">1</span>]) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!calc(*c, *d, p[<span class="number">1</span>]) &amp;&amp; dis(c -&gt; x, c -&gt; y, p[<span class="number">1</span>].x, p[<span class="number">1</span>].y) &lt; dis(d -&gt; x, d -&gt; y, p[<span class="number">1</span>].x, p[<span class="number">1</span>].y)) <span class="comment">// 如果在一条直线上，则把远的放在前面 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sort-cmp-函数的写法"><a href="#Sort-cmp-函数的写法" class="headerlink" title="Sort cmp 函数的写法"></a>Sort cmp 函数的写法</h3><p>默认排序顺序为从小到大 <code>sort(arr, arr + n)</code><br>如果是没有定义小于运算的数据类型，或者想改变排序的顺序，就要用到第三参数——比较函数。比较函数是一个自己定义的函数，返回值是 bool 型，它规定了什么样的关系才是“小于”。想把刚才的整数数组按降序排列，可以先定义一个比较函数 cmp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>排序的时候就写 sort(a,a+100,cmp);<br>假设自己定义了一个结构体 node<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>有一个 node 类型的数组 node arr[100] ，想对它进行排序：先按 a 值升序排列，如果 a 值相同，再按 b 值降序排列，如果 b 还相同，就按 c 降序排列。就可以写这样一个比较函数：<br>以下是代码片段：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.a != y.a) <span class="keyword">return</span> x.a</span><br><span class="line">    <span class="keyword">if</span>(x.b != y.b) <span class="keyword">return</span> x.b &gt; y.b;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">return</span> x.c &gt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>排序时写 <code>sort(arr,a+100,cmp);</code></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个有序的子序列，再把有序的子序列合并为整体有序序列。归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。值得注意的是归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p>具体排序过程分成三个过程：</p><ol><li>分解：将当前区间一分为二，即求分裂点 mid = (low + high)/2;</li><li>求解：递归地对两个子区间 array[low..mid] 和 array[mid + 1..high] 进行归并排序；递归的终结条件：子区间长度为 1（一个记录自然有序）。</li><li>合并：将已排序的两个子区间R[low..mid]和R[mid + 1..high]归并为一个有序的区间 array[low..high]。<br>合并操作的过程如下：<br>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>4.重复步骤3直到某一指针到达序列尾<br>5.将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid, i, j, k;</span><br><span class="line">    <span class="keyword">if</span>(r - l &gt; <span class="number">1</span>)&#123; <span class="comment">// 递归结束条件;</span></span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        mergesort(a, l, mid); <span class="comment">// 分治思想的应用;</span></span><br><span class="line">        mergesort(a, mid, r);</span><br><span class="line">        i = l;</span><br><span class="line">        j = mid;</span><br><span class="line">        k = l;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; mid &amp;&amp; j &lt; r)&#123; <span class="comment">// 将每一个小区间[l, r) 中的元素排列到临时数组 c 中去;</span></span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt;= a[j])</span><br><span class="line">                c[k++] = a[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                c[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; mid; i++) <span class="comment">// 将剩余的元素放在后面;</span></span><br><span class="line">        c[k++] = a[i];</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; r; j++)</span><br><span class="line">            c[k++] = a[j];</span><br><span class="line">        <span class="keyword">for</span>(i = l; i &lt; r; i++)</span><br><span class="line">            a[i] = c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">20</span>] = &#123;<span class="number">0</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">8</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">19</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    mergesort(a, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度为O(nlogn) 这是该算法中最好、最坏和平均的时间性能。空间复杂度为 O(n)比较操作的次数介于(nlogn) / 2和nlogn - n + 1。赋值操作的次数是(2nlogn)。归并算法的空间复杂度为：0 (n)归并排序比较占用内存，但却是一种效率高且稳定的算法。</p><h3 id="其他作用-求逆序数"><a href="#其他作用-求逆序数" class="headerlink" title="其他作用(求逆序数)"></a>其他作用(求逆序数)</h3><p>修改合并排序在合并两个子序列时，出现右边元素小于左边元素的情况，亦即a[j] &lt; a[i]时，出现逆序对。此时a[i+1…n1]里的元素均比a[j]大，而a[j]又在它们的后面。所以，此时的逆序对数：n1-i。后面的元素以此类推。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt; mid &amp;&amp; j &lt; r)&#123; <span class="comment">// 将每一个小区间[l, r) 中的元素排列到临时数组 c 中去;</span></span><br><span class="line">    <span class="keyword">if</span>(a[i] &lt;= a[j])</span><br><span class="line">        c[k++] = a[i++];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        c[k++] = a[j++];</span><br><span class="line">        ans += mid – i; <span class="comment">// 在此处求逆序数;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="堆排序-详见数据结构-堆"><a href="#堆排序-详见数据结构-堆" class="headerlink" title="堆排序(详见数据结构, 堆)"></a>堆排序(详见数据结构, 堆)</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="用大根堆排序的基本思想"><a href="#用大根堆排序的基本思想" class="headerlink" title="用大根堆排序的基本思想"></a>用大根堆排序的基本思想</h4><ol><li>先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区</li><li>再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key</li><li>由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。<br>……<br>直到无序区只有一个元素为止。</li></ol><h4 id="大根堆排序算法的基本操作："><a href="#大根堆排序算法的基本操作：" class="headerlink" title="大根堆排序算法的基本操作："></a>大根堆排序算法的基本操作：</h4><ol><li>初始化操作：将R[1..n]构造为初始堆；</li><li><p>每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换，然后将新的无序区调整为堆（亦称重建堆）<br><strong>注意:</strong></p></li><li><p>只需做n-1趟排序，选出较大的n-1个关键字即可以使得文件递增有序。</p></li><li>用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。堆排序和直接选择排序相反：在任何时刻堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止</li></ol><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> heap[<span class="number">20</span>]; <span class="comment">// 用数组模拟堆;</span></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 堆中元素的数量;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Minheapsortdown</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> m)</span></span>&#123; <span class="comment">// 向下调整下标为i的元素直到合适的位置;</span></span><br><span class="line">    <span class="keyword">int</span> j, temp;</span><br><span class="line">    temp = heap[i]; <span class="comment">// 依然临时变量temp来记录该元素的值;</span></span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 令j等于其中一个儿子的值;</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; m &amp;&amp; heap[j + <span class="number">1</span>] &lt; heap[j]) <span class="comment">// 选择一个父节点下面较小的儿子来交换;</span></span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(heap[j] &gt;= temp) <span class="comment">// 当所有的儿子都大于该元素的时候, 停止;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        heap[i] = heap[j]; <span class="comment">// 否则, 将比较小的儿子放到父节点的位置;</span></span><br><span class="line">        i = j; <span class="comment">// 更新i和 j的值;</span></span><br><span class="line">        j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = temp; <span class="comment">// 将temp放到合适的位置;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeMinheap</span><span class="params">()</span></span>&#123; <span class="comment">// 对一个数组进行堆化操作;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 注意此处从n / 2 – 1 开始排列;</span></span><br><span class="line">    Minheapsortdown(I, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Minheapsort</span><span class="params">()</span></span>&#123; <span class="comment">// 堆排序;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        swap(&amp;heap[<span class="number">0</span>], &amp;heap[i]); <span class="comment">// 每次排序可以确定一个最小值(堆顶元素), 将其放在数组的末尾;</span></span><br><span class="line">        Minheapsortdown(<span class="number">0</span>, i); <span class="comment">// 每次排好 顶元素;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        heap[i] = -i;</span><br><span class="line">    n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; heap[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    makeMinheap();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; heap[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Minheapsort();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; heap[i] &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。平均性能O(N*logN)。</p><h3 id="其他性能"><a href="#其他性能" class="headerlink" title="其他性能"></a>其他性能</h3><p>由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。堆排序是就地排序，辅助空间为O(1）.它是不稳定的排序方法。</p><h3 id="STL-中的堆排序"><a href="#STL-中的堆排序" class="headerlink" title="STL 中的堆排序"></a>STL 中的堆排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">// 实现最小堆的比较函数;</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; hea; <span class="comment">// 定义堆;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">        hea.push_back(n); <span class="comment">// 向堆中添加数据, 并放在尾部;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"After make_heap: "</span>);</span><br><span class="line">    make_heap(hea.begin(), hea.end(), cmp);</span><br><span class="line">    for_each(hea.begin(), hea.end(), print);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"After sort_heap: "</span>);</span><br><span class="line">    sort_heap(hea.begin(), hea.end(), cmp); <span class="comment">// 堆排序函数, 从小到大排序;</span></span><br><span class="line">    for_each(hea.begin(), hea.end(), print);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="以上四种排序算法的总结"><a href="#以上四种排序算法的总结" class="headerlink" title="以上四种排序算法的总结"></a>以上四种排序算法的总结</h2><h3 id="时空复杂度和稳定性"><a href="#时空复杂度和稳定性" class="headerlink" title="时空复杂度和稳定性"></a>时空复杂度和稳定性</h3><p><img src="/images/2015/10/9hygfhc1976f7b67f2d.png" alt="9hygfhc1976f7b67f2d"><br>程序效率验证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="comment">//------------------------快速排序(普通)-------------------------- </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> i = l, j = r, x = s[l]; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[j] &gt;= x) <span class="comment">// 从右向左找第一个小于x的数 </span></span><br><span class="line">                j--; </span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) </span><br><span class="line">                s[i++] = s[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; s[i] &lt; x) <span class="comment">// 从左向右找第一个大于等于x的数 </span></span><br><span class="line">                i++; </span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) </span><br><span class="line">                s[j--] = s[i]; </span><br><span class="line">        &#125; </span><br><span class="line">        s[i] = x; </span><br><span class="line">        quick_sort(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span></span><br><span class="line">        quick_sort(s, i + <span class="number">1</span>, r); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//-----------------------快速排序(随机)--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123; <span class="comment">// 简单的交换函数;</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort1</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="comment">// 快排函数;</span></span><br><span class="line">    <span class="keyword">int</span> t, i, j;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123; <span class="comment">// 递归结束条件;</span></span><br><span class="line">        srand(time(<span class="literal">NULL</span>)); <span class="comment">// 找一个随机数来作为每一个分区的基准数;</span></span><br><span class="line">        t = l + rand()%(r - l + <span class="number">1</span>);</span><br><span class="line">        swap(&amp;a[t], &amp;a[l]); <span class="comment">// 将这个基准数放在数组的末尾;</span></span><br><span class="line">        <span class="keyword">int</span> base = a[l]; <span class="comment">// 用base 来存储这个基准数;</span></span><br><span class="line">        i = l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j]&gt;= base) <span class="comment">// 从右向左找第一个小于x的数 </span></span><br><span class="line">                j--; </span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) </span><br><span class="line">                a[i++] = a[j]; </span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i]&lt; base) <span class="comment">// 从左向右找第一个大于等于x的数 </span></span><br><span class="line">                i++; </span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) </span><br><span class="line">                a[j--] = a[i]; </span><br><span class="line">        &#125; </span><br><span class="line">        a[i] = base; </span><br><span class="line">        quick_sort(a, l, i - <span class="number">1</span>);</span><br><span class="line">        quick_sort(a, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------归并排序---------------------------- </span></span><br><span class="line"><span class="comment">//将有二个有序数列a[first...mid]和a[mid...last]合并。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergearray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> mid, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = first, j = mid + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">int</span> m = mid, n = last; </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= n) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) </span><br><span class="line">            temp[k++] = a[i++]; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            temp[k++] = a[j++]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m) </span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n) </span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">        a[first + i] = temp[i]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (first &lt; last) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>; </span><br><span class="line">        mergesort(a, first, mid, temp); <span class="comment">//左边有序 </span></span><br><span class="line">        mergesort(a, mid + <span class="number">1</span>, last, temp); <span class="comment">//右边有序 </span></span><br><span class="line">        mergearray(a, first, mid, last, temp); <span class="comment">//再将二个有序数列合并 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n]; </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    mergesort(a, <span class="number">0</span>, n - <span class="number">1</span>, p); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//------------------------堆排序--------------------------- </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> c = a; </span><br><span class="line">    a = b; </span><br><span class="line">    b = c; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//建立最小堆 </span></span><br><span class="line"><span class="comment">// 从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MinHeapFixdown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> j, temp;</span><br><span class="line"></span><br><span class="line">    temp = a[i]; </span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (j &lt; n) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; a[j + <span class="number">1</span>] &lt; a[j]) <span class="comment">//在左右孩子中找最小的 </span></span><br><span class="line">            j++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt;= temp) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        a[i] = a[j]; <span class="comment">//把较小的子结点往上移动,替换它的父结点 </span></span><br><span class="line">        i = j; </span><br><span class="line">        j = <span class="number">2</span> * i + <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    a[i] = temp; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//建立最小堆 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeMinHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        MinHeapFixdown(a, i, n); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MinheapsortTodescendarray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) </span><br><span class="line">    &#123; </span><br><span class="line">        Swap(a[i], a[<span class="number">0</span>]); </span><br><span class="line">        MinHeapFixdown(a, <span class="number">0</span>, i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000000</span>; </span><br><span class="line"><span class="keyword">int</span> a[MAXN]; </span><br><span class="line"><span class="keyword">int</span> b[MAXN], c[MAXN], d[MAXN], e[MAXN]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line">    srand(time(<span class="literal">NULL</span>)); </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXN; ++i) </span><br><span class="line">        a[i] = rand() * rand(); <span class="comment">//注rand()产生的数在0到0x7FFF之间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXN; ++i) </span><br><span class="line">        e[i] = d[i] = c[i] = b[i] = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">clock_t</span> ibegin, iend;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n == %d\n"</span>, MAXN); </span><br><span class="line">    <span class="comment">//快速排序 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"quick_sort: "</span>); </span><br><span class="line">    ibegin = clock(); </span><br><span class="line">    quick_sort(a, <span class="number">0</span>, MAXN - <span class="number">1</span>); </span><br><span class="line">    iend = clock(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d MS\n"</span>, iend - ibegin);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"quick_sort1: "</span>); </span><br><span class="line">    ibegin = clock(); </span><br><span class="line">    quick_sort(e, <span class="number">0</span>, MAXN - <span class="number">1</span>); </span><br><span class="line">    iend = clock(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d MS\n"</span>, iend - ibegin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MergeSort: "</span>); </span><br><span class="line">    ibegin = clock(); </span><br><span class="line">    MergeSort(b, MAXN); </span><br><span class="line">    iend = clock(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d MS\n"</span>, iend - ibegin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Heap_Sort: "</span>); </span><br><span class="line">    ibegin = clock(); </span><br><span class="line">    MakeMinHeap(c, MAXN); </span><br><span class="line">    MinheapsortTodescendarray(c, MAXN); </span><br><span class="line">    iend = clock(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d MS\n"</span>, iend - ibegin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//STL中的堆排序 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"STL_Heap_sort: "</span>); </span><br><span class="line">    ibegin = clock(); </span><br><span class="line">    make_heap(d, d + MAXN); </span><br><span class="line">    sort_heap(d, d + MAXN); </span><br><span class="line">    iend = clock(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d MS\n"</span>, iend - ibegin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h4><p><img src="/images/2015/10/ea90515b66073859aea470e10b25.png" alt="ea90515b66073859aea470e10b25"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>一个较大的工程往往被划分成许多子工程，我们把这些子工程称作活动(activity)。在整个工程中，有些子工程(活动)必须在其它有关子工程完成之后才能开始，也就是说，一个子工程的开始是以它的所有前序子工程的结束为先决条件的，但有些子工程没有先决条件，可以安排在任何时间开始。为了形象地反映出整个工程中各个子工程(活动)之间的先后关系，可用一个有向图来表示，图中的顶点代表活动(子工程)，图中的有向边代表活动的先后关系，即有向边的起点的活动是终点活动的前序活动，只有当起点活动完成之后，其终点活动才能进行。通常，我们把这种顶点表示活动、边表示活动间先后关系的有向图称做顶点活动网(Activity On Vertex network)，简称AOV网。对一个AOV网G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p><h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><p>由AOV网构造出拓扑序列的实际意义是：如果按照拓扑序列中的顶点次序，在开始每一项活动时，能够保证它的所有前驱活动都已完成，从而使整个工程顺序进行，不会出现冲突的情况。<br>由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。</p><ol><li>选择一个入度为0的顶点并输出之；</li><li>从网中删除此顶点及所有出边。<br>循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，否则输出的顶点序列就是一种拓扑序列。<br>下面以有图(a)为例，来说明拓扑排序算法的执行过程。</li><li>在(a)图中v0和v1的入度都为0，不妨选择v0并输出之，接着删去顶点v0及出边&lt;0,2&gt;，得到的结果如(b)图所示。</li><li>在(b)图中只有一个入度为0的顶点v1，输出v1，接着删去v1和它的三条出边&lt;1,2&gt;,&lt;1,3&gt;和&lt;1,4&gt;，得到的结果如(c)图所示。</li><li>在(c)图中v2和v4的入度都为0，不妨选择v2并输出之，接着删去v2及两条出边&lt;2,3&gt;和&lt;2,5&gt;，得到的结果如(d)图所示。</li><li>在(d)图上依次输出顶点v3,v4和v5，并在每个顶点输出后删除该顶点及出边，操作都很简单，不再赘述。为了利用C++语言在计算机上实现拓扑排序算法，AOV网采用邻接表表示较方便。如对于上图(a)，对应的邻接表如下图2.</li></ol><p><img src="/images/2015/10/5cd8e379de2db193077a008d3c9a.png" alt="5cd8e379de2db193077a008d3c9a"></p><p><img src="/images/2015/10/61d3c5a479d040129ba7b043a47c.png" alt="61d3c5a479d040129ba7b043a47c"></p><p>在拓扑排序算法中，需要设置一个包含n个元素的一维整型数组，假定用d表示，用它来保存AOV网中每个顶点的入度值。如对于上图(a)，得到数组d的初始值为<img src="/images/2015/10/20151029092343.png" alt="QQ截图20151029092343">在进行拓扑排序中，为了把所有入度为0的顶点都保存起来，而且又便于插入、删除以及节省存储，最好的方法是把它们链接成一个栈. 这里有两种方法，一种是再重新建一个栈用来存储入度为0 的点，另一种是直接用 d 数组来模拟栈操作，下面只介绍第二种。<br>例如，利用图2所示的邻接表，建立的入度为0的初始栈的过程为：</p><ol><li>开始置链栈为空，即给链栈指针top赋初值为-1： top=-1;<a href="/images/2015/10/fddasfsfds.png"></a></li><li>将入度为0的元素d[0]进栈，即： d[0]=top; top=0; 此时top指向d[0]元素，表示顶点v0的入度为0，而d[0]的值为-1，表明为栈底。</li><li>将入度为0的元素d[1]进栈，即: d[1]=top; top=1;此时top指向d[1]元素，表示顶点v1的入度为0，而d[1]的值为0，表明下一个入度为0的元素为d[0]，即对应下一个入度为0的顶点为v0，d[0]的值为-1，所以此栈当前有两个元素d[1]和d[0]。</li><li>因d[2]至d[5]的值均不为0，即对应的v2到v5的入度均不为0，所以它们均不进栈，至此，初始栈建立完毕，得到的数组d为:<br><img src="/images/2015/10/fddasfsfds.png" alt="fddasfsfds"><br>将入度为0的顶点利用上述链栈链接起来后，拓扑算法中循环执行的第(1)步“选择一个入度为0的顶点并输出之”，可通过输出栈顶指针top所代表的顶点序号来实现；第2 步“从AOV网中删除刚输出的顶点（假定为vj，其中j等于top的值）及所有出边”，可通过首先作退栈处理，使top指向下一个入度为0的元素，然后遍历vj的邻接点表，分别把所有邻接点的入度减1，若减1后的入度为0则令该元素进栈来实现。此外，该循环的终止条件“直到不存在入度为0的顶点为止”，可通过判断栈空来实现。</li></ol><p>对于上表，当删除由top值所代表的顶点v1及所有出边后，数组d变为：<br><img src="/images/2015/10/20151029091333.png" alt="QQ截图20151029091333">当依次删除top所表示的每个顶点及所有出边后，数组d的变化分别如下图所示：</p><p><img src="/images/2015/10/201510290923431.png" alt="QQ截图20151029092343"><br>当删除顶点v5及所有出边后，top的值为1，表示栈空，至此算法执行结束，得到的拓扑序列为：1,4,0,2,3,5.</p><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; vec[M]; <span class="comment">// 邻接表;</span></span><br><span class="line"><span class="keyword">int</span> ingree[M]; <span class="comment">// 存储节点的入度;</span></span><br><span class="line"><span class="keyword">int</span> ans[M]; <span class="comment">// 存储排序后的数字;</span></span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">// 点数;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TOSort</span><span class="params">()</span></span>&#123; <span class="comment">// 排序成功返回 true 否则返回 false;</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>; <span class="comment">// 栈顶;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 排序数组的指针;</span></span><br><span class="line">    fill(ingree, ingree + M, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">// 初始化入度数组, 统计所有点的入度;</span></span><br><span class="line">        <span class="keyword">int</span> end = vec[i].size();</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; end; j++)</span><br><span class="line">            ingree[vec[i][j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 初始化栈;</span></span><br><span class="line">    <span class="keyword">if</span>(ingree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">        ingree[i] = top;</span><br><span class="line">        top = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top != <span class="number">-1</span>)&#123; <span class="comment">// -1 为栈底;</span></span><br><span class="line">        <span class="keyword">int</span> t = top;</span><br><span class="line">        top = ingree[t];</span><br><span class="line">        ans[count++] = t;</span><br><span class="line">        <span class="keyword">int</span> end = vec[t].size();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; end; i++)&#123; <span class="comment">// 删除入度为零的点的边;</span></span><br><span class="line">            ingree[vec[t][i]]--;</span><br><span class="line">            <span class="keyword">if</span>(ingree[vec[t][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                ingree[vec[t][i]] = top;</span><br><span class="line">                top = vec[t][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); <span class="comment">// 输入点的个数, 和边的个数;</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b); <span class="comment">// a -&gt; b 边;</span></span><br><span class="line">        vec[a].push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(TOSort())</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], i == n - <span class="number">1</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"有环\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>拓扑排序实际上是对邻接表表示的图G进行遍历的过程，每次访问一个入度为0的顶点。若图G中没有回路，则需要扫描邻接表中的所有边结点，再加上在算法开始时，为建立入度数组d需要访问表头向量中的每个域和其单链表中的每个结点，所以此算法的时间复杂性为O(n+e)。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例1-POJ-1094"><a href="#例1-POJ-1094" class="headerlink" title="例1: POJ 1094"></a>例1: <a href="http://poj.org/problem?id=1094" target="_blank" rel="noopener">POJ 1094</a></h4><p><strong>题目描述:</strong> 输入的第一行有两个数字, n 和 m, n 指有n 个字母(从A开始的n 个), m 表示有m条信息, 接下来的m行信息的格式为: 字母1&lt;字母2(例如A&lt;B), m条信息后, 会有三种可能, 在第i个信息就能判断出n个字母的排序输出” Sorted sequence determined after i relations: ABCD…..”, 中间出现矛盾(A&lt;B, B&lt;A), 输出” Inconsistency found after i relations.”, 或者最终也没有一个唯一的排序输出” Sorted sequence cannot be determined.”</p><p><strong>解题思路:</strong> 需要注意的是题目要求输出的几种情况的优先级, 首先优先级最高的是出现矛盾, 也就是如果出现了答案不唯一的情况之后出现了矛盾，那最终答案为矛盾; 如果拓扑序唯一确定之后出现了矛盾, 那最终答案为输出拓扑序.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, nxt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">Edge edge[MAXM];</span><br><span class="line"><span class="keyword">int</span> n, m, ecnt, num;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], deg[MAXN], res[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num = ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res));</span><br><span class="line">    <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u] = ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * return 0: 拓扑序不唯一</span></span><br><span class="line"><span class="comment"> * return cnt: 拓扑序唯一且排序完毕</span></span><br><span class="line"><span class="comment"> * return -1: 矛盾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span>(deg));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; <span class="number">26</span>; u++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; i = edge[i].nxt)</span><br><span class="line">            deg[edge[i].v]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(!deg[i] &amp;&amp; vis[i]) que.push(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.size() &gt; <span class="number">1</span>) flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> top = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        res[cnt++] = top;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[top]; i + <span class="number">1</span>; i = edge[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(deg[edge[i].v] &amp;&amp; vis[edge[i].v])&#123;</span><br><span class="line">                deg[edge[i].v]--;</span><br><span class="line">                <span class="keyword">if</span>(deg[edge[i].v] == <span class="number">0</span> &amp;&amp; vis[edge[i].v]) que.push(edge[i].v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != num) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(n + m)) <span class="keyword">break</span>;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">char</span> a, b;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, dx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c&lt;%c"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(!vis[a - <span class="string">'A'</span>]) vis[a - <span class="string">'A'</span>] = <span class="literal">true</span>, num++; </span><br><span class="line">            <span class="keyword">if</span>(!vis[b - <span class="string">'A'</span>]) vis[b - <span class="string">'A'</span>] = <span class="literal">true</span>, num++; </span><br><span class="line">            addEdge(a - <span class="string">'A'</span>, b - <span class="string">'A'</span>);</span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = toSort();</span><br><span class="line">                <span class="keyword">if</span>(tmp == <span class="number">-1</span>) ans = tmp, dx = i;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tmp == n &amp;&amp; ans == <span class="number">0</span>) ans = tmp, dx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"Inconsistency found after %d relations.\n"</span>, dx);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Sorted sequence determined after %d relations: "</span>, dx);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>, res[i] + <span class="string">'A'</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">".\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Sorted sequence cannot be determined.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例2-POJ-3687"><a href="#例2-POJ-3687" class="headerlink" title="例2: POJ 3687"></a>例2: <a href="http://poj.org/problem?id=3687" target="_blank" rel="noopener">POJ 3687</a></h4><p><strong>题目描述:</strong> 标号为 1~n 的 N 个球，满足给定的 M 个编号约束关系，输出最终满足关系的球的标号。</p><p><strong>解题思路:</strong></p><ol><li><p>相互之间有一定的约束关系，会联系到拓扑排序，如果利用拓扑排序去解决本题还需要一定的贪心思想;</p></li><li><p>因为要保证标号小的球靠前的优先级越高，所以对于正向图拓扑排序，无法满足，比如：&lt;1, 4&gt; &lt;4, 2&gt; &lt;3, 5&gt;</p></li><li><p>对于反向拓扑排序，用同样的方法只需要保证标号大的球尽量靠后就行了，具体见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">210</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> arr[MAXN], indeg[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (G[u][i] == v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cases;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cases);</span><br><span class="line">    <span class="keyword">while</span> (cases--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            G[i].clear(), indeg[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v, &amp;u);</span><br><span class="line">            <span class="keyword">if</span> (judge(u, v)) &#123;</span><br><span class="line">                G[u].push_back(v);</span><br><span class="line">                indeg[v] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">for</span> (w = n; w &gt;= <span class="number">1</span>; w--) &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (!indeg[i]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            arr[i] = w;</span><br><span class="line">            indeg[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = G[i][j];</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] &gt; <span class="number">0</span>) indeg[v] -= <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, arr[i], i == n ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序法&quot;&gt;&lt;a href=&quot;#快速排序法&quot; class=&quot;headerlink&quot; title=&quot;快速排序法&quot;&gt;&lt;/a&gt;快速排序法&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;快速排序（Quicksort）是对冒泡排序的一种改进。由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列.
    
    </summary>
    
      <category term="算法" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://blog.andrewei.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://blog.andrewei.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最短路径</title>
    <link href="https://blog.andrewei.me/2015/10/28/e6-9c-80-e7-9f-ad-e8-b7-af-e5-be-84/"/>
    <id>https://blog.andrewei.me/2015/10/28/e6-9c-80-e7-9f-ad-e8-b7-af-e5-be-84/</id>
    <published>2015-10-28T11:47:36.000Z</published>
    <updated>2018-04-09T01:16:07.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最短路径问题是图论研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。 算法具体的形式包括：<a id="more"></a></p><ol><li>确定起点的最短路径问题 - 即已知起始结点，求最短路径的问题。</li><li>确定终点的最短路径问题 - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。</li><li>确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。</li><li>全局最短路径问题 - 求图中所有的最短路径。</li></ol><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><p>用于解决最短路径问题的算法被称做“最短路径算法”， 有时被简称作“路径算法”。 最常用的路径算法有：</p><ol><li>Dijkstra 算法</li><li>A*算法</li><li>SPFA 算法</li><li>Bellman-Ford 算法</li><li>Floyd-Warshall 算法</li><li>Johnson 算法<br>所谓单源最短路径问题是指：已知图 G=（V，E），我们希望找出从某给定的源结点 S∈V 到 V 中的每个结点的最短路径。</li></ol><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>设 G=(V,E)是一个带权有向图，把图中顶点集合 V 分成两组，第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，以后每求得一条最短路径 , 就将加入到集合 S 中，直到全部顶点都加入到 S 中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中。在加入的过程中，总保持从源点 v 到 S 中各顶点的最短路径长度不大于从源点 v 到 U 中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S 中的顶点的距离就是从 v 到此顶点的最短路径长度，</p><p>U 中的顶点的距离，是从 v 到此顶点只包括 S 中的顶点为中间顶点的当前最短路径长度。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>初始时，S 只包含源点，即 $S＝{v}$，v 的距离为 0。U 包含除 v 外的其他顶点，即:U={其余顶点}，若 v 与 U 中顶点 u 有边，则&lt;u,v&gt;正常有权值，若 u 不是 v 的出边邻接点，则$&lt;u,v&gt;$权值为∞。</li><li>从 U 中选取一个距离 v 最小的顶点 k，把 k，加入 S 中（该选定的距离就是 v 到 k 的最短路径长度）。</li><li>以 k 为新考虑的中间点，修改 U 中各顶点的距离；若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值的顶点 k 的距离加上边上的权。</li><li>重复步骤 b 和 c 直到所有顶点都包含在 S 中。</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/images/2015/10/shortest_rude.png" alt=""></h3><h3 id="示例代码（邻接表-优先队列）"><a href="#示例代码（邻接表-优先队列）" class="headerlink" title="示例代码（邻接表+优先队列）"></a>示例代码（邻接表+优先队列）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (1 &lt;&lt; 30) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> v, w, n; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Struct Node&#123;    </span><br><span class="line">    <span class="keyword">int</span> v, w; </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w &gt; b.w; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], dis[N], n, m, e; <span class="keyword">bool</span> vis[N];</span><br><span class="line">Edge edge[N * /<span class="number">2</span>]; </span><br><span class="line">priority_queue &lt; Node &gt; que; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    e = <span class="number">0</span>;     </span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) que.pop();</span><br><span class="line">    fill(head, head + N, <span class="number">-1</span>);</span><br><span class="line">    fill(dis, dis + N, M);     </span><br><span class="line">    fill(vis, vis + N, <span class="literal">false</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;     </span><br><span class="line">    edge[e].v = v;     </span><br><span class="line">    edge[e].w = w;     </span><br><span class="line">    edge[e].n = head[u];</span><br><span class="line">    head[u] = e++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;     </span><br><span class="line">    Node t;     </span><br><span class="line">    t.v = s; </span><br><span class="line">    t.w = <span class="number">0</span>;     </span><br><span class="line">    dis[t.v] = t.w;     </span><br><span class="line">    que.push(t);     </span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;         </span><br><span class="line">        t = que.top();         </span><br><span class="line">        que.pop();         </span><br><span class="line">        <span class="keyword">if</span>(vis[t.v]) <span class="keyword">continue</span>;        </span><br><span class="line">        vis[t.v] = <span class="literal">true</span>;         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[t.v]; i != <span class="number">-1</span>; i = edge[i].n) </span><br><span class="line">            <span class="keyword">if</span>(!vis[edge[i].v] &amp;&amp; dis[edge[i].v] &gt; dis[t.v] + edge[i].w)&#123;                 </span><br><span class="line">                Node tt;                 </span><br><span class="line">                tt.v = edge[i].v; </span><br><span class="line">                dis[edge[i].v] = tt.w = dis[t.v] + edge[i].w;                 </span><br><span class="line">                que.push(tt); </span><br><span class="line">            &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF &amp;&amp; n)&#123;         </span><br><span class="line">        init();        </span><br><span class="line">        <span class="keyword">int</span> a, b, c;         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;             </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);             </span><br><span class="line">            addedge(a, b, c);             </span><br><span class="line">            addedge(b, a, c); </span><br><span class="line">        &#125; </span><br><span class="line">        Dijkstra(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[n]); </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>邻接矩阵 $O(n^{2})$, 邻接表+优先队列 $O(e logv)$.</p><h2 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>弗洛伊德（Floyd）算法过程：</p><ol><li>用 $D[v][w]$记录每一对顶点的最短距离。</li><li>依次扫描每一个点，并以其为基点再遍历所有每一对顶点 D[][]的值，看看是否可用过该基点让这对顶点间的距离更小。</li></ol><h3 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h3><p>最短距离有三种情况：</p><ul><li>两点的直达距离最短。（如下图&lt;v,x&gt;）</li><li>两点间只通过一个中间点而距离最短。（图&lt;v,u&gt;）</li><li>两点间用通过两各以上的顶点而距离最短。（图&lt;v,w&gt;）<br>对于第一种情况：在初始化的时候就已经找出来了且以后也不会更改到。对于第二种情况：弗洛伊德算法的基本操作就是对于每一对顶点，遍历所有其它顶点，看看可否通过这一个顶点让这对顶点距离更短，也就是遍历了图中所有的三角形（算法中对同一个三角形扫描了九次，原则上只用扫描三次即可，但要加入判断，效率更低）。</li></ul><p>对于第三种情况：如下图的五边形，可先找一点（比如 x，使$&lt;v,u&gt;=2$），就变成了四边形问题，再找一点（比如 y,使&lt;u,w&gt;=2），可变成三角形问题了（v,u,w），也就变成第二种情况了，由此对于 n 边形也可以一步步转化成四边形三角形问题。（这里面不用担心哪个点要先找哪个点要后找，因为找了任一个点都可以使其变成（n－1）边形的问题）。结合代码 并参照上图所示 我们来模拟执行下 这样才能加深理解：</p><p>第一关键步骤：当 k 执行到 x，i=v,j=u 时，计算出 v 到 u 的最短路径要通过 x，此时 v、u 联通了。<img src="/images/2015/10/1.jpg" alt=""></p><p>第二关键步骤：当 k 执行到 u，i=v，j=y，此时计算出 v 到 y 的最短路径的最短路径为 v 到 u，再到 y(此时 v 到 u 的最短路径上一步我们已经计算过来，直接利用上步结果)。</p><p>第三关键步骤：当 k 执行到 y 时，i=v，j=w，此时计算出最短路径为 v 到 y(此时 v 到 y 的最短路径长在第二步我们已经计算出来了)，再从 y 到 w。</p><p><strong>依次扫描每一点**</strong>(k)<strong><strong>，并以该点作为中介点，计算出通过 </strong></strong>k <strong><strong>点的其他任意两点</strong></strong>(i,j)<strong><strong>的最短距离，这就是 </strong></strong>floyd <strong>**算法的精髓！</strong></p><p>同时也解释了为什么 k 点这个中介点要放在最外层循环的原因.</p><p><strong>动态规划的解释：</strong></p><p>在动态规划算法中，处于首要位置、且也是核心理念之一的就是状态的定义。在这里，把 d[k][i][j]定义成：</p><p>“只能使用第 1 号到第 k 号点作为中间媒介时，点 i 到点 j 之间的最短路径长度。”</p><p>图中共有 n 个点，标号从 1 开始到 n。因此，在这里，k 可以认为是动态规划算法在进行时的一种层次，或者称为“松弛操作”。d[1][i][j]表示只使用 1 号点作为中间媒介时，点 i 到点 j 之间的最短路径长度；d[2][i][j]表示使用 1 号点到 2 号点中的所有点作为中间媒介时，点 i 到点 j 之间的最短路径长度；d[n-1][i][j]表示使用 1 号点到 (n-1)号点中的所有点作为中间媒介时，点 i 到点 j 之间的最短路径长度 d[n][i][j]表示使用 1 号到 n 号点时，点 i到点 j 之间的最短路径长度。有了状态的定义之后，就可以根据动态规划思想来构建动态转移方程。</p><p>动态转移的基本思想可以认为是建立起某一状态和之前状态的一种转移表示。按照前面的定义，d[k][i][j]是一种使用 1 号到 k 号点的状态，可以想办法把这个状态通过动态转移，规约到使用 1 号到(k-1)号的状态，即 d[k1][i][j]。对于 d[k][i][j]（即使用 1 号到 k 号点中的所有点作为中间媒介时，i 和 j 之间的最短路径），可以分为两种情况：（1）i 到 j 的最短路不经过 k；（2）i 到 j 的最短路经过了 k。不经过点 k 的最短路情况下，$d[k][i][j]=d[k1][i][j]$。经过点 k 的最短路情况下，$d[k][i][j]=d[k-1][i][k]+d[k-1][k][j]$。因此，综合上述两种情况，便可以得到 Floyd 算法的动态转移方程：$$d[k][i][j] = min(d[k-1][i][j], d[k-1][i][k]+d[k-1][k][j]) (k,i,j \epsilon [1,n])$$</p><p>最后，d[n][i][j]就是所要求的图中所有的两点之间的最短路径的长度。在这里，需要注意上述动态转移方程的初始（边界）条件，即 d[0][i][j]=w(i, j)，也就是说在不使用任何点的情况下（“松弛操作”的最初），两点之间最短路径的长度就是两点之间边的权值（若两点之间没有边，则权值为 INF，且我比较偏向在 Floyd 算法中把图用邻接矩阵的数据结构来表示，因为便于操作）。当然，还有 $d[i][i]=0(i\epsilon [1,n])$。</p><p>这样我们就可以编写出最为初步的 Floyd 算法代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd_original</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)             </span><br><span class="line">            d[<span class="number">0</span>][i][j] = graph[i][j];     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;             </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123; </span><br><span class="line">                d[k][i][j] = min(d[k<span class="number">-1</span>][i][j], d[k<span class="number">-1</span>][i][k] + d[k<span class="number">-1</span>][k][j]); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>几乎所有介绍动态规划中最为著名的“0/1 背包”问题的算法书籍中，都会进一步介绍利用滚动数组的技巧来进一步减少算<br>的空<br>间复杂度，使得 0/1 背包只需要使用一维数组就可以求得最优解。而在各种资料中，最为常见的 Floyd 算法也都是用了二维数组来表示状态。那么，在 Floyd 算法中，是如何运用滚动数组的呢？</p><p>再次观察动态转移方程 $$d[k][i][j] = min(d[k-1][i][j], d[k-1][i][k]+d[k-1][k][j])$$ <span style="line-height: 1.5;">可以发现每一个第 k 阶段的状态（d[k][i][j]），所依赖的都是前一阶段（即第 k-1 阶段）的状态（如 d[k-1][i][</span><span style="line-height: 1.5;">j]，d[k-1][i][k]和 d[k-1][k][j]）。</span></p><p>右图描述了在前面最初试的 Floyd 算法中，计算状态 d[k][i][j]时，d[k-1][][]和 d[k][][]这两个二维数组的情况（d[k-1][][]表示第 k-1 阶段时，图中两点之间最短路径长度的二维矩阵；d[k][][]表示第 k 阶段时，图中两点之间最短路径长度的二维矩阵）。红色带有箭头的有向线段指示了规划方向。灰色表示已经算过的数组元素，白色代表还未算过的元素。由于 d[k-1][][]和 d[k][][]是两个相互独立的二维数组，因此利用 d[k-1][i][j]，d[k-1][i][k] 和 d[k-1][k][j]（皆处于上方的二维数组中）来计算 d[k][i][j]时没有任何问题。</p><p>那如何利用一个二维数组来实现滚动数组，以减小空间复杂度呢？</p><p>右图是使用滚动数组，在第 k 阶段，计算 d[i][j]时的情况。此时，由于使用 d[][]这个二维数组作为滚动数组，在各个阶段的计算中被重复使用，因此数组中表示阶段的那一维也被取消了。在这图中，白色的格子，代表最新被计算过的元素（即第 k 阶段的新值），而灰色的格子中的元素值，其实保存的还是上一阶段（即第 k-1 阶段）的旧值。因此，在新的 d[i][j]还未被计算出来时，d[i][j]中保存的值其实就对应之前没有用滚动数组时 d[k-1][i][j] 的值。此时，动态转移方程在隐藏掉阶段索<br>引后就变为：$$d[i][j] = min(d[i][j], d[i][k]+d[k][j]) (k,i,j\epsilon [1,n])$$ 赋值号左侧 d[i][j]就是我们要计算的第 k 阶段是 i 和 j 之间的最短路径长度。在这里，需要确保赋值号右侧的d[i][j], d[i][k]和 d[k][j]的值是上一阶段（k-1 阶段）的值。前面已经分析过了，在新的 d[i][j]算出之前，d[i][j]元素保留的值的确就是上一阶段的旧值。但至于 d[i][k]和 d[k][j]呢？我们无法确定这两个元素是落在白色区域（新值）还是灰色区域（旧值）。好在有这样一条重要的性质，dp[k-1][i][k]和 dp[k-1][k][j]是不会在第 k 阶段改变大小的。也就是说，凡是和 k 节点相连的边，在第 k 阶段的值都不会变。如何简单证明呢？我们可以把 j=k 代入之前的$$ d[k][i][j]=min(d[k-1][i][j], d[k-1][i][k]+d[k-1][k][j]) $$方程中，即：</p><p>$$d[k][i][k]</p><p>= min(d[k-1][i][k], d[k-1][i][k]+d[k-1][k][k])</p><p>= min(d[k-1][i][k], d[k-1][i][k]+0)</p><p>= d[k-1][i][k]$$</p><p>也就是说在第 k-1 阶段和第 k 阶段，点 i 和点 k 之间的最短路径长度是不变的。相同可以证明，在这两个阶段中，点 k 和点 j 之间的的最短路径长度也是不变的。因此，对于使用滚动数组的转移方程$$ d[i][j] = min(d[i][j], d[i][k]+d[k][j]) $$来说，赋值号右侧的 d[i][j], d[i][k]和 d[k][j]的值都是上一阶段（k-1 阶段）的值，可以放心地被用来计算第 k 阶段时 d[i][j]的值。</p><p><img src="/images/2015/10/2.jpg" alt=""><br><img src="/images/2015/10/3.jpg" alt=""></p><p>利用滚动数组改写后的 Floyd 算法代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)  </span><br><span class="line">                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，通过这篇文章的分析，我们可以发现，Floyd 算法的的确确是一种典型的动态规划算法；理解 Floyd 算法，也可以帮助我们进一步理解动态规划思想。</p><h3 id="示例代码（含记录路径）"><a href="#示例代码（含记录路径）" class="headerlink" title="示例代码（含记录路径）"></a>示例代码（含记录路径）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (1 &lt;&lt; 20) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[N][N], path[N][N]; </span><br><span class="line"><span class="keyword">int</span> n, m; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)              <span class="comment">// 初始化 path 数组         </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)             </span><br><span class="line">            path[i][j] = i;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)             </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)                 </span><br><span class="line">                <span class="keyword">if</span>(mp[i][k] + mp[k][j] &lt; mp[i][j])&#123;                     </span><br><span class="line">                    mp[i][j] = mp[i][k] + mp[k][j];                     </span><br><span class="line">                    path[i][j] = path[k][j]; </span><br><span class="line">                &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 输入图 */</span> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)             </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;                 </span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);                 </span><br><span class="line">                mp[i][j] = mp[i][j]; </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 求解 */</span>         </span><br><span class="line">        floyd(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 输出 */</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Origin -&gt; Dest      Distance        Path\n"</span>);        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;             </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;                 </span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;                 </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"     %d -&gt; %d          "</span>, i + <span class="number">1</span>, j + <span class="number">1</span>);                 </span><br><span class="line">                <span class="keyword">if</span>(mp[i][j] == M) <span class="built_in">printf</span>(<span class="string">"No answer\n"</span>);                 </span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%2d             "</span>, mp[i][j]);                 </span><br><span class="line">                <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; sta;                 </span><br><span class="line">                <span class="keyword">int</span> k = j;                 </span><br><span class="line">                <span class="keyword">do</span>&#123;                     </span><br><span class="line">                    k = path[i][k];                     </span><br><span class="line">                    sta.push(k);                 </span><br><span class="line">                &#125;<span class="keyword">while</span>(k != i); </span><br><span class="line">                <span class="keyword">while</span>(!sta.empty()) <span class="built_in">printf</span>(<span class="string">"%d -&gt; "</span>, sta.top() + <span class="number">1</span>), sta.pop();                 </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, j + <span class="number">1</span>); </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用-Floyd-算法思想求最小环"><a href="#用-Floyd-算法思想求最小环" class="headerlink" title="用 Floyd 算法思想求最小环"></a>用 <strong>Floyd </strong>算法思想求最小环</h3><p>Floyd 算法在进行时会不断更新矩阵 dist(k)。设 dist[k，i，j]表示从结点 i 到结点 j 且满足所有中间结点，它们均属于集合{1，2，⋯ ，k}的一条最短路径的权。其中 dist[0，i,j ]即为初始状态 i 到 j 的直接距离。对于一个给定的赋权有向图， 求出其中权值和最小的一个环。我们可以将任意一个环化成如下形式：u-&gt;k-&gt;v -&gt;(x1-&gt; x2-&gt; ⋯ xm1)-&gt; u(u 与 k、k 与 v 都是直接相连的)，其中 v -&gt;(x1-&gt; 2-&gt; ⋯ m)-&gt; u 是指 v 到 u 不经过 k 的一种路径。</p><p>在 u，k，v 确定的情况下，要使环权值最小， 则要求 (x1 一&gt;x2-&gt;⋯一&gt;xm)-&gt;u 路径权值最小．即要求其为 v 到 u 不经过 k 的最短路径，则这个经过 u，k，v 的环的最短路径就是：[v 到 u 不包含 k 的最短距离]+dist[O， u，k]+dist[O，k，v]。我们用 Floyd 只能求出任意 2 点间满足中间结点均属于集合{1，2，⋯ ，k}的最短路径，可是我们如何求出 v 到 u 不包含 k 的最短距离呢?</p><p>现在我们给 k 加一个限制条件：k 为当前环中的序号最大的节点(简称最大点)。因为 k 是最大点，所以当前环中没有任何一个点≥k，即所有点都 &lt; k。因为 v-&gt;(x1-&gt;x2-&gt;……xm)-&gt;u 属于当前环，所以 x1，x2，⋯ ， xm &lt; k，即 x1，x2．⋯。xm≤k-1。这样，v 到 u 的最短距离就可以表示成 dist[k - 1 ,u,v]。dist[k - 1,v,u]表示的是从 v 到 u 且满足所有中间结点均属于集合{1，2，⋯ ，k - 1}的一条最短路径的权。接下来，我们就可以求出 v 到 u 不包含 k 的最短距离了。这里只是要求不包含 k，而上述方法用的是 dist[k - 1，v，u]，求出的路径永远不会包含 k+l，k+2，⋯ 。万一所求的最小环中包含 k+1，k+2，⋯ 怎么办呢?的确，如果最小环中包含比 k 大的节点，在当前 u,k,v 所求出的环显然不是那个最小环。然而我们知道，这个最小环中必定有一个最大点 kO，也就是说，虽然当前 k 没有求出我们所需要的最小环，但是当我们从 k 做到 kO 的时候，这个环上的所有点都小于 kO 了．也就是说在 k=kO 时一定能求出这个最小环。我们用一个实例来说明：假设最小环为 1—3—4—5—6—2—1。的确，在 u=l，v=4，k=3 时，k&lt;6，dist[3，4，1]的确求出的不是 4—5—6—2—1 这个环，但是，当 u=4，v=6，k=5 或 u=5，v=2，k=6 时，dist[k，v，u]表示的都是这条最短路径.所以我们在 Floyd 以后，只要枚举 u, v, k 三个变量即可求出最小环。时间复杂度为 O(n3)。我们可以发现，Floyd 和最后枚举 u, v, k 三个变量求最小环的过程都是 u,v,k 三个变量，所以我们可以将其合并。这样，我们在 k 变量变化的同时，也就是进行 Floyd 算法的同时，寻找最大点为 k 的最小环。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1100 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (1 &lt;&lt; 29) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[N][N], dis[N][N]; </span><br><span class="line"><span class="keyword">int</span> path[N], pre[N][N]; </span><br><span class="line"><span class="keyword">int</span> n, m, minc, num; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;             </span><br><span class="line">            mp[i][j] = M;             </span><br><span class="line">            dis[i][j] = M;             </span><br><span class="line">            pre[i][j] = i; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        <span class="keyword">if</span>(w &lt; mp[a][b])</span><br><span class="line">            dis[a][b] = dis[b][a] = mp[a][b] = mp[b][a] = w; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    minc = M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; j++)</span><br><span class="line">                <span class="keyword">if</span>(minc &gt; dis[i][j] + mp[j][k] + mp[k][i])&#123;</span><br><span class="line">                    minc = dis[i][j] + mp[j][k] + mp[k][i];</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> t = j;</span><br><span class="line">                    <span class="keyword">while</span>(t != i)&#123;</span><br><span class="line">                        path[num++] = t;</span><br><span class="line">                        t = pre[i][t];</span><br><span class="line">                    &#125;</span><br><span class="line">                    path[num++] = i;</span><br><span class="line">                    path[num++] = k;</span><br><span class="line">                &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span>(dis[i][j] &gt; dis[i][k] + dis[k][j])&#123;</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">                    pre[i][j] = pre[k][j]; </span><br><span class="line">                &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) !=EOF)&#123;</span><br><span class="line">        init();</span><br><span class="line">        Floyd();</span><br><span class="line">        <span class="keyword">if</span>(minc == M) <span class="built_in">printf</span>(<span class="string">"No solution.\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, path[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>, path[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>$O(n ^{3})$</p><h2 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Bellman-ford 算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写。即进行不停地松弛每次松弛把每条边都更新一下，若 n-1 次松弛后还能更新，则说明图中有负环，无法得出结果，否则就成功完成。Bellmanford 算法有一个小优化：每次松弛先设一个旗帜 flag，初值为 FALSE，若有边更新则赋值为 TRUE，最终如果还是 FALSE 则直接成功退出。Bellman-ford 算法浪费了许多时间做无必要的松弛。Dijkstra 算法中不允许边的权是负权，如果遇到负权，则可以采用 Bellman-Ford 算法。</p><p>Bellman-Ford 算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。对于给定的带权（有向或无向）图 G=（V,E），其源点为 s，加权函数 w 是 边集 E 的映射。对图 G 运行 Bellman-Ford 算法的结果是一个布尔值，表明图中是否存在着一个从源点 s 可达的负权回路。若不存在这样的回路，算法将给出从源点 s 到 图</p><p>G 的任意顶点 v 的最短路径 d[v]。</p><h3 id="适用条件-amp-范围"><a href="#适用条件-amp-范围" class="headerlink" title="适用条件&amp;范围"></a>适用条件<strong>&amp;</strong>范围</h3><p>1.单源最短路径(从源点 s 到其它所有顶点 v);</p><p>2.有向图&amp;无向图(无向图可以看作(u,v),(v,u)同属于边集 E 的有向图);</p><p>3.边权可正可负(如有负权回路输出错误提示);</p><p>4.差分约束系统;</p><h3 id="Bellman-Ford-算法描述"><a href="#Bellman-Ford-算法描述" class="headerlink" title="Bellman-Ford 算法描述"></a><strong>Bellman-Ford </strong>算法描述</h3><p>1,.初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0;</p><p>2.迭代求解：反复对边集 E 中的每条边进行松弛操作，使得顶点集 V 中的每个顶点 v 的最短距离估计值逐步逼近其最短距离；（运行|v|-1 次）</p><p>3.检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回 true，并且从源点可达的顶点 v 的最短距离保存在 d[v]中。</p><h3 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h3><p>首先指出，图的任意一条最短路径既不能包含负权回路，也不会包含正权回路，因此它最多包含|v|-1 条边。   其次，从源点 s 可达的所有顶点如果 存在最短路径，则这些最短路径构成一个以 s 为根的最短路径树。</p><p>Bellman-Ford 算法的迭代松弛操作，实际上就是按顶点距离 s 的层次，逐层生成这棵最短路径树的过程。</p><p>在对每条边进行 1 遍松弛的时候，生成了从 s 出发，层次至多为 1 的那些树枝。也就是说，找到了与 s 至多有 1 条边相联的那些顶点的最短路径；对每条边进行第 2 遍松弛的时候，生成了第 2 层次的树枝，就是说找到了经过 2 条边相连的那些顶点的最短路径……。因为最短路径最多只包含|v|-1 条边，所以，只需要循环|v|-</p><p>1 次。</p><p>每实施一次松弛操作，最短路径树上就会有一层顶点达到其最短距离，此后这层顶点的最短距离值就会一直保持不变，不再受后续松弛操作的影响。（但是，每次还要判断松弛，这里浪费了大量的时间，怎么优化？单纯的优化是否可行？）   如果没有负权回路，由于最短路径树的高度最多只能是|v|-1，所以最多经过|v|-1 遍松弛操作后，所有从 s 可达的顶点必将求出最短距离。如果 d[v]仍保持 +∞，则表明从 s 到 v 不可达。</p><p>如果有负权回路，那么第 |v|-1 遍松弛操作仍然会成功，这时，负权回路上的顶点不会收敛。</p><h3 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h3><p>首先介绍一下松弛计算。如图：松弛计算之前，点 B 的值是 8，但是点 A 的值加上边上的权重 2，得到 5，比点 B 的值（8）小，所以，点 B 的值减小为 5。这个过程的意义是，找到了一条通向 B 点更短的路线，且该路线是先经过点 A，然后通过权重为 2 的边，到达点B。</p><p>Bellman－Ford 算法可以大致分为三个部分<img src="/images/2015/10/20151027144908.png" alt=""></p><p>第一，初始化所有点。每一个点保存一个值，表示从原点到达这个点的距离，将原点的值设为 0，其它的点的值设为无穷大（表示不可达）。</p><p>第二，进行循环，循环下标为从 1 到 n－1（n 等于图中点的个数）。在循环内部，遍历所有的边，进行松弛计算。</p><p>第三，遍历途中所有的边（edge（u，v）），判断是否存在这样情况：</p><p>d（v） &gt; d (u) + w(u,v)</p><p>则返回 false，表示途中存在从源点可达的权为负的回路。</p><p>之所以需要第三部分的原因，是因为，如果存在从源点可达的权为负的回路。则 应为无法收敛而导致不能求出最短路径。</p><p>考虑右图：</p><p>经过第一次遍历后，点 B 的值变为 5，点 C 的值变为 8，这时，注意权重为－10 的边，这条边的存在，导致点 A 的值变为－2。（8＋ －10＝－2）第二次遍历后，点 B 的值变为 3，点 C 变为 6，点 A 变为－4。正是因为有一条负边在回路中，导致每次遍历后，各个点的值不断变小。</p><p>在回过来看一下 bellman－ford 算法的第三部分，遍历所有边，检查是否存在 d（v） &gt; d (u) + w(u,v)。因为第二部分循环的次数是定长的，所以如果存在无法收敛的情况，则肯定能够在第三部分中检查出来。比如此时，点 A 的值为－2，点 B 的值为 5，边 AB 的权重为 5，5 &gt; -2 + 5. 检查出来这条边没有收敛。</p><p>所以，Bellman－Ford 算法可以解决图中有权为负数的边的单源最短路径问。</p><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s; <span class="comment">//点，边，起点   </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="comment">//边       </span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">int</span> cost;   </span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line">Edge edge[N];</span><br><span class="line"><span class="keyword">int</span> dis[N], pre[N];   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman_Ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//初始化</span></span><br><span class="line">        dis[i] = (i == s ? <span class="number">0</span> : MAX);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cost)&#123; <span class="comment">//松弛（顺序一定不能反~）</span></span><br><span class="line">                dis[edge[j].v] = dis[edge[j].u] + edge[j].cost;</span><br><span class="line">                pre[edge[j].v] = edge[j].u; </span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>; <span class="comment">//判断是否含有负权回路   </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span>(dis[edge[i].v] &gt; dis[edge[i].u] + edge[i].cost)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_path</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123; <span class="comment">//打印最短路的路径</span></span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">    <span class="keyword">while</span>(root != pre[root])&#123; <span class="comment">//前驱</span></span><br><span class="line">        sta.push(root);</span><br><span class="line">        root = pre[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, root);</span><br><span class="line">    <span class="keyword">while</span>(!sta.empty())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" -&gt; %d"</span>, sta.top());</span><br><span class="line">        sta.pop(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;s))&#123;</span><br><span class="line">        fill(pre, pre + N, <span class="number">0</span>);</span><br><span class="line">        pre[s] = s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].cost);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Bellman_Ford())</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123; <span class="comment">//每个点最短路</span></span><br><span class="line">                <span class="keyword">if</span>(dis[i] == MAX)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"From %d to %d no way!\n"</span>, s, i);</span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"From %d to %d : %d\n"</span>, s, i, dis[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Path: "</span>);</span><br><span class="line">                print_path(i);   </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">"have negative circle\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>O(VE)</p><h2 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="SPFA 算法"></a>SPFA 算法</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>SPFA(Shortest Path Faster Algorithm)是 Bellman-Ford 算法的一种队列实现，减少了不必要的冗余计算。 SPFA——Shortest Path Faster Algorithm，它可以在 O(kE)的时间复杂度内求出源点到其他所有点的最短路径，可以处理负边。SPFA 的实现甚至比 Dijkstra 或者 Bellman_Ford 还要简单。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>设 Dist 代表 S 到 I 点的当前最短距离，Fa 代表 S 到 I 的当前最短路径中 I 点之前的一个点的编号。开始时 Dist 全部为+∞，只有 Dist[S]=0，Fa 全部为 0。</p><p>维护一个队列，里面存放所有需要进行迭代的点。初始时队列中只有一个点 S。用一个布尔数组记录每个点是否处在队列中。</p><p>每次迭代，取出队头的点 v，依次枚举从 v 出发的边 v-&gt;u，设边的长度为 len，判断 Dist[v]+len 是否小于 Dist[u]，若小于则改进 Dist[u]，将 Fa[u]记为 v，并且由于 S 到 u 的最短距离变小了，有可能 u 可以改进其它的点，所以若 u 不在队列中，就将它放入队尾。这样一直迭代下去直到队列变空，也就是 S 到所有的最短距离都确定下来，结束算法。若一个点入队次数超过 n，则有负权环。</p><p>SPFA 在形式上和宽度优先搜索非常类似，不同的是宽度优先搜索中一个点出了队列就不可能重新进入队列，但是 SPFA 中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进，于是再次用来改进其它的点，这样反复迭代下去。设一个点用来作为迭代点对其它点进行改进的平均次数为 k，有办法证明对于通常的情况，k 在 2 左右。</p><p>SPFA 算法（Shortest Path Faster Algorithm），也是求解单源最短路径问题的一种算法，用来解决：给定一个加权有向图 G 和源点 s，对于图 G 中的任意一点 v，求从 s 到 v 的最短路径。 SPFA 算法是 Bellman-Ford 算法的一种队列实现，减少了不必要的冗余计算，他的基本算法和 Bellman-Ford 一样，并且用如下的方法改进： 1、第二步，不是枚举所有节点，而是通过队列来进行优化 设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点 u，并且用 u 点当前的最短路径估计值对离开 u 点所指向的结点 v 进行松弛操作，如果 v 点的最短路径估计值有所调整，且 v 点不在当前的队列中，就将 v 点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。 2、同时除了通过判断队列是否为空来结束循环，还可以通过下面的方法： 判断有无负环：如果某个点进入队列的次数超过 V 次则存在负环（SPFA 无法处理带负环的图）。</p><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w, nxt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, ecnt;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">Edge edge[MAXN * MAXN];</span><br><span class="line"><span class="keyword">int</span> head[MAXN], cnt[MAXN], dis[MAXN], path[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    fill(cnt, cnt + MAXN, MAX_INT);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">        path[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[ecnt].v = v;</span><br><span class="line">    edge[ecnt].w = w;</span><br><span class="line">    edge[ecnt].nxt = head[u];</span><br><span class="line">    head[u] = ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    que.push(s);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        cnt[u]++;</span><br><span class="line">        <span class="keyword">if</span>(cnt[u] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i + <span class="number">1</span>; edge[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + edge[i].w)&#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].w;</span><br><span class="line">                path[v] = u;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">    <span class="keyword">while</span>(t != path[t])&#123;</span><br><span class="line">        sta.push(t);</span><br><span class="line">        t = path[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, t);</span><br><span class="line">    <span class="keyword">while</span>(!sta.empty())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, sta.top());</span><br><span class="line">        sta.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>O(E)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;最短路径问题是图论研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。 算法具体的形式包括：
    
    </summary>
    
      <category term="算法" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="https://blog.andrewei.me/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="算法" scheme="https://blog.andrewei.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="https://blog.andrewei.me/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://blog.andrewei.me/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
</feed>
